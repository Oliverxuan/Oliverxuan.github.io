<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Better-scroll 中无法滚动问题</title>
    <url>/2021/08/11/Better-scroll-%E4%B8%AD%E6%97%A0%E6%B3%95%E6%BB%9A%E5%8A%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在昨天我在使用 Vue 开发前端页面的时候，我遇到了在使用 better-scroll 实现页面滚动的时候无法滚动<br>经过排查，问题出在与 better-scroll 的滚动原理与实际高度之间产生矛盾（图片异步加载问题）</p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>在之前的 GoodsList 组件中，有一个加载接口图片的操作</p>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;goods-item&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;goodsItem.img&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>  /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;goods-info&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">goodsItem.name</span> &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;price&quot;</span>&gt;</span>RMB:</span><span class="template-variable">&#123;&#123; <span class="name">goodsItem.price</span> &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br></pre></td></tr></table></figure>

<p>由于 better-scroll 在计算 wrapper content 高度的时候是在一开始就会计算好 从而达到滚动的目的</p>
<p>但是 Goods list 会加载网路图片，存在一个异步问题<br>加载完后，实际的高度会远超于之前 better-scroll 计算的高度</p>
<p>从而导致 better-scroll 之间计算无效了，最终无法滚动</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;goods-item&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;goodsItem.img&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> @<span class="attr">load</span>=<span class="string">&quot;imageload&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;goods-info&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">goodsItem.name</span> &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;price&quot;</span>&gt;</span>RMB:</span><span class="template-variable">&#123;&#123; <span class="name">goodsItem.price</span> &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>在原代码 “&lt; img &gt;”标签处新增 @load=”imageload“ 监听事件</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    <span class="built_in">imageload</span>() &#123;</span><br><span class="line">      this.$bus.$<span class="built_in">emit</span>(<span class="string">&quot;itemImageLoad&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>随后在方法里将此事件发射到事件总线里面</p>
<p>注意，需要在 main.js 里注册 事件总线</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./App.vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&quot;./router&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;./store&quot;</span>;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span>;</span><br><span class="line">Vue.prototype.$bus = <span class="keyword">new</span> Vue();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h =&gt; h(App)</span><br><span class="line">&#125;).$mount(<span class="string">&quot;<span class="subst">#app</span>&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>将事件传入事件总线后 需要在 better-scroll 滚动页面里面监听事件</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">    <span class="built_in">this</span>.$bus.$<span class="literal">on</span>(<span class="string">&quot;itemImageLoad&quot;</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.$refs.scroll.scroll.refresh();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>提前设置 better-scroll 中的 refs 从而方便操作</p>
<p>最后监听到图片加载后 调用 scroll 的 refresh（）函数达到重新计算高度的目的</p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>由于之前的频繁发出事件 image load 导致 实际上会 refresh 很多次</p>
<p>此处就需要 dbounce 防抖函数来处理 ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn,delay</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> handle;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(handle)</span><br><span class="line">         handle=<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             fn()</span><br><span class="line">         &#125;,delay)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>从而达到性能优化的目的</p>
]]></content>
      <categories>
        <category>Obstacle</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello,好久不见</title>
    <url>/2021/08/11/Hello-%E5%A5%BD%E4%B9%85%E4%B8%8D%E8%A7%81/</url>
    <content><![CDATA[<h2 id="最近都去干什么了？"><a href="#最近都去干什么了？" class="headerlink" title="最近都去干什么了？"></a>最近都去干什么了？</h2><p>距离上次更新我的博客已经过去了 10 多天了，在这段时间里我开始新的征程 =&gt; 准备 9 月份的 辽宁省大学生移动开发大赛</p>
<p>我计划着开发一个护肤品测评网站，整个网站的架构为：<br>前端：Vue 全家桶，axios</p>
<p>后端：Node.js，express</p>
<p>数据库：Mysql</p>
<h2 id="期间遇到的问题困难"><a href="#期间遇到的问题困难" class="headerlink" title="期间遇到的问题困难"></a>期间遇到的问题困难</h2><p>由于我之前没有涉及过后端的接口开发，所以我在这 10 天的时间里自学了一点 Node.js 的开发基础。顺便学习了 Express，Koa 框架的基本开发。</p>
<p>到目前为止，我已成功地将写好的使用 Express 的 Js 程序用 Node.js 部署在我的云服务器上。</p>
<p>在这其中我遇到了很多的困难，例如：</p>
<ol>
<li><p>在服务器上部署合适的 Node &amp; Mysql</p>
</li>
<li><p>如何在本地通过 ssh 连接远端服务器</p>
</li>
</ol>
<ul>
<li>ssh root@ip</li>
</ul>
<ol start="3">
<li>如何在 vs code navicat-mysql ssh 连接远端数据</li>
</ol>
<ul>
<li>vs code 通过远程资源管理器</li>
<li>mysql 里设置可远端读写权限</li>
<li>navicat 在建立连接时正确写入服务器中的数据库信息</li>
<li>注意需要在服务器安全组里开放相应的端口</li>
</ul>
<ol start="4">
<li><p>建立数据库，在 Vue 里通过 axios 连接远端数据库</p>
</li>
<li><p>处理接口数据</p>
</li>
<li><p>如何在服务器上一直运行 Node 项目</p>
</li>
</ol>
<ul>
<li>npm2 管理插件</li>
</ul>
<p>在此感谢前辈们在遇到困难时留下的宝贵经验，以至于我在后续开发时遇到问题都能及时解决</p>
]]></content>
      <categories>
        <category>CodeLife</category>
      </categories>
      <tags>
        <tag>规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Js中的This指向</title>
    <url>/2021/09/08/Js%E4%B8%AD%E7%9A%84This%E6%8C%87%E5%90%91/</url>
    <content><![CDATA[<h1 id="Js-中什么是-This？"><a href="#Js-中什么是-This？" class="headerlink" title="Js 中什么是 This？"></a>Js 中什么是 This？</h1><h2 id="为什么需要-this"><a href="#为什么需要-this" class="headerlink" title="为什么需要 this?"></a>为什么需要 this?</h2><p>学过 Java 的都明白，this 出现于类的调用中，我们常常可以用 this.的方式调用类的属性，方法。</p>
<p>但是 Js，this 的用法可比 Java 中更灵活。</p>
<p>正也是因为灵活，让 Js 中的 this 常常让人摸不清头脑。</p>
<p>在 Js 中我们可以通过 this 方法，在不同的情况下，拿到不同的对象。有可能是全局对象(window)，也有可能是一个 Obj 对象,或者我们可以直接给我们的 this 指定绑定上一个对象。</p>
<h2 id="this-指向什么呢？"><a href="#this-指向什么呢？" class="headerlink" title="this 指向什么呢？"></a>this 指向什么呢？</h2><ul>
<li><p>在<strong>全局</strong>的情况下，this 指向 window</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">//window</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Oliver&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.name) <span class="comment">//oliver</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name) <span class="comment">//oliver</span></span><br></pre></td></tr></table></figure></li>
<li><p>但是，开发中很少直接在全局作用域下去使用 this，通常都是在<strong>函数中使用</strong>。</p>
<ol>
<li><p>所有的函数在被调用时，都会创建一个执行上下文：</p>
</li>
<li><p>这个上下文中记录着函数的调用栈、AO 对象等；</p>
</li>
<li><p>this 也是其中的一条记录；</p>
</li>
</ol>
</li>
</ul>
<p>我们先来看一个让人困惑的问题：</p>
<p>定义一个函数，我们采用三种不同的方式对它进行调用，它产生了<strong>三种不同</strong>的结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">//window  默认绑定</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo,</span><br><span class="line">&#125;</span><br><span class="line">obj.foo() <span class="comment">//obj对象  隐式绑定</span></span><br><span class="line"></span><br><span class="line">foo.apply(<span class="string">&#x27;abc&#x27;</span>) <span class="comment">//abc  显式绑定</span></span><br></pre></td></tr></table></figure>

<p>这个的案例可以给我们什么样的启示呢？</p>
<ol>
<li><p>函数在调用时，JavaScript 会默认给 this 绑定一个值；</p>
</li>
<li><p>this 的绑定和<strong>定义</strong>的位置（编写的位置）没有关系；</p>
</li>
<li><p>this 的绑定和<strong>调用方式</strong>以及<strong>调用的位置</strong>有关系；</p>
</li>
<li><p>this 是在<strong>运行时被绑定</strong>的；</p>
</li>
</ol>
<h3 id="重要结论："><a href="#重要结论：" class="headerlink" title="重要结论："></a>重要结论：</h3><ol>
<li><strong><em>this 的指向，和它所处的位置无关和调用位置有关！</em></strong></li>
<li><strong>this 在被调用运行的时候，才会给他 this 绑定一个值</strong>！</li>
</ol>
<h3 id="this-绑定规则："><a href="#this-绑定规则：" class="headerlink" title="this 绑定规则："></a>this 绑定规则：</h3><h4 id="绑定一：默认绑定"><a href="#绑定一：默认绑定" class="headerlink" title="绑定一：默认绑定"></a>绑定一：默认绑定</h4><h4 id="绑定二：隐式绑定"><a href="#绑定二：隐式绑定" class="headerlink" title="绑定二：隐式绑定"></a>绑定二：隐式绑定</h4><h4 id="绑定三：显示绑定"><a href="#绑定三：显示绑定" class="headerlink" title="绑定三：显示绑定"></a>绑定三：显示绑定</h4><h4 id="绑定四：new-绑定"><a href="#绑定四：new-绑定" class="headerlink" title="绑定四：new 绑定"></a>绑定四：new 绑定</h4><h2 id="规则一：默认绑定"><a href="#规则一：默认绑定" class="headerlink" title="规则一：默认绑定"></a><strong>规则一：默认绑定</strong></h2><h3 id="什么情况下使用默认绑定呢？"><a href="#什么情况下使用默认绑定呢？" class="headerlink" title="什么情况下使用默认绑定呢？"></a>什么情况下使用默认绑定呢？</h3><p><strong>独立的</strong>函数调用</p>
<p>我们可以理解成<strong>函数没有被绑定到某个对象上进行调用</strong></p>
<p><em>下面是一些默认绑定演示：</em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. window</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.  window</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  foo1()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  foo2()</span><br><span class="line">&#125;</span><br><span class="line">foo3()</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. window</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = obj.foo <span class="comment">//将该对象中的方法传递给了bar  那么其实bar就是一个单独调用</span></span><br><span class="line">bar()</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. window</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = foo() <span class="comment">//实质上就是在调用bar 然后将bar传递给了fn</span></span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>

<p><strong>默认绑定，独立函数调用</strong></p>
<h2 id="规则二：隐式绑定"><a href="#规则二：隐式绑定" class="headerlink" title="规则二：隐式绑定"></a>规则二：隐式绑定</h2><p>另外一种比较常见的调用方式是<strong>通过某个对象进行调用</strong>的：</p>
<p>也就是它的调用位置中，是<strong>通过某个对象发起的函数调用。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">19</span>,</span><br><span class="line">  <span class="attr">fn</span>: foo,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用对象调用的方式来执行函数。</span></span><br><span class="line">obj.fn() <span class="comment">//在对象里，将foo函数传递给了fn 实质上就是通过obj在调用</span></span><br></pre></td></tr></table></figure>

<p>隐式绑定有前提条件：</p>
<ol>
<li><p>必须在调用的对象<strong>内部</strong>有一个对函数的<strong>引用</strong>（比如一个属性）；</p>
</li>
<li><p>如果<strong>没有</strong>这样的<strong>引用</strong>，在进行调用时，会报<strong>找不到该函数的错误</strong>；</p>
</li>
<li><p>正是<strong>通过</strong>这个<strong>引用</strong>，间接的将<strong>this 绑定</strong>到了这个<strong>对象</strong>上；</p>
</li>
</ol>
<h2 id="规则三：显示绑定"><a href="#规则三：显示绑定" class="headerlink" title="规则三：显示绑定"></a>规则三：显示绑定</h2><p>如果我们不希望在 <strong>对象内部</strong> 包含这个函数的引用，同时又希望在这个对象上进行强制调用，该怎么做呢？</p>
<p>JavaScript 所有的函数<strong>都可以使用</strong>call 和 apply 方法（这个和 Prototype 有关）。</p>
<ul>
<li><p>其实非常简单，第一个参数是相同的，后面的参数，apply 为数组，call 为参数列表；</p>
</li>
<li><p>这两个函数的<strong>第一个参数</strong>都要求是一个<strong>对象</strong>，这个对象的作用是什么呢？就是<strong>给 this 准备</strong>的。</p>
</li>
<li><p>在调用这个函数时，会<strong>将 this 绑定到这个传入的对象上</strong>。</p>
</li>
<li><p>因为上面的过程，我们<strong>明确的绑定了 this 指向的对象</strong>，所以称之为 <strong>显示绑定</strong>。</p>
</li>
</ul>
<h3 id="通过-call-或者-apply-绑定-this-对象"><a href="#通过-call-或者-apply-绑定-this-对象" class="headerlink" title="通过 call 或者 apply 绑定 this 对象"></a>通过 call 或者 apply 绑定 this 对象</h3><ul>
<li>call（ ）绑定，其第一参数为指定的 this 绑定对象，第二，三，N，参数为将要传入的参数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num1, num2, num3</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(num1, num2, num3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.call(<span class="string">&#x27;call&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">//[String: &#x27;call&#x27;] 1 2 3</span></span><br><span class="line">foo.call(&#123; <span class="attr">name</span>: <span class="string">&#x27;yzx&#x27;</span> &#125;) <span class="comment">//&#123; name: &#x27;yzx&#x27; &#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>apply（ ）绑定，其第一参数为指定 this 绑定对象，第二参数为一个数组，其中包含了将要传入的参数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num1, num2, num3</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(num1, num2, num3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.apply(<span class="string">&#x27;apply&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">//[String: &#x27;apply&#x27;]  1 2 3</span></span><br><span class="line">foo.apply(&#123; <span class="attr">name</span>: <span class="string">&#x27;yzx&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;) <span class="comment">//&#123; name: &#x27;yzx&#x27;, age: 18 &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="通过-bind-方法实现显示绑定"><a href="#通过-bind-方法实现显示绑定" class="headerlink" title="通过 bind 方法实现显示绑定"></a>通过 bind 方法实现显示绑定</h3><ul>
<li>我们可以通过.bind 方法实现显示绑定</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span>, <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">  <span class="attr">fn</span>: foo,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">//window</span></span><br><span class="line">obj.fn() <span class="comment">//obj</span></span><br><span class="line"><span class="keyword">var</span> fn = obj.fn.bind(&#123; <span class="attr">name</span>: <span class="string">&#x27;Bind&#x27;</span> &#125;)</span><br><span class="line">fn() <span class="comment">//Bind</span></span><br></pre></td></tr></table></figure>

<h2 id="规则四：new-绑定"><a href="#规则四：new-绑定" class="headerlink" title="规则四：new 绑定"></a>规则四：new 绑定</h2><p>JavaScript 中的函数可以当做一个类的构造函数来使用，也就是使用 new 关键字。</p>
<p>使用 new 关键字来调用函数是，会执行如下的操作：</p>
<ol>
<li><p>创建一个全新的对象；</p>
</li>
<li><p>这个新对象会被执行 prototype 连接；</p>
</li>
<li><p>这个新对象会绑定到函数调用的 this 上（this 的绑定在这个步骤完成）；</p>
</li>
<li><p>如果函数没有返回其他对象，表达式会返回这个新对象；</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">//Person&#123;&#125;</span></span><br><span class="line">  <span class="built_in">this</span>.name = name <span class="comment">//Person&#123;name:Oliverxuan&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;Oliverxuan&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p)</span><br></pre></td></tr></table></figure>

<h1 id="内置函数-this-绑定"><a href="#内置函数-this-绑定" class="headerlink" title="内置函数 this 绑定"></a>内置函数 this 绑定</h1><h2 id="setTimeout（）"><a href="#setTimeout（）" class="headerlink" title="setTimeout（）"></a>setTimeout（）</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. setTimeout</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">//window</span></span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure>

<h2 id="监听点击"><a href="#监听点击" class="headerlink" title="监听点击"></a>监听点击</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> boxDiv = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;box&#x27;</span>)</span><br><span class="line">boxDiv.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">//boxDiv&#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组：filter-map-forEach-等高阶函数"><a href="#数组：filter-map-forEach-等高阶函数" class="headerlink" title="数组：filter/map/forEach 等高阶函数"></a>数组：filter/map/forEach 等高阶函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;cba&#x27;</span>]</span><br><span class="line"></span><br><span class="line">names.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item, <span class="built_in">this</span>) <span class="comment">//abc&#123;&#125;</span></span><br><span class="line">&#125;, <span class="string">&#x27;abc&#x27;</span>) <span class="comment">//此处进行了this绑定</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> names = [<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;cba&#x27;</span>]</span><br><span class="line">names.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item, <span class="built_in">this</span>) <span class="comment">// window</span></span><br><span class="line">&#125;) <span class="comment">//此处没有进行this的绑定</span></span><br></pre></td></tr></table></figure>

<h1 id="规则优先级"><a href="#规则优先级" class="headerlink" title="规则优先级"></a>规则优先级</h1><h2 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h2><p>学习了四条规则，接下来开发中我们只需要去查找函数的调用应用了哪条规则即可，但是如果一个函数调用位置应用了多条规则，优先级谁更高呢？</p>
<p><strong>1. 默认规则的优先级最低</strong></p>
<ul>
<li>毫无疑问，默认规则的优先级是最低的，因为存在其他规则时，就会通过其他规则的方式来绑定 this</li>
</ul>
<p><strong>2. 显示绑定优先级高于默认绑定</strong></p>
<ul>
<li>代码测试：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.foo() <span class="comment">// name:&#123; name: &#x27;obj&#x27;, foo: [Function: foo] &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>3 .显示绑定优先级高于隐式绑定</strong></p>
<ul>
<li>代码测试：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.foo.call(<span class="string">&#x27;abc&#x27;</span>) <span class="comment">//[String: &#x27;abc&#x27;]</span></span><br><span class="line">obj.foo.apply(<span class="string">&#x27;abc&#x27;</span>) <span class="comment">//[String: &#x27;abc&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. bind 的优先级，高于隐式绑定</strong></p>
<ul>
<li>代码测试：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo.bind(<span class="string">&#x27;aaa&#x27;</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.foo() <span class="comment">//[String: &#x27;aaa&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><strong>6. new 绑定优先级高于显示绑定</strong></p>
<ul>
<li>new 绑定和<strong>call、apply 是不允许同时使用的</strong>，所以不存在谁的优先级更高</li>
<li>new 绑定可以和 bind 一起使用，new 绑定优先级更高</li>
<li>代码测试：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> obj.foo() <span class="comment">//foo&#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>7. 小小总结</strong></p>
<ul>
<li>bind 优先级比较高</li>
<li>new &gt; 显示 &gt; 隐式 &gt; 默认绑定（独立函数调用）</li>
</ul>
<h2 id="规则之外"><a href="#规则之外" class="headerlink" title="规则之外"></a>规则之外</h2><h3 id="常规情况"><a href="#常规情况" class="headerlink" title="常规情况"></a>常规情况</h3><ol>
<li><p>忽略显示绑定</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.apply(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line">foo.apply(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">foo.apply(<span class="literal">null</span>) <span class="comment">//window 全局对象</span></span><br><span class="line">foo.apply(<span class="literal">undefined</span>) <span class="comment">//window 全局对象</span></span><br><span class="line">foo.bind(<span class="literal">null</span>) <span class="comment">//window 全局对象</span></span><br><span class="line">foo.bind(<span class="literal">undefined</span>) <span class="comment">//window 全局对象</span></span><br><span class="line"><span class="keyword">var</span> bar = foo.bind(<span class="literal">null</span>)</span><br><span class="line">bar()</span><br></pre></td></tr></table></figure></li>
<li><p>间接函数引用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj2&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line">obj2.bar = obj.foo</span><br><span class="line">obj2.bar() <span class="comment">//&#123; name: &#x27;obj2&#x27;, bar: [Function: foo] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj2&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line">obj2.bar = obj.foo</span><br><span class="line">obj2.bar()(</span><br><span class="line">  <span class="comment">//&#123; name: &#x27;obj2&#x27;, bar: [Function: foo] &#125;</span></span><br><span class="line">  (obj2.bar = obj.foo)</span><br><span class="line">)() <span class="comment">// 没有 分号（；）无法运行 与上面的代码看成整体</span></span><br><span class="line">;(obj2.bar = obj.foo)() <span class="comment">// 有 分号（；）window 独立调用</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><h4 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h4><ul>
<li><strong>箭头函数</strong>中 是<strong>不会绑定 this/arguments 属性</strong></li>
<li>箭头函数<strong>不能作为函数构造器</strong>使用</li>
<li><strong>四大规则 对箭头函数不适用</strong></li>
</ul>
<h4 id="简写："><a href="#简写：" class="headerlink" title="简写："></a>简写：</h4><ol>
<li><p>如果参数只有一个 小括号可以省略</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">nums.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>如果函数的函数执行体只有一行代码，大括号也可以省略</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">nums.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="built_in">console</span>.log(item))</span><br><span class="line"><span class="comment">// 并且会默认地将代码的执行结果作为返回值</span></span><br><span class="line"><span class="keyword">var</span> num = nums.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> item % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(num)</span><br></pre></td></tr></table></figure></li>
<li><p>如果一个箭头函数它的返回值，只有一行代码，且只返回一个对象 如果想简写 返回对象 需要在外层套一个（）以示整体</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="function">() =&gt;</span> (&#123; <span class="attr">name</span>: <span class="string">&#x27;oliver&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>JS 中的 this 十分灵活，需要结合各种情况进行分析。但是万变不离其宗。掌握特性，方可以一眼看穿真相！</p>
<p>JS 的优点是灵活，缺点也是灵活。想要真正掌握 JS 中的晦涩语法。还需要继续修炼内功</p>
<p>感谢 coderwhy 老师的课程以及公众号，能够让我细节地，全面地学习 JS</p>
]]></content>
      <categories>
        <category>底层逻辑</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Js常用数组高阶函数</title>
    <url>/2021/09/06/Js%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>js 中有很多高阶函数，能在日常的代码编写工作中提高效率。下面列举一些常用 js 的数组高阶函数</p>
<h2 id="FOO-数组"><a href="#FOO-数组" class="headerlink" title="FOO 数组"></a>FOO 数组</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = [<span class="number">10</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">100</span>, <span class="number">55</span>]</span><br></pre></td></tr></table></figure>

<h3 id="filter-过滤"><a href="#filter-过滤" class="headerlink" title="filter: 过滤"></a>filter: 过滤</h3><p>返回布尔类型 可以传递三个值 item 当前的的元素，index 当前数组下标， arr 当前整个数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组取偶操作</span></span><br><span class="line"><span class="keyword">var</span> numbers = nums.filter(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(numbers)</span><br></pre></td></tr></table></figure>

<h3 id="map-映射"><a href="#map-映射" class="headerlink" title="map: 映射"></a>map: 映射</h3><p>对所有的 item 进行操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对每个item进行*10操作</span></span><br><span class="line"><span class="keyword">var</span> nums2 = nums.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item * <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(nums2)</span><br></pre></td></tr></table></figure>

<h3 id="forEach-迭代"><a href="#forEach-迭代" class="headerlink" title="forEach: 迭代"></a>forEach: 迭代</h3><p>无返回值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历数组，无返回值！</span></span><br><span class="line">nums.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="find-findIndex-查找"><a href="#find-findIndex-查找" class="headerlink" title="find/findIndex :查找"></a>find/findIndex :查找</h3><p>查找 item/返还该 item/itemIndex</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> item = nums.find(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item == <span class="number">11</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(item)</span><br></pre></td></tr></table></figure>

<h3 id="reduce-累加"><a href="#reduce-累加" class="headerlink" title="reduce :累加"></a>reduce :累加</h3><p>preValue 前数据;</p>
<p>0:基础数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组累加操作</span></span><br><span class="line"><span class="keyword">var</span> total = nums.reduce(<span class="function">(<span class="params">preValue, item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> preValue + item</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(total)</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>js 中很多高阶函数，我们还需继续探索。慢慢感受 js 的魅力！</p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>axios拦截</title>
    <url>/2021/08/30/axios%E6%8B%A6%E6%88%AA/</url>
    <content><![CDATA[<h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><p>实现在 axios 每次请求/响应时，对请求/响应进行相关的处理。我们把这种处理方式称之为拦截。</p>
<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><ol>
<li>request.js 文件的封装</li>
</ol>
<h4 id="首先我们要将-axios-主要的请求封装在-request-js-文件中，这样我们可以降低代码的耦合度，提高整体的效率，方便后期的维护。"><a href="#首先我们要将-axios-主要的请求封装在-request-js-文件中，这样我们可以降低代码的耦合度，提高整体的效率，方便后期的维护。" class="headerlink" title="首先我们要将 axios 主要的请求封装在 request.js 文件中，这样我们可以降低代码的耦合度，提高整体的效率，方便后期的维护。"></a>首先我们要将 axios 主要的请求封装在 request.js 文件中，这样我们可以降低代码的耦合度，提高整体的效率，方便后期的维护。</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将axios插件导入</span></span><br><span class="line"><span class="keyword">import</span> axios from <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建axios方法，并将该方法导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> request(<span class="keyword">config</span>) &#123;</span><br><span class="line">  <span class="comment">// 1.创建axios的实例</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">instance</span> = axios<span class="variable">.create</span>(&#123;</span><br><span class="line">    baseURL: <span class="string">&quot;*******&quot;</span>,</span><br><span class="line">    timeout: <span class="number">5000</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 2.设立请求/响应拦截</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.发送真正的网络请求</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">instance</span>(<span class="keyword">config</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>axios 拦截器</li>
</ol>
<ul>
<li>请求拦截</li>
</ul>
<p>可以在任何的请求上进行修饰，改变。此处我以添加 Authorization：Token 的方法为例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用axios的请求拦截方法</span></span><br><span class="line">instance.interceptors.request.use(</span><br><span class="line">  <span class="comment">//对参数进行处理</span></span><br><span class="line">    <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//具体操作</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">localStorage</span>.getItem(<span class="string">&quot;Authorization&quot;</span>)) &#123;</span><br><span class="line">        config.headers.Authorization = <span class="built_in">localStorage</span>.getItem(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//最后注意需要返回修饰后的参数</span></span><br><span class="line">      <span class="keyword">return</span> config;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//如果请求是错误的，我们将异常抛出</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>

<ul>
<li>响应拦截</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//axios响应拦截方法</span></span><br><span class="line">instance.interceptors.response.use(</span><br><span class="line">    <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//获取响应参数，并返回</span></span><br><span class="line">      <span class="keyword">return</span> res.data;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//如果返还错误，提取相关的Status响应码，进行错误提示</span></span><br><span class="line">      <span class="keyword">const</span> &#123; response &#125; = err;</span><br><span class="line">      <span class="keyword">if</span> ((response.status = <span class="number">401</span>)) &#123;</span><br><span class="line">        <span class="built_in">localStorage</span>.removeItem(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="built_in">localStorage</span>.removeItem(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">        <span class="built_in">localStorage</span>.removeItem(<span class="string">&quot;userId&quot;</span>);</span><br><span class="line">        alert(<span class="string">&quot;请登陆后再使用哦～&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>后续调用</li>
</ol>
<p>如需对接后端接口，仅需要创建相关 js 文件，并写入具体请求方法。</p>
<ul>
<li>user.js</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入我们之前封装好的request文件</span></span><br><span class="line"><span class="keyword">import</span> &#123; request &#125; <span class="keyword">from</span> <span class="string">&quot;./request&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写具体的对接接口的方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">GetUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> request(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;/users/name&quot;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传参类：</span></span><br><span class="line"><span class="comment">//将需要的参数写在方法内</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ChangeUserSkin</span>(<span class="params">flag, <span class="keyword">type</span>, fix</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> request(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;/users/skintest&quot;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">    <span class="comment">//将所需的数据创建好。</span></span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">flag</span>: flag,</span><br><span class="line">      <span class="attr">type</span>: <span class="keyword">type</span>,</span><br><span class="line">      <span class="attr">fix</span>: fix</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>axios 在日常的 vue 开发中是使用频率很高的组件，用来进行前后端数据交互工作。整体上并不难。需要我们熟练掌握相关的方法，逻辑。其中也需要注意代码的规范，体现封装性。</p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title>mmjd项目的完成情况</title>
    <url>/2021/08/25/mmjd%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%AE%8C%E6%88%90%E6%83%85%E5%86%B5/</url>
    <content><![CDATA[<h2 id="项目进度"><a href="#项目进度" class="headerlink" title="项目进度:"></a>项目进度:</h2><p>最近一直在做那个护肤品测评网站，可谓是从无到有，功能也都在慢慢实现。目前已经完成了 90% 剩余的就是 Debug 和样式</p>
<h2 id="接口功能："><a href="#接口功能：" class="headerlink" title="接口功能："></a>接口功能：</h2><h3 id="不多说了，直接上图！"><a href="#不多说了，直接上图！" class="headerlink" title="不多说了，直接上图！"></a>不多说了，直接上图！</h3><ol>
<li>后端接口：<br><img src="/2021/08/25/mmjd%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%AE%8C%E6%88%90%E6%83%85%E5%86%B5/user.png" alt="接口功能图"><br><img src="/2021/08/25/mmjd%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%AE%8C%E6%88%90%E6%83%85%E5%86%B5/end.png" alt="接口功能图"></li>
</ol>
<p>真的是完完整地做完了整个项目的后端接口。从中真的学会了很多！慢慢也熟悉了 Node.js + Koa 开发接口的开发逻辑。</p>
<ol start="2">
<li>Mysql：<br><img src="/2021/08/25/mmjd%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%AE%8C%E6%88%90%E6%83%85%E5%86%B5/mysql1.png" alt="mysql"><br><img src="/2021/08/25/mmjd%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%AE%8C%E6%88%90%E6%83%85%E5%86%B5/mysql2.png" alt="mysql"><br><img src="/2021/08/25/mmjd%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%AE%8C%E6%88%90%E6%83%85%E5%86%B5/mysql3.png" alt="mysql"></li>
</ol>
<p>从中也重新回忆起了很多的 sql 语句（真的好久不用生疏了！）比如：left join ，json_object….</p>
<h2 id="前端界面："><a href="#前端界面：" class="headerlink" title="前端界面："></a>前端界面：</h2><p><img src="/2021/08/25/mmjd%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%AE%8C%E6%88%90%E6%83%85%E5%86%B5/font1.png" alt="font"><br>现在的前端界面真的奇丑无比，等着这两天我调好了我们再看！</p>
<h2 id="技术栈："><a href="#技术栈：" class="headerlink" title="技术栈："></a>技术栈：</h2><ol>
<li>前端：Html JavaScript CSS Vue Vuex VueRouter axios Webpack node.js Bootstrap</li>
<li>后端：node.js Koa mysql</li>
<li>数据库: mysql</li>
</ol>
<h2 id="收获："><a href="#收获：" class="headerlink" title="收获："></a>收获：</h2><p>通过这次完完整整地独自开发前后端的项目，很多东西真的就是要亲自来才能深刻体会！<br>希望自己以后能参与或创造更多的项目！</p>
<h2 id="开源地址"><a href="#开源地址" class="headerlink" title="开源地址:"></a>开源地址:</h2><ol>
<li>前端：<br><a href="https://github.com/Oliverxuan/mmjd">https://github.com/Oliverxuan/mmjd</a></li>
<li>后端：<br><a href="https://github.com/Oliverxuan/MMJD-node">https://github.com/Oliverxuan/MMJD-node</a></li>
</ol>
]]></content>
      <categories>
        <category>CodeLife</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo s 时4000端口被占用问题</title>
    <url>/2021/07/25/hexo-s-%E6%97%B64000%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>hexo s 启动的时候遇到了 4000 端口无法创建使用的问题。<br>具体打开 localhost：4000 发现 4000 端口下 hexo 依然在运行！</p>
<h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><p>(mac 环境):</p>
<ol>
<li>sudo lsof -i tcp:4000<br><strong>查询当前端口的进程</strong></li>
<li>报错：</li>
</ol>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">COMMAND</span>   PID USER   FD   TYPE             DEVICE SIZE/<span class="literal">OFF</span> NODE NAME</span><br><span class="line"><span class="attribute">node</span>    <span class="number">19087</span> root   <span class="number">23</span>u  IPv<span class="number">6</span> <span class="number">0</span>xe<span class="number">0</span>d<span class="number">367</span>ae<span class="number">3505</span>eeb<span class="number">3</span>      <span class="number">0</span>t<span class="number">0</span>  TCP *:terabase (LISTEN)</span><br></pre></td></tr></table></figure>

<p>发现进程 19087</p>
<ol start="3">
<li>sudo kill 19087</li>
</ol>
<p><strong>再次打开就没有 hexo 的页面了</strong></p>
<h2 id="最后成功在-4000-默认端口下启动-hexo"><a href="#最后成功在-4000-默认端口下启动-hexo" class="headerlink" title="最后成功在 4000 默认端口下启动 hexo"></a>最后成功在 4000 默认端口下启动 hexo</h2>]]></content>
      <categories>
        <category>Obstacle</category>
      </categories>
      <tags>
        <tag>技术踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>node.js 用户登陆初体验</title>
    <url>/2021/08/14/node-js-%E7%94%A8%E6%88%B7%E7%99%BB%E9%99%86%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<h2 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h2><p>写一个接口，实现从用户输入中获得数据</p>
<h2 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h2><h4 id="文件夹功能分类"><a href="#文件夹功能分类" class="headerlink" title="文件夹功能分类"></a>文件夹功能分类</h4><ol>
<li>app (app 操作文件夹)</li>
</ol>
<ul>
<li>index.js (导入所使用的插件，中间件)</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入所需的插件，中间件</span></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="keyword">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="keyword">require</span>(<span class="string">&#x27;koa-bodyparser&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> userRouter = <span class="keyword">require</span>(<span class="string">&#x27;../router/user.router&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化Koa对象</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册/使用插件，中间件</span></span><br><span class="line">app.<span class="keyword">use</span>(bodyParser())</span><br><span class="line">app.<span class="keyword">use</span>(userRouter.routes())</span><br><span class="line">app.<span class="keyword">use</span>(userRouter.allowedMethods())</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出app 以便其他模块使用</span></span><br><span class="line">module.exports = app</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>config.js (配置操作)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入插件</span></span><br><span class="line"><span class="keyword">const</span> dotenv = require(<span class="string">&#x27;dotenv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用插件的方法，导入写好的配置文件（.env）</span></span><br><span class="line">dotenv.config()</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span>.<span class="keyword">exports</span> = &#123; APP_PORT &#125; = process.env</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>main.js (程序的总入口)</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入之前的Koa实例化的对象app。 导入配置文件</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">&#x27;./app&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&#x27;./app/config&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建服务器，并利用config的APP_PORT参数</span></span><br><span class="line">app.listen(config.APP_PORT, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`服务器在<span class="subst">$&#123;config.APP_PORT&#125;</span>端口已启动`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>router (所有的路由管理文件夹)</li>
</ol>
<ul>
<li>user.router.js (user 的路由管理)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路由相关的js 注册接口适用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//导入koa-router组件</span></span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>)</span><br><span class="line"><span class="comment">//导入方法</span></span><br><span class="line"><span class="keyword">const</span> &#123; create &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../controller/user.controller&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册路由 其路径为/users</span></span><br><span class="line"><span class="keyword">const</span> userRouter = <span class="keyword">new</span> Router(&#123; <span class="attr">prefix</span>: <span class="string">&#x27;/users&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置路由的响应方式，响应方法</span></span><br><span class="line">userRouter.post(<span class="string">&#x27;/&#x27;</span>, create)</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出路由</span></span><br><span class="line"><span class="built_in">module</span>.exports = userRouter</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>controller (管理不同路径下的不同的情况下的方法，操作)</li>
</ol>
<ul>
<li>user.controller.js (user 的一些方法，操作)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入写好的方法</span></span><br><span class="line"><span class="keyword">const</span> service = <span class="built_in">require</span>(<span class="string">&#x27;../service/user.service&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建类 其中包含了不同情况下的不同方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">create</span>(<span class="params">ctx, next</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//获取用户请求的参数</span></span><br><span class="line">    <span class="keyword">const</span> user = ctx.request.body</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询数据</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> service.create(user)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回数据</span></span><br><span class="line">    ctx.body = result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> UserController()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>service (业务层，其一般对接着 mysql 数据库操作)</li>
</ol>
<ul>
<li>user.service.js</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">create</span>(<span class="params">user</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;将用户数据保存到数据库中&#x27;</span>, user)</span><br><span class="line">    <span class="comment">//将user存储到数据库中</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;创建用户成功&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> UserService()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>utils (工具类)</p>
</li>
<li><p>.env (配置文件)</p>
</li>
</ol>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务器端口号</span></span><br><span class="line"><span class="attr">APP_PORT</span>=<span class="number">8000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="实现结果"><a href="#实现结果" class="headerlink" title="实现结果"></a>实现结果</h2><p><img src="/2021/08/14/node-js-%E7%94%A8%E6%88%B7%E7%99%BB%E9%99%86%E5%88%9D%E4%BD%93%E9%AA%8C/1.png" alt="node 运行结果"><br><img src="/2021/08/14/node-js-%E7%94%A8%E6%88%B7%E7%99%BB%E9%99%86%E5%88%9D%E4%BD%93%E9%AA%8C/2.png" alt="接口响应结果"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次实现了一个小功能，主要目的是想让自己理清楚这个文件与文件之间的关系，以及不同的文件之间的分工。</p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>vue表单提交时自动刷新</title>
    <url>/2021/08/31/vue%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4%E6%97%B6%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在之前 mmjd 的项目中，我设计了一个登陆的界面。发现当第一次提交的时候，会默认刷新一次。导致用户提交的表单是空的。从而报错。</p>
<p>这直接导致了很不好的用户体验。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>vue 中使用表单 form 默认提交行为是刷新一下，在这儿我们使用事件修饰符 prevent 来阻止 form 表单的默认行为</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;input <span class="attribute">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attribute">value</span>=<span class="string">&quot;提交&quot;</span> @click.<span class="attribute">prevent</span>=<span class="string">&#x27;had&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个点似曾相识，在以前学习的时候老师好像提到过。自己没注意到细节上的东西。反向说明了自己对 vue 的一些细节，和项目经验不足。需要继续提高！</p>
]]></content>
      <categories>
        <category>Obstacle</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>创建用户并验证合法性</title>
    <url>/2021/08/16/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E5%B9%B6%E9%AA%8C%E8%AF%81%E5%90%88%E6%B3%95%E6%80%A7/</url>
    <content><![CDATA[<h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><p>实现一个接口，可以读取用户的输入信息，并检查其合法性。<br>如果其合法，将其录入数据库中，如果不合法，返回其不合法的类型。</p>
<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><h3 id="1-创建数据库："><a href="#1-创建数据库：" class="headerlink" title="1.创建数据库："></a>1.创建数据库：</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `users`(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line"><span class="type">name</span> <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line"><span class="keyword">password</span> <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">createAt <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">updateAt <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="2-连接数据库"><a href="#2-连接数据库" class="headerlink" title="2.连接数据库"></a>2.连接数据库</h3><h4 id="1-配置数据库信息"><a href="#1-配置数据库信息" class="headerlink" title="1.配置数据库信息"></a>1.配置数据库信息</h4><ol>
<li>将数据库的配置写入 .env 文件中</li>
</ol>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mysql配置</span></span><br><span class="line"><span class="attr">MYSQL_HOST</span>=xxxxxx</span><br><span class="line"><span class="attr">MYSQL_PORT</span>=xxxx</span><br><span class="line"><span class="attr">MYSQL_DATABASE</span>=xxxxx</span><br><span class="line"><span class="attr">MYSQL_ROOT</span>=xxxxx</span><br><span class="line"><span class="attr">MYSQL_PASSWORD</span>=xxxxxx</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将数据库信息在 config.js 文件中导入</li>
</ol>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line"><span class="built_in">  APP_PORT,</span></span><br><span class="line"><span class="built_in">  MYSQL_HOST,</span></span><br><span class="line"><span class="built_in">  MYSQL_PORT,</span></span><br><span class="line"><span class="built_in">  MYSQL_DATABASE,</span></span><br><span class="line"><span class="built_in">  MYSQL_ROOT,</span></span><br><span class="line"><span class="built_in">  MYSQL_PASSWORD,</span></span><br><span class="line">&#125; = process.env</span><br></pre></td></tr></table></figure>

<h3 id="2-建立数据库连接"><a href="#2-建立数据库连接" class="headerlink" title="2.建立数据库连接"></a>2.建立数据库连接</h3><ol>
<li>在全局文件夹（app）里新建关于数据库操作的 database.js 文件</li>
<li>导入 mysql 插件</li>
</ol>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">const</span> <span class="variable">mysql</span> = <span class="function"><span class="title">require</span>(<span class="string">&#x27;mysql2&#x27;</span>)</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>将配置信息导入</li>
</ol>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">const</span> <span class="variable">config</span> = <span class="function"><span class="title">require</span>(<span class="string">&#x27;./config&#x27;</span>)</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>创建数据库连接池,并将相关配置导入</li>
</ol>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> connections = mysql.<span class="built_in">createPool</span>(&#123;</span><br><span class="line">  host: config.MYSQL_HOST,</span><br><span class="line">  port: config.MYSQL_PORT,</span><br><span class="line">  database: config.MYSQL_DATABASE,</span><br><span class="line">  user: config.MYSQL_ROOT,</span><br><span class="line">  password: config.MYSQL_PASSWORD,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>取得数据库连接，并设置数据库启动提示</li>
</ol>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">connections.getConnection(<span class="function"><span class="params">(err, conn)</span> =&gt;</span> &#123;</span><br><span class="line">  conn.connect(<span class="function"><span class="params">(err)</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;数据库连接失败!&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;数据库连接成功！&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>将 connections 导出，从而达到封装。</li>
</ol>
<figure class="highlight mercury"><table><tr><td class="code"><pre><span class="line">//操作都是建立在connections.<span class="keyword">promise</span>（）上的，所以在导出的时候连带<span class="keyword">promise</span>()</span><br><span class="line"><span class="keyword">module</span>.exports <span class="built_in">=</span> connections.<span class="keyword">promise</span>()</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>在 main.js 中引入 database.js，从而达到加载目的</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">require</span><span class="params">(<span class="string">&#x27;./app/database&#x27;</span>)</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="8">
<li>测试连接,得到回应：<br><img src="/2021/08/16/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E5%B9%B6%E9%AA%8C%E8%AF%81%E5%90%88%E6%B3%95%E6%80%A7/database.png" alt="数据库连接成功"></li>
</ol>
<h3 id="3-实现数据库的存入"><a href="#3-实现数据库的存入" class="headerlink" title="3.实现数据库的存入"></a>3.实现数据库的存入</h3><ol>
<li>实现 create 方法</li>
</ol>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询数据</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">result</span> = <span class="keyword">await</span> service.create(user)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 service 的 user.service.js 中写入数据库操作</li>
</ol>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">//操作都是异步的所以要加上async await</span><br><span class="line">async <span class="keyword">create</span>(<span class="keyword">user</span>) &#123;</span><br><span class="line">  //从<span class="keyword">user</span>中获取<span class="keyword">user</span>，<span class="keyword">password</span></span><br><span class="line">    const &#123; <span class="type">name</span>, <span class="keyword">password</span> &#125; = <span class="keyword">user</span></span><br><span class="line">    //<span class="keyword">sql</span>语句</span><br><span class="line">    const <span class="keyword">statement</span> = <span class="string">&#x27;INSERT INTO users (name,password) VALUES (?,?);&#x27;</span></span><br><span class="line">    //执行<span class="keyword">sql</span>语句，并将查询结果返还至result中</span><br><span class="line">    const result = await <span class="keyword">connection</span>.<span class="keyword">execute</span>(<span class="keyword">statement</span>, [<span class="type">name</span>, <span class="keyword">password</span>])</span><br><span class="line">    <span class="keyword">return</span> result[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>执行结果<br><img src="/2021/08/16/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E5%B9%B6%E9%AA%8C%E8%AF%81%E5%90%88%E6%B3%95%E6%80%A7/result.png" alt="result"></li>
</ol>
<h3 id="优化过程：验证输入的合法性"><a href="#优化过程：验证输入的合法性" class="headerlink" title="优化过程：验证输入的合法性"></a>优化过程：验证输入的合法性</h3><ol>
<li>创建验证中间件 verifyUser ,并写入 UserRouter 中</li>
</ol>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">userRouter.<span class="built_in">post</span>(<span class="string">&#x27;/&#x27;</span>, verifyUser, <span class="built_in">create</span>)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>由于此类型的中间件在后续开发中会频繁创建，故统一在 middleware.js 中创建</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  导入错误类型</span></span><br><span class="line"><span class="keyword">const</span> errorType = <span class="built_in">require</span>(<span class="string">&#x27;../constants/error-types&#x27;</span>)</span><br><span class="line"><span class="comment">// 导入service 利用其中的getUserByName来验证是否已存在该用户</span></span><br><span class="line"><span class="keyword">const</span> service = <span class="built_in">require</span>(<span class="string">&#x27;../service/user.service&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建中间件，注意其也是异步操作！</span></span><br><span class="line"><span class="keyword">const</span> verifyUser = <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">//获取用户名，密码</span></span><br><span class="line">  <span class="keyword">const</span> &#123; name, password &#125; = ctx.request.body</span><br><span class="line"></span><br><span class="line">  <span class="comment">//判断不能为空</span></span><br><span class="line">  <span class="keyword">if</span> (!name || !password) &#123;</span><br><span class="line">    <span class="comment">//如果为空，则新建Error，其错误类型为：NAME_OR_PASSWORD_IS_REQUIRED</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(errorType.NAME_OR_PASSWORD_IS_REQUIRED)</span><br><span class="line">    <span class="comment">//将错误发射出去</span></span><br><span class="line">    <span class="keyword">return</span> ctx.app.emit(<span class="string">&#x27;error&#x27;</span>, error, ctx)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//判断本次注册的用户名是否被注册</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> service.getUserByNanme(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果返还不为NULL</span></span><br><span class="line">  <span class="keyword">if</span> (result.length) &#123;</span><br><span class="line">    <span class="comment">//新建error 错误类型为：USER_ALREADY_EXISTS</span></span><br><span class="line">    <span class="keyword">const</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(errorType.USER_ALREADY_EXISTS)</span><br><span class="line">    <span class="comment">//将错误发射出去</span></span><br><span class="line">    <span class="keyword">return</span> ctx.app.emit(<span class="string">&#x27;error&#x27;</span>, error, ctx)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果以上都未执行，则进行下一个中间件：create</span></span><br><span class="line">  <span class="keyword">await</span> next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出verifyUser</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  verifyUser,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>errorType 的创建<br>由于以后的错误类型会有很多，所以统一写入在 errorType 中</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> NAME_OR_PASSWORD_IS_REQUIRED = <span class="string">&#x27;name_or_password_is_required&#x27;</span></span><br><span class="line"><span class="keyword">const</span> USER_ALREADY_EXISTS = <span class="string">&#x27;user_already_exists&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span>.<span class="keyword">exports</span> = &#123;</span><br><span class="line">  NAME_OR_PASSWORD_IS_REQUIRED,</span><br><span class="line">  USER_ALREADY_EXISTS,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>service 中的 getUserByName 方法</li>
</ol>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">async getUserByNanme(<span class="type">name</span>) &#123;</span><br><span class="line">  const <span class="keyword">statement</span> = `<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> <span class="type">name</span> = ?;`</span><br><span class="line"></span><br><span class="line">  const result = await <span class="keyword">connection</span>.<span class="keyword">execute</span>(<span class="keyword">statement</span>, [<span class="type">name</span>])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在 index.js 中接收报错信息</li>
</ol>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">app</span>.<span class="keyword">on</span>(&#x27;<span class="keyword">error</span>&#x27;, errorHandler)</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>创建错误处理 error-handle.js<br>在其中统一处理错误信息</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入错误类型</span></span><br><span class="line"><span class="keyword">const</span> errorTypes = <span class="built_in">require</span>(<span class="string">&#x27;../constants/error-types&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入之前发射出来的参数error，ctx，并进行分析处理</span></span><br><span class="line"><span class="keyword">const</span> errorHandler = <span class="function">(<span class="params">error, ctx</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//建立状态变量，和报错提示</span></span><br><span class="line">  <span class="keyword">let</span> status, message</span><br><span class="line"></span><br><span class="line">  <span class="comment">//通过传入的错误类型来判断处理方式</span></span><br><span class="line">  <span class="keyword">switch</span> (error.message) &#123;</span><br><span class="line">    <span class="keyword">case</span> errorTypes.NAME_OR_PASSWORD_IS_REQUIRED:</span><br><span class="line">      status = <span class="number">400</span> <span class="comment">//Bad request</span></span><br><span class="line">      message = <span class="string">&#x27;用户名或者密码为空&#x27;</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> errorTypes.USER_ALREADY_EXISTS:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">      status = <span class="number">409</span> <span class="comment">//Conflict</span></span><br><span class="line">      message = <span class="string">&#x27;用户名已存在&#x27;</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      status = <span class="number">404</span></span><br><span class="line">      message = <span class="string">&#x27;NOT FOUND&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将错误信息导入ctx中</span></span><br><span class="line">  ctx.status = status</span><br><span class="line">  ctx.body = message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = errorHandler</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>错误展示<br>用户已存在：<br><img src="/2021/08/16/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E5%B9%B6%E9%AA%8C%E8%AF%81%E5%90%88%E6%B3%95%E6%80%A7/useretsis.png" alt="用户已存在"><br>状态码：<br><img src="/2021/08/16/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E5%B9%B6%E9%AA%8C%E8%AF%81%E5%90%88%E6%B3%95%E6%80%A7/status1.png" alt="状态码"></li>
</ol>
<p>用户输入名或密码为空:<br><img src="/2021/08/16/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E5%B9%B6%E9%AA%8C%E8%AF%81%E5%90%88%E6%B3%95%E6%80%A7/null.png" alt="null"><br>状态码：<br><img src="/2021/08/16/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E5%B9%B6%E9%AA%8C%E8%AF%81%E5%90%88%E6%B3%95%E6%80%A7/status2.png" alt="状态码"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过今天的汇总，逐渐将其中的思路理清楚，为以后开发接口提供了思路。</p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>关于大三一年的计划</title>
    <url>/2021/07/25/%E5%85%B3%E4%BA%8E%E5%A4%A7%E4%B8%89%E4%B8%80%E5%B9%B4%E7%9A%84%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<p>大三这一年真的是无比关键.想着明年的今天就是我实习的日子.心里多少还是有些焦虑。</p>
<h3 id="回顾自身："><a href="#回顾自身：" class="headerlink" title="回顾自身："></a>回顾自身：</h3><p>大一光顾着玩耍，等到大一暑假的时候突然感觉”玩的索然无味“玩的甚至有点空虚。觉得这不是自己想要的生活。于是放下了我喜欢的游戏。打开了哔哩哔哩，搜起了关于 Java 的教学视频，我还记着我第一次装 Jdk 第一次配置环境变量的时候的一脸懵逼。（这和我学的 C 不一样呀）好奇心促使我继续坚持学习了下去。就这样，我听着尚硅谷的宋红康老师的 Java 课程度过了第一个充实的暑假，也是在那个暑假，我渐渐地明白了，计算机的路，我才刚刚开始。等到了大二，我渐渐尝试着做一些简单的静态页面，跟着做一些简单的 JavaWeb 项目。当我第一次在我自己的数据库接收到前端页面发来的数据的时候，我真的无比激动！这真的是一件很有成就感的事情！<br>到了大二的下学期，在好朋友的指引下，我渐渐接触一些更深层次的东西，我学习了 CoderWhy 老师的 Vue，学完了 Vue 我也深刻体会到组件化开发的便利性。真的佩服我们的尤大佬！能开发出这么好的框架！我什么时候才能到达他这种能力呀！<br>大二这一年，是我学习进步最快的一年，我渐渐明白到了真正的差距到底有多大。所以我想在我大三这一年，有计划有目标地进行学习！争取在一年后的今天能取得互联网大厂的 offer！</p>
<h3 id="大三规划："><a href="#大三规划：" class="headerlink" title="大三规划："></a>大三规划：</h3><h4 id="大方向：扎实内功，基础。深入底层逻辑，原理。追求技术深度。多总结，多学习。"><a href="#大方向：扎实内功，基础。深入底层逻辑，原理。追求技术深度。多总结，多学习。" class="headerlink" title="大方向：扎实内功，基础。深入底层逻辑，原理。追求技术深度。多总结，多学习。"></a>大方向：扎实内功，基础。深入底层逻辑，原理。追求技术深度。多总结，多学习。</h4><h4 id="具体目标，步骤"><a href="#具体目标，步骤" class="headerlink" title="具体目标，步骤:"></a>具体目标，步骤:</h4><ol>
<li>复习巩固计算机原理，数据结构等计算机基础。（巩固基础）</li>
<li>leetcode 坚持每天刷题。（巩固基础）</li>
<li>学习 Node.js 以达到能够做出前后端分离的全栈完整项目。（完善自己的技术面）</li>
<li>学习 uniapp 或 flutter 以达到跨平台，多处运用的目的。（完善自己的技术面）</li>
<li>深入研究 Javascript，Vue 的底层逻辑，以及源码。以达到一定的技术深度。（提高自己技术深度）</li>
<li>多做项目，多参加比赛。提高自己的眼界，技术的多样性，学习别人的优点，改善自己的不足。（提高自己技术深度）</li>
</ol>
]]></content>
      <categories>
        <category>CodeLife</category>
      </categories>
      <tags>
        <tag>规划</tag>
      </tags>
  </entry>
  <entry>
    <title>岛屿问题的实现</title>
    <url>/2021/07/31/%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给你一个由  ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/number-of-islands">https://leetcode-cn.com/problems/number-of-islands</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>此问题与上一期的门墙算法的实现的思想基本一致，属于利用队列，以及广度优先搜索（dfs）的方式解决问题。但是并不是完全的相同。本问题需要注意在于广度优先搜索的时候，需要有“感染”的思想。 首先遍历整个二维数组，寻找数组中的岛 再在孤岛的基础上 遍历他的上下左右临格元素 是否也为“1”岛屿 如果是 将它感染。</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">        public <span class="keyword">int</span> numIslands(char[][] <span class="keyword">grid</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">grid</span>.length==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">grid</span>.length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">grid</span>[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="keyword">grid</span>[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                        count++;</span><br><span class="line">                        dfs(<span class="keyword">grid</span>,i,j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    private void dfs(char[][] <span class="keyword">grid</span>, <span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;= <span class="keyword">grid</span>.length || j&lt;<span class="number">0</span> || j&gt;=<span class="keyword">grid</span>[<span class="number">0</span>].length || <span class="keyword">grid</span>[i][j]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">grid</span>[i][j]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        dfs(<span class="keyword">grid</span>, i - <span class="number">1</span>, j);</span><br><span class="line">        dfs(<span class="keyword">grid</span>, i + <span class="number">1</span>, j);</span><br><span class="line">        dfs(<span class="keyword">grid</span>, i, j + <span class="number">1</span>);</span><br><span class="line">        dfs(<span class="keyword">grid</span>, i, j - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Problems</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>循环队列的实现</title>
    <url>/2021/07/28/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。</p>
<p>循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。</p>
<p>你的实现应该支持如下操作：</p>
<p>MyCircularQueue(k): 构造器，设置队列长度为 k 。<br>Front: 从队首获取元素。如果队列为空，返回 -1 。<br>Rear: 获取队尾元素。如果队列为空，返回 -1 。<br>enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。<br>deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。<br>isEmpty(): 检查循环队列是否为空。<br>isFull(): 检查循环队列是否已满。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/design-circular-queue">https://leetcode-cn.com/problems/design-circular-queue</a></p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3<br>circularQueue.enQueue(1);  // 返回 true<br>circularQueue.enQueue(2);  // 返回 true<br>circularQueue.enQueue(3);  // 返回 true<br>circularQueue.enQueue(4);  // 返回 false，队列已满<br>circularQueue.Rear();  // 返回 3<br>circularQueue.isFull();  // 返回 true<br>circularQueue.deQueue();  // 返回 true<br>circularQueue.enQueue(4);  // 返回 true<br>circularQueue.Rear();  // 返回 4</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><ol>
<li>首先要明白循环队列的原理</li>
<li>如何设计循环队列中的两个指针</li>
<li>细节处理</li>
</ol>
<p>循环队列原理<br><a href="https://www.bilibili.com/video/BV1yx411e7nb?from=search&amp;seid=13632348157331521482/">https://www.bilibili.com/video/BV1yx411e7nb?from=search&amp;seid=13632348157331521482/</a></p>
<h3 id="实现难点："><a href="#实现难点：" class="headerlink" title="实现难点："></a>实现难点：</h3><ol>
<li>为什么要在 eg：head（head+1）% size 取模？</li>
<li>为什么 get tail 的时候不能直接返回？</li>
<li>细节处理</li>
</ol>
<h3 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCircularQueue</span> &#123;</span></span><br><span class="line">    <span class="comment">//构造原始数组</span></span><br><span class="line">    <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="comment">//数组长度</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">//头指针，记录循环列表的头部</span></span><br><span class="line">    <span class="keyword">int</span> head;</span><br><span class="line">    <span class="comment">//尾指针，记录循环列表的尾部</span></span><br><span class="line">    <span class="keyword">int</span> tail;</span><br><span class="line">    <span class="comment">//计数器，记录总共有多少个元素</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器，将原始的数组arr转化为实体，以及一些变量的初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCircularQueue</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        size = k;</span><br><span class="line">        head = <span class="number">0</span>;</span><br><span class="line">        tail = <span class="number">0</span>;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先判断队列是否已满。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isFull</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[tail] = value;</span><br><span class="line">        <span class="comment">//关键点！此处的指针也应该跟着循环，不能说到了数组的size（最大长度）就一直无限延续</span></span><br><span class="line">        <span class="comment">//所以这里需要取模运算&quot;%&quot; 例：k=size=7  tail=7 tail=（7+1%7=1 所以下次tail</span></span><br><span class="line">        <span class="comment">//的位置就在下角标为 1 的位置 从而达到循环指针的目的 后面的head指针同理</span></span><br><span class="line">        tail = (tail + <span class="number">1</span>) % size;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = (head + <span class="number">1</span>) % size;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//取头元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[head];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Rear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此处需要注意tail的真实位置到底指向的是哪里。</span></span><br><span class="line">        <span class="comment">//注意数据的处理不能取负。</span></span><br><span class="line">        <span class="keyword">return</span> arr[(tail - <span class="number">1</span> + size) % size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断满</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size==count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>在对循环队列实现的时候，注意的细节点有很多，需要做到指针循环才能达到整体的循环目的。<br>总的来说还是难度中等。</p>
]]></content>
      <categories>
        <category>Problems</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈js闭包</title>
    <url>/2021/09/05/%E6%B5%85%E8%B0%88js%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<p>最近在学习 Javascript 高级语法，研究到了一些底层逻辑，有了很多的心得体会。赶紧记录下来！</p>
<h1 id="什么是-Js-闭包？"><a href="#什么是-Js-闭包？" class="headerlink" title="什么是 Js 闭包？"></a>什么是 Js 闭包？</h1><p><img src="/2021/09/05/%E6%B5%85%E8%B0%88js%E9%97%AD%E5%8C%85/book.png" alt="描述"></p>
<h2 id="js-中函数是一等公民"><a href="#js-中函数是一等公民" class="headerlink" title="js 中函数是一等公民"></a>js 中函数是一等公民</h2><h3 id="什么是一等公民？"><a href="#什么是一等公民？" class="headerlink" title="什么是一等公民？"></a>什么是一等公民？</h3><p>就好比 java 中的对象。js 中的函数十分灵活！</p>
<ul>
<li>函数可以作为另一个函数的参数，也可以作为另一个函数的返回值来使用</li>
<li>自己可以编写高阶函数</li>
<li>可以使用内置的高阶函数</li>
</ul>
<h3 id="代码演示："><a href="#代码演示：" class="headerlink" title="代码演示："></a>代码演示：</h3><ul>
<li>函数作为一等公民，可以作为参数传入其他的函数中</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calc</span>(<span class="params">num1, num2, fnc</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(fnc(num1, num2))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line">calc(<span class="number">20</span>, <span class="number">30</span>, add)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>js 允许函数的嵌套定义</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fn = foo()</span><br><span class="line">fn()</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">makeAdder</span>(<span class="params">count</span>)</span></span><br><span class="line"><span class="function">   <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num</span>) </span>&#123;</span></span><br><span class="line"><span class="function">     <span class="title">return</span> <span class="title">count</span> + <span class="title">num</span></span></span><br><span class="line"><span class="function">   &#125;</span></span><br><span class="line"><span class="function">   <span class="title">return</span> <span class="title">add</span></span></span><br><span class="line"><span class="function"> &#125;</span></span><br><span class="line"><span class="function"> <span class="title">var</span> <span class="title">add5</span> = <span class="title">makeAdder</span>(<span class="params"><span class="number">5</span></span>)</span></span><br><span class="line"><span class="function"> <span class="title">var</span> <span class="title">add10</span> = <span class="title">makeAdder</span>(<span class="params"><span class="number">10</span></span>)</span></span><br><span class="line"><span class="function"> <span class="title">console</span>.<span class="title">log</span>(<span class="params">add5(<span class="number">10</span>)</span>)</span></span><br><span class="line"><span class="function"> <span class="title">console</span>.<span class="title">log</span>(<span class="params">add10(<span class="number">10</span>)</span>)</span></span><br></pre></td></tr></table></figure></li>
<li><p>高阶函数:把一个函数，接受另一个函数的返回值，作为参数使用，称为高阶函数。</p>
</li>
</ul>
<h2 id="js-中的闭包定义"><a href="#js-中的闭包定义" class="headerlink" title="js 中的闭包定义"></a>js 中的闭包定义</h2><h3 id="官方式定义："><a href="#官方式定义：" class="headerlink" title="官方式定义："></a>官方式定义：</h3><h4 id="在计算机科学中对闭包的定义（维基百科）："><a href="#在计算机科学中对闭包的定义（维基百科）：" class="headerlink" title="在计算机科学中对闭包的定义（维基百科）："></a>在计算机科学中对闭包的定义（维基百科）：</h4><ul>
<li><p>闭包（英语：Closure），又称<strong>词法闭包</strong>（Lexical Closure）或<strong>函数闭包</strong>（function closures）；</p>
</li>
<li><p>是在支持 <strong>头等函数</strong> 的编程语言中，实现词法绑定的一种技术；</p>
</li>
<li><p>闭包在实现上是一个结构体，它存储了一个函数和一个关联的环境（相当于一个符号查找表）；</p>
</li>
<li><p>闭包跟函数最大的区别在于，当捕捉闭包的时候，它的 <strong>自由变量</strong> 会在捕捉时被确定，这样即使脱离了捕捉时的上下文，它也能照常运行；</p>
</li>
</ul>
<h4 id="MDN-对-JavaScript-闭包的解释："><a href="#MDN-对-JavaScript-闭包的解释：" class="headerlink" title="MDN 对 JavaScript 闭包的解释："></a>MDN 对 JavaScript 闭包的解释：</h4><ul>
<li><p>一个函数和对其周围状态（<strong>lexical environment，词法环境</strong>）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是<strong>闭包</strong>（<strong>closure</strong>）；</p>
</li>
<li><p>也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域；</p>
</li>
<li><p>在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来；</p>
</li>
</ul>
<h4 id="我对-Js-闭包的理解："><a href="#我对-Js-闭包的理解：" class="headerlink" title="我对 Js 闭包的理解："></a>我对 Js 闭包的理解：</h4><ul>
<li>广义上来讲，js 中的函数都是闭包</li>
<li>狭义上来讲，js 中的一个函数，如果访问了外层作用域的变量，那它就是一个闭包。</li>
<li>闭包：函数+可以访问的自由变量</li>
</ul>
<h3 id="简单的闭包，以及逻辑："><a href="#简单的闭包，以及逻辑：" class="headerlink" title="简单的闭包，以及逻辑："></a>简单的闭包，以及逻辑：</h3><p><img src="/2021/09/05/%E6%B5%85%E8%B0%88js%E9%97%AD%E5%8C%85/1.png" alt="1"></p>
<p>简单描述逻辑：GO 对象，执行上下文调用栈 EcStack-&gt;全局执行上下文，VO：GO-&gt;解析函数，创建函数对象,上层作用域,函数执行体-&gt;函数执行上下文-&gt;执行代码-&gt;执行上下文销毁，AO 也销毁</p>
<h2 id="闭包中的问题"><a href="#闭包中的问题" class="headerlink" title="闭包中的问题"></a>闭包中的问题</h2><h3 id="闭包中的某些-AO-为什么不会被销毁？"><a href="#闭包中的某些-AO-为什么不会被销毁？" class="headerlink" title="闭包中的某些 AO 为什么不会被销毁？"></a>闭包中的某些 AO 为什么不会被销毁？</h3><p>这就涉及到 Js 的内存回收机制：垃圾回收器会定期从这个根开始，找所有从根开始有引用到的对象，对于哪些没有引用到的对象，就认为是不可用的对象；</p>
<p>我们可以参考：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name)</span><br><span class="line">    <span class="built_in">console</span>.log(age)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = foo()</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/05/%E6%B5%85%E8%B0%88js%E9%97%AD%E5%8C%85/2.png" alt="2"></p>
<p>我们对 function bar 进行研究。</p>
<ol>
<li>创建 GO 对象，包含了 fn：undefined ，foo：undefined</li>
<li>运行 foo（）</li>
<li>创建 foo 函数对象，其中包含了他作用域链，函数执行体；创建 foo AO 对象，name：undefined …，并对 bar（）进行预加载</li>
<li>执行 foo 函数，对 foo AO 进行修改。</li>
<li>创建 bar 函数对象，bar AO</li>
</ol>
<p>其中 bar 的函数对象中 父级作用域是 foo，指向 foo AO 。</p>
<ol start="6">
<li>返回 bar（）</li>
<li>fn 存储 bar 的地址</li>
<li>运行 fn（）</li>
<li>bar 开始寻找相关的 name，age，bar AO 无，则向 foo AO 中寻找。</li>
<li>找到相关数据，执行函数。</li>
</ol>
<p>由于我们可以很清楚地找到一条线：GO 的 fn（）-&gt; bar-&gt;bar AO 父级作用域指向 foo 的 AO</p>
<p>所以此时的 foo AO 不会被销毁，因为我们可以从根目录开始寻找这一条线路。</p>
<h3 id="闭包内存泄漏"><a href="#闭包内存泄漏" class="headerlink" title="闭包内存泄漏"></a>闭包内存泄漏</h3><p>由于某些 AO 一直存在，就有着内存泄漏的问题存在。</p>
<p>解决方法就直接将其指向 null</p>
<p>如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name)</span><br><span class="line">    <span class="built_in">console</span>.log(age)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = foo()</span><br><span class="line">fn()</span><br><span class="line"></span><br><span class="line">fn = <span class="literal">null</span></span><br><span class="line">foo = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>就可以解决这个问题</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JavaScript 博大精深，还需继续努力，深入研究其中的原理。冲冲冲！</p>
]]></content>
      <categories>
        <category>底层逻辑</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>通过node如何创建一个接口</title>
    <url>/2021/08/31/%E9%80%9A%E8%BF%87node%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><p>通过 node.js 环境与 Koa 框架，编写一个接口</p>
<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><ul>
<li>app 文件夹</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- index.js --&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导入Koa框架</span></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;koa-bodyparser&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> errorHandler = <span class="built_in">require</span>(<span class="string">&#x27;./error-handle&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> useRoutes = <span class="built_in">require</span>(<span class="string">&#x27;../router&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//新建Koa实例</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"></span><br><span class="line">app.use(bodyParser())</span><br><span class="line">useRoutes(app)</span><br><span class="line">app.on(<span class="string">&#x27;error&#x27;</span>, errorHandler)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = app</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>main.js 文件</li>
</ul>
<p>main.js 文件一般是程序的主要入口</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入之前创建的app实例</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">&#x27;./app&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//导入数据库相关配置</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./app/database&#x27;</span>)</span><br><span class="line"><span class="comment">//导入相关配置</span></span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&#x27;./app/config&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建启动服务器</span></span><br><span class="line">app.listen(config.APP_PORT, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`服务器在<span class="subst">$&#123;config.APP_PORT&#125;</span>端口已启动`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>router 文件夹<br>index.js 文件 主要用来配置 router（路由）相关信息</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入fs插件</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建useRoutes</span></span><br><span class="line"><span class="keyword">const</span> useRoutes = <span class="function">(<span class="params">app</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//自动生成router相关配置</span></span><br><span class="line">  fs.readdirSync(__dirname).forEach(<span class="function">(<span class="params">file</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (file === <span class="string">&#x27;index.js&#x27;</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">`./<span class="subst">$&#123;file&#125;</span>`</span>)</span><br><span class="line">    app.use(router.routes())</span><br><span class="line">    app.use(router.allowedMethods())</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = useRoutes</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>img.router.js 具体的路由文件</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入koa路由</span></span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//制定接口的路径</span></span><br><span class="line"><span class="keyword">const</span> imgRouter = <span class="keyword">new</span> Router(&#123; <span class="attr">prefix</span>: <span class="string">&#x27;/mmjd&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//导入相关方法/中间件</span></span><br><span class="line"><span class="keyword">const</span> &#123; getImgs,personType,personImgs &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../controller/img.controller&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; verifyAuth &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../middleware/auth.middleware&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册接口，并标明请求方法</span></span><br><span class="line">imgRouter.get(<span class="string">&#x27;/&#x27;</span>, getImgs)</span><br><span class="line">imgRouter.post(<span class="string">&#x27;/personimg&#x27;</span>,verifyAuth,personType,personImgs)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = imgRouter</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>其次就是在 middleware 或者 controller，service 中写具体操作了</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其中还是有很多细节的东西没有掌握好，此点需要以后继续深入研究！</p>
]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>门与墙算法的实现</title>
    <url>/2021/07/29/%E9%97%A8%E4%B8%8E%E5%A2%99%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>你被给定一个  m × n  的二维网格 rooms ，网格中有以下三种可能的初始化值：-1  表示墙或是障碍物 0  表示一扇门<br>INF  无限表示一个空的房间。然后，我们用  231 - 1 = 2147483647  代表  INF。你可以认为通往门的距离总是小于  2147483647  的。<br>你要给每个空房间位上填上该房间到   最近门的距离 ，如果无法到达门，则填  INF  即可。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/walls-and-gates">https://leetcode-cn.com/problems/walls-and-gates</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li>建立基本数据以及辅助坐标</li>
<li>先寻找门坐标，将其入队</li>
<li>取出队头元素 A 进行解析</li>
<li>分析 A 上下左右 block 是否可用 合法 A 是否未赋值</li>
<li>将合法的 block 进行赋值（步数）</li>
<li>将新的 block 入队</li>
</ol>
<h2 id="结束条件"><a href="#结束条件" class="headerlink" title="结束条件"></a>结束条件</h2><p>当取出的区域 上下左右都已经赋值 ｜｜ 为墙，为门 则无需处理，退出处理队列</p>
<h2 id="本题的突破点"><a href="#本题的突破点" class="headerlink" title="本题的突破点:"></a>本题的突破点:</h2><ol>
<li>理解队列先进先出的性质</li>
<li>广度优先搜索的性质</li>
<li>先找门，后赋值的思路</li>
</ol>
<p><em>ps：block 我的定义是 INF 即可用的房间</em></p>
<p><strong>实现难点</strong></p>
<ol>
<li>如何寻找 block 的上下左右房间</li>
<li>该房间的周围空间是否有用</li>
<li>能否联想到新的 block 就当作是一个新门，再从新门找他的上下左右 block</li>
<li>如何进行数据处理</li>
<li>细节处理</li>
</ol>
<h2 id="象形理解"><a href="#象形理解" class="headerlink" title="象形理解"></a>象形理解</h2><p>把每一个门当作一个大的问题小孩（类似孩子王），队列就是记录未解决问题小孩的清单。<br>我们把每一个 INF 区域当作一个医生，安排医生用最小的距离去解决这些问题小孩。<br>我们先在房间里寻找大问题小孩，将他们全部记录在清单上。<br>我们开始分析他周围是否也有问题小孩（孩子王的小跟班）（上下左右检查）<br>如果有（该区域为空）且该问题其他医生没有解决（未赋值）<br>我们就指派该区域的医生去解决这个问题小孩，并且记录该问题小孩离孩子王有多远。（为 block 赋值）<br>如果周围的问题小孩已经有医生解决了，我们就不管。<br>将新的问题小孩记录在队列上，原先的孩子王的下线已经全盘供出，所以他从问题清单上划除。<br>继续解决清单上的新的问题小孩….<br>（可能有点不怎么容易理解。。。。我真的尽力了 源码 yyds ）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="comment">//定义空房间的特征值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INF = <span class="number">2147483647</span>;</span><br><span class="line">    <span class="comment">//定义门的特殊值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DOOR = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//定义辅助坐标 以此来表示房间的上下左右</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;<span class="keyword">int</span>[]&gt; DIRECTIONS = Arrays.<span class="built_in">asList</span>(</span><br><span class="line">            <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wallsAndGates</span><span class="params">(<span class="keyword">int</span>[][] rooms)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//记录房间的长宽</span></span><br><span class="line">        <span class="keyword">int</span> m= rooms.length;</span><br><span class="line">        <span class="keyword">int</span> n=rooms[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建队列</span></span><br><span class="line">        Queue&lt;<span class="keyword">int</span> []&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历rooms 寻找所有的门</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; m; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">                <span class="comment">//当检测到该地区为门的时候 将门的坐标元素入队</span></span><br><span class="line">                <span class="keyword">if</span>(rooms[row][col]==DOOR)&#123;</span><br><span class="line">                    queue.<span class="built_in">add</span>(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;row,col&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//核心区域 （当队列不为空的时候，继续执行）</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">            <span class="comment">//取出队头的元素 也是最先入队的元素 （   d,c,b,a   =&gt; a)</span></span><br><span class="line">            <span class="keyword">int</span>[] block = queue.<span class="built_in">poll</span>();</span><br><span class="line">            <span class="comment">//记录原生的行，列数据</span></span><br><span class="line">            <span class="keyword">int</span> row=block[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> col=block[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//制造当前block的上下左右block 利用辅助坐标快速制作出新的坐标数据</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> [] direction:</span><br><span class="line">                 DIRECTIONS) &#123;</span><br><span class="line">               <span class="keyword">int</span> r=row+direction[<span class="number">0</span>];</span><br><span class="line">               <span class="keyword">int</span> c=col+direction[<span class="number">1</span>];</span><br><span class="line">               <span class="comment">//判断新的坐标是否合法 是否存在障碍物            ！！（重点！）是否之前已经被被赋值过！！</span></span><br><span class="line">                <span class="comment">//如果已经被赋值 说明当前值就是该区域的最短路径，再次改变就是不准确值</span></span><br><span class="line">                <span class="comment">// 因为是广度优先 所以当前值一定是最优值</span></span><br><span class="line">               <span class="keyword">if</span>(r&lt;<span class="number">0</span> || c&lt;<span class="number">0</span> || r&gt;=rooms.length || c&gt;=rooms[<span class="number">0</span>].length || rooms[r][c]!=INF)&#123;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//细节点  需要在前一个block的值上进行+1 否则步数全为1</span></span><br><span class="line">               rooms[r][c]=rooms[row][col]+<span class="number">1</span>;</span><br><span class="line">               <span class="comment">//如果都不是 则为全新的为赋值block 将其加入队列（列尾）</span></span><br><span class="line">                queue.<span class="built_in">add</span>(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r,c&#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Problems</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
</search>
