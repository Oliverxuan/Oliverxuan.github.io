<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Better-scroll 中无法滚动问题</title>
    <url>/2021/08/11/Better-scroll-%E4%B8%AD%E6%97%A0%E6%B3%95%E6%BB%9A%E5%8A%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在昨天我在使用 Vue 开发前端页面的时候，我遇到了在使用 better-scroll 实现页面滚动的时候无法滚动<br>经过排查，问题出在与 better-scroll 的滚动原理与实际高度之间产生矛盾（图片异步加载问题）</p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>在之前的 GoodsList 组件中，有一个加载接口图片的操作</p>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;goods-item&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;goodsItem.img&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>  /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;goods-info&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">goodsItem.name</span> &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;price&quot;</span>&gt;</span>RMB:</span><span class="template-variable">&#123;&#123; <span class="name">goodsItem.price</span> &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br></pre></td></tr></table></figure>

<p>由于 better-scroll 在计算 wrapper content 高度的时候是在一开始就会计算好 从而达到滚动的目的</p>
<p>但是 Goods list 会加载网路图片，存在一个异步问题<br>加载完后，实际的高度会远超于之前 better-scroll 计算的高度</p>
<p>从而导致 better-scroll 之间计算无效了，最终无法滚动</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;goods-item&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;goodsItem.img&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> @<span class="attr">load</span>=<span class="string">&quot;imageload&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;goods-info&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">goodsItem.name</span> &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;price&quot;</span>&gt;</span>RMB:</span><span class="template-variable">&#123;&#123; <span class="name">goodsItem.price</span> &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>在原代码 “&lt; img &gt;”标签处新增 @load=”imageload“ 监听事件</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    <span class="built_in">imageload</span>() &#123;</span><br><span class="line">      this.$bus.$<span class="built_in">emit</span>(<span class="string">&quot;itemImageLoad&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>随后在方法里将此事件发射到事件总线里面</p>
<p>注意，需要在 main.js 里注册 事件总线</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./App.vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&quot;./router&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;./store&quot;</span>;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span>;</span><br><span class="line">Vue.prototype.$bus = <span class="keyword">new</span> Vue();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h =&gt; h(App)</span><br><span class="line">&#125;).$mount(<span class="string">&quot;<span class="subst">#app</span>&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>将事件传入事件总线后 需要在 better-scroll 滚动页面里面监听事件</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">    <span class="built_in">this</span>.$bus.$<span class="literal">on</span>(<span class="string">&quot;itemImageLoad&quot;</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.$refs.scroll.scroll.refresh();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>提前设置 better-scroll 中的 refs 从而方便操作</p>
<p>最后监听到图片加载后 调用 scroll 的 refresh（）函数达到重新计算高度的目的</p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>由于之前的频繁发出事件 image load 导致 实际上会 refresh 很多次</p>
<p>此处就需要 dbounce 防抖函数来处理 ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn,delay</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> handle;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(handle)</span><br><span class="line">         handle=<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             fn()</span><br><span class="line">         &#125;,delay)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>从而达到性能优化的目的</p>
]]></content>
      <categories>
        <category>Obstacle</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Js中call,apply,bind的实现</title>
    <url>/2021/09/12/Js%E4%B8%ADcall-apply-bind%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>在 Js 中，我们常常会用到 call，apply，bind。进行一些 this 操作。我们不禁对其产生了好奇。</p>
<p>Js 中，这些方法是通过 C++实现的，那么我们尝试用 Js 来实现一下。</p>
<h1 id="call"><a href="#call" class="headerlink" title="call"></a>call</h1><ul>
<li><strong>将手写的 mycall 方法，绑定在函数原型上。</strong></li>
</ul>
<p>实现所有函数都可以通过 foo（）.mycall 的方式调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Function.prototype :函数原型</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.mycall = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>拿到调用 mycall（）的对象。</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不难发现，此处是一个隐式绑定，函数foo（）.mycall。我们可以通过this拿到目标函数</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="built_in">this</span></span><br></pre></td></tr></table></figure>

<p><strong>目前，我们完成了最基本的通过 mycall 执行函数体的方法。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mycall = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fn = <span class="built_in">this</span></span><br><span class="line">  fn()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;foo函数被调用&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.mycall() <span class="comment">//foo函数被调用</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>实现函数可传入指定的 this</strong></li>
</ul>
<p>我们知道在 js 的 call（）中，是可以转入指定的对象，用该对象进行函数的调用。</p>
<p>但是也有一些特殊的情况。</p>
<ol>
<li>undefined，null。传入该值后，实际上 this 是 window。</li>
<li>传入数字，字符串。实际上是 number/String 对象</li>
</ol>
<p>我们针对这些特性，进行函数优化。</p>
<p>这里使用到：</p>
<p>Object（）：_将传入的值变成对象类型_；</p>
<p>三元运算符：_判断是否为特殊情况_。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改函数体，传入指定的</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.mycall = <span class="function"><span class="keyword">function</span> (<span class="params">thisArg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fn = <span class="built_in">this</span></span><br><span class="line">  <span class="comment">//对传入的thisArg进行判断，是否为null，undefined，如果是：window，不是 Object(thisArg)。</span></span><br><span class="line">  thisArg = thisArg !== <span class="literal">null</span> &amp;&amp; thisArg !== <span class="literal">undefined</span> ? <span class="built_in">Object</span>(thisArg) : <span class="built_in">window</span></span><br><span class="line">  <span class="comment">//保存原this</span></span><br><span class="line">  thisArg.fn = fn</span><br><span class="line">  <span class="comment">//执行原函数体，并保存结果</span></span><br><span class="line">  <span class="keyword">var</span> result = thisArg.fn()</span><br><span class="line">  <span class="comment">//防止作用域污染，及时删除</span></span><br><span class="line">  <span class="keyword">delete</span> thisArg.fn</span><br><span class="line">  <span class="comment">//返回执行结果</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;foo函数被调用&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.mycall(<span class="string">&#x27;abc&#x27;</span>) <span class="comment">//String&#123;&#x27;abc&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line">foo.mycall() <span class="comment">//window</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>实现函数可传入参数</strong></li>
</ul>
<p>在这里，我们用到了…args （展开运算符），实现可传入未知个数的参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...args 用于传入未知个数的参数</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.mycall = <span class="function"><span class="keyword">function</span> (<span class="params">thisArg, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fn = <span class="built_in">this</span></span><br><span class="line">  thisArg = thisArg !== <span class="literal">null</span> &amp;&amp; thisArg !== <span class="literal">undefined</span> ? <span class="built_in">Object</span>(thisArg) : <span class="built_in">window</span></span><br><span class="line">  thisArg.fn = fn</span><br><span class="line">  <span class="comment">//将参数传入执行函数中</span></span><br><span class="line">  <span class="keyword">var</span> result = thisArg.fn(...args)</span><br><span class="line">  <span class="keyword">delete</span> thisArg.fn</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;foo函数被调用&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;sum函数被执行&#x27;</span>, <span class="built_in">this</span>, num1, num2)</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// foo.call(&#x27;abc&#x27;)</span></span><br><span class="line"><span class="comment">// foo.mycall(&#x27;abc&#x27;)</span></span><br><span class="line"><span class="comment">// foo.call()</span></span><br><span class="line"><span class="comment">// foo.mycall()</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum.mycall(&#123;&#125;, <span class="number">1</span>, <span class="number">2</span>)) <span class="comment">//sum函数被执行 &#123;fn: ƒ&#125;[[Prototype]]: Object 1 2    3</span></span><br></pre></td></tr></table></figure>

<p>目前我们己完成了 mycall（）的手写。</p>
<h1 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h1><ul>
<li><p><strong>基础部分</strong></p>
<p>此部分和 call 基本一致。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myapply = <span class="function"><span class="keyword">function</span> (<span class="params">thisArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fn = <span class="built_in">this</span></span><br><span class="line">  thisArgs =</span><br><span class="line">    thisArgs !== <span class="literal">null</span> &amp;&amp; thisArs !== <span class="literal">undefined</span> ? <span class="built_in">Object</span>(thisArgs) : <span class="built_in">window</span></span><br><span class="line">  thisArgs.fn = fn</span><br><span class="line">  <span class="keyword">var</span> result = thisArgs.fn()</span><br><span class="line">  <span class="keyword">delete</span> thisArgs.fn</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>apply 传参处理</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//apple传参是数组类型，所以我们这里只需要传入目标数组就行</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myapply = <span class="function"><span class="keyword">function</span> (<span class="params">thisArgs, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fn = <span class="built_in">this</span></span><br><span class="line">  thisArgs =</span><br><span class="line">    thisArgs !== <span class="literal">null</span> &amp;&amp; thisArgs !== <span class="literal">undefined</span> ? <span class="built_in">Object</span>(thisArgs) : <span class="built_in">window</span></span><br><span class="line">  thisArgs.fn = fn</span><br><span class="line">  <span class="comment">//array = array ? array: []</span></span><br><span class="line">  array = array || []</span><br><span class="line">  <span class="keyword">var</span> result = thisArgs.fn(...array)</span><br><span class="line">  <span class="keyword">delete</span> thisArgs.fn</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;sum函数被执行&#x27;</span>, <span class="built_in">this</span>, num1, num2)</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum.myapply(&#123;&#125;, [<span class="number">1</span>, <span class="number">2</span>])) <span class="comment">//sum函数被执行 &#123;fn: ƒ&#125; 1 2 3</span></span><br></pre></td></tr></table></figure>

<h1 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h1><ul>
<li><strong>基础部分</strong></li>
</ul>
<p>基础部分和前文一致</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mybind = <span class="function"><span class="keyword">function</span> (<span class="params">thisArg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fn = <span class="built_in">this</span></span><br><span class="line">  thisArg = thisArg !== <span class="literal">null</span> &amp;&amp; thisArg !== <span class="literal">undefined</span> ? <span class="built_in">Object</span>(thisArg) : <span class="built_in">window</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>传参处理</strong></li>
</ul>
<p>由于 bind 的特殊用法，我们可以在 bind（）里传入参数，也可以在新的函数中传入参数，或者都传入参数，所以我们需要特殊处理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mybind = <span class="function"><span class="keyword">function</span> (<span class="params">thisArg, ...myargs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fn = <span class="built_in">this</span></span><br><span class="line">  thisArg = thisArg !== <span class="literal">null</span> &amp;&amp; thisArg !== <span class="literal">undefined</span> ? <span class="built_in">Object</span>(thisArg) : <span class="built_in">window</span></span><br><span class="line">  <span class="comment">//设立一个代理函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">pxfn</span>(<span class="params">...arg</span>) </span>&#123;</span><br><span class="line">    thisArg.fn = fn</span><br><span class="line">    <span class="comment">//合并参数</span></span><br><span class="line">    <span class="keyword">var</span> finalArray = [...myargs, ...arg]</span><br><span class="line">    <span class="comment">//执行函数体</span></span><br><span class="line">    <span class="keyword">var</span> result = thisArg.fn(...finalArray)</span><br><span class="line">    <span class="keyword">delete</span> thisArg.fn</span><br><span class="line">    <span class="comment">//返回执行结果</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//返回pxfn函数</span></span><br><span class="line">  <span class="keyword">return</span> pxfn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2, num3, num4</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(num1, num2, num3, num4)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.mybind(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">bar() <span class="comment">//foo被执行 String &#123;&#x27;123&#x27;, fn: ƒ&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar2 = sum.mybind(<span class="string">&#x27;1234&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">bar2() <span class="comment">//1  2  3  4</span></span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过这次手写 Js 中的一些重要方法，我理解到 this 在实际开发的重要性，也学会了，如何处理数据，以及一些边界情况的处理。总的来说，这是一次很好的学习经验。</p>
]]></content>
      <categories>
        <category>底层逻辑</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello,好久不见</title>
    <url>/2021/08/11/Hello-%E5%A5%BD%E4%B9%85%E4%B8%8D%E8%A7%81/</url>
    <content><![CDATA[<h2 id="最近都去干什么了？"><a href="#最近都去干什么了？" class="headerlink" title="最近都去干什么了？"></a>最近都去干什么了？</h2><p>距离上次更新我的博客已经过去了 10 多天了，在这段时间里我开始新的征程 =&gt; 准备 9 月份的 辽宁省大学生移动开发大赛</p>
<p>我计划着开发一个护肤品测评网站，整个网站的架构为：<br>前端：Vue 全家桶，axios</p>
<p>后端：Node.js，express</p>
<p>数据库：Mysql</p>
<h2 id="期间遇到的问题困难"><a href="#期间遇到的问题困难" class="headerlink" title="期间遇到的问题困难"></a>期间遇到的问题困难</h2><p>由于我之前没有涉及过后端的接口开发，所以我在这 10 天的时间里自学了一点 Node.js 的开发基础。顺便学习了 Express，Koa 框架的基本开发。</p>
<p>到目前为止，我已成功地将写好的使用 Express 的 Js 程序用 Node.js 部署在我的云服务器上。</p>
<p>在这其中我遇到了很多的困难，例如：</p>
<ol>
<li><p>在服务器上部署合适的 Node &amp; Mysql</p>
</li>
<li><p>如何在本地通过 ssh 连接远端服务器</p>
</li>
</ol>
<ul>
<li>ssh root@ip</li>
</ul>
<ol start="3">
<li>如何在 vs code navicat-mysql ssh 连接远端数据</li>
</ol>
<ul>
<li>vs code 通过远程资源管理器</li>
<li>mysql 里设置可远端读写权限</li>
<li>navicat 在建立连接时正确写入服务器中的数据库信息</li>
<li>注意需要在服务器安全组里开放相应的端口</li>
</ul>
<ol start="4">
<li><p>建立数据库，在 Vue 里通过 axios 连接远端数据库</p>
</li>
<li><p>处理接口数据</p>
</li>
<li><p>如何在服务器上一直运行 Node 项目</p>
</li>
</ol>
<ul>
<li>npm2 管理插件</li>
</ul>
<p>在此感谢前辈们在遇到困难时留下的宝贵经验，以至于我在后续开发时遇到问题都能及时解决</p>
]]></content>
      <categories>
        <category>CodeLife</category>
      </categories>
      <tags>
        <tag>规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Js中的This指向</title>
    <url>/2021/09/08/Js%E4%B8%AD%E7%9A%84This%E6%8C%87%E5%90%91/</url>
    <content><![CDATA[<h1 id="Js-中什么是-This？"><a href="#Js-中什么是-This？" class="headerlink" title="Js 中什么是 This？"></a>Js 中什么是 This？</h1><h2 id="为什么需要-this"><a href="#为什么需要-this" class="headerlink" title="为什么需要 this?"></a>为什么需要 this?</h2><p>在 Java 中 this 常用在关于类的操作中，我们常常可以用 this.的方式调用类的属性，方法。</p>
<p>相对于 Java。 Js 中的 this 用法可比 Java 中更灵活。</p>
<p>正也是因为灵活，让 Js 中的 this 常常让人摸不清头脑。</p>
<p>在 Js 中我们可以通过 this 方法，在不同的情况下，拿到不同的对象。有可能是全局对象(window)，也有可能是一个 Obj 对象,或者我们可以直接给我们的 this 指定绑定上一个对象。</p>
<h2 id="this-指向什么呢？"><a href="#this-指向什么呢？" class="headerlink" title="this 指向什么呢？"></a>this 指向什么呢？</h2><ul>
<li><p>在<strong>全局</strong>的情况下，this 指向 window</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">//window</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Oliver&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.name) <span class="comment">//oliver</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name) <span class="comment">//oliver</span></span><br></pre></td></tr></table></figure></li>
<li><p>但是，开发中很少直接在全局作用域下去使用 this，通常都是在<strong>函数中使用</strong>。</p>
<ol>
<li><p>所有的函数在被调用时，都会创建一个执行上下文：</p>
</li>
<li><p>这个上下文中记录着函数的调用栈、AO 对象等；</p>
</li>
<li><p>this 也是其中的一条记录；</p>
</li>
</ol>
</li>
</ul>
<p>我们先来看一个让人困惑的问题：</p>
<p>定义一个函数，我们采用三种不同的方式对它进行调用，它产生了<strong>三种不同</strong>的结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">//window  默认绑定</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo,</span><br><span class="line">&#125;</span><br><span class="line">obj.foo() <span class="comment">//obj对象  隐式绑定</span></span><br><span class="line"></span><br><span class="line">foo.apply(<span class="string">&#x27;abc&#x27;</span>) <span class="comment">//abc  显式绑定</span></span><br></pre></td></tr></table></figure>

<p>这个的案例可以给我们什么样的启示呢？</p>
<ol>
<li><p>函数在调用时，JavaScript 会默认给 this 绑定一个值；</p>
</li>
<li><p>this 的绑定和<strong>定义</strong>的位置（编写的位置）没有关系；</p>
</li>
<li><p>this 的绑定和<strong>调用方式</strong>以及<strong>调用的位置</strong>有关系；</p>
</li>
<li><p>this 是在<strong>运行时被绑定</strong>的；</p>
</li>
</ol>
<h3 id="重要结论："><a href="#重要结论：" class="headerlink" title="重要结论："></a>重要结论：</h3><ol>
<li><strong><em>this 的指向，和它所处的位置无关和调用位置有关！</em></strong></li>
<li><strong>this 在被调用运行的时候，才会给他 this 绑定一个值</strong>！</li>
</ol>
<h3 id="this-绑定规则："><a href="#this-绑定规则：" class="headerlink" title="this 绑定规则："></a>this 绑定规则：</h3><h4 id="绑定一：默认绑定"><a href="#绑定一：默认绑定" class="headerlink" title="绑定一：默认绑定"></a>绑定一：默认绑定</h4><h4 id="绑定二：隐式绑定"><a href="#绑定二：隐式绑定" class="headerlink" title="绑定二：隐式绑定"></a>绑定二：隐式绑定</h4><h4 id="绑定三：显示绑定"><a href="#绑定三：显示绑定" class="headerlink" title="绑定三：显示绑定"></a>绑定三：显示绑定</h4><h4 id="绑定四：new-绑定"><a href="#绑定四：new-绑定" class="headerlink" title="绑定四：new 绑定"></a>绑定四：new 绑定</h4><h2 id="规则一：默认绑定"><a href="#规则一：默认绑定" class="headerlink" title="规则一：默认绑定"></a><strong>规则一：默认绑定</strong></h2><h3 id="什么情况下使用默认绑定呢？"><a href="#什么情况下使用默认绑定呢？" class="headerlink" title="什么情况下使用默认绑定呢？"></a>什么情况下使用默认绑定呢？</h3><p><strong>独立的</strong>函数调用</p>
<p>我们可以理解成<strong>函数没有被绑定到某个对象上进行调用</strong></p>
<p><em>下面是一些默认绑定演示：</em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. window</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.  window</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  foo1()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  foo2()</span><br><span class="line">&#125;</span><br><span class="line">foo3()</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. window</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = obj.foo <span class="comment">//将该对象中的方法传递给了bar  那么其实bar就是一个单独调用</span></span><br><span class="line">bar()</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. window</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = foo() <span class="comment">//实质上就是在调用bar 然后将bar传递给了fn</span></span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>

<p><strong>默认绑定，独立函数调用</strong></p>
<h2 id="规则二：隐式绑定"><a href="#规则二：隐式绑定" class="headerlink" title="规则二：隐式绑定"></a>规则二：隐式绑定</h2><p>另外一种比较常见的调用方式是<strong>通过某个对象进行调用</strong>的：</p>
<p>也就是它的调用位置中，是<strong>通过某个对象发起的函数调用。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">19</span>,</span><br><span class="line">  <span class="attr">fn</span>: foo,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用对象调用的方式来执行函数。</span></span><br><span class="line">obj.fn() <span class="comment">//在对象里，将foo函数传递给了fn 实质上就是通过obj在调用</span></span><br></pre></td></tr></table></figure>

<p>隐式绑定有前提条件：</p>
<ol>
<li><p>必须在调用的对象<strong>内部</strong>有一个对函数的<strong>引用</strong>（比如一个属性）；</p>
</li>
<li><p>如果<strong>没有</strong>这样的<strong>引用</strong>，在进行调用时，会报<strong>找不到该函数的错误</strong>；</p>
</li>
<li><p>正是<strong>通过</strong>这个<strong>引用</strong>，间接的将<strong>this 绑定</strong>到了这个<strong>对象</strong>上；</p>
</li>
</ol>
<h2 id="规则三：显示绑定"><a href="#规则三：显示绑定" class="headerlink" title="规则三：显示绑定"></a>规则三：显示绑定</h2><p>如果我们不希望在 <strong>对象内部</strong> 包含这个函数的引用，同时又希望在这个对象上进行强制调用，该怎么做呢？</p>
<p>JavaScript 所有的函数<strong>都可以使用</strong>call 和 apply 方法（这个和 Prototype 有关）。</p>
<ul>
<li><p>其实非常简单，第一个参数是相同的，后面的参数，apply 为数组，call 为参数列表；</p>
</li>
<li><p>这两个函数的<strong>第一个参数</strong>都要求是一个<strong>对象</strong>，这个对象的作用是什么呢？就是<strong>给 this 准备</strong>的。</p>
</li>
<li><p>在调用这个函数时，会<strong>将 this 绑定到这个传入的对象上</strong>。</p>
</li>
<li><p>因为上面的过程，我们<strong>明确的绑定了 this 指向的对象</strong>，所以称之为 <strong>显示绑定</strong>。</p>
</li>
</ul>
<h3 id="通过-call-或者-apply-绑定-this-对象"><a href="#通过-call-或者-apply-绑定-this-对象" class="headerlink" title="通过 call 或者 apply 绑定 this 对象"></a>通过 call 或者 apply 绑定 this 对象</h3><ul>
<li>call（ ）绑定，其第一参数为指定的 this 绑定对象，第二，三，N，参数为将要传入的参数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num1, num2, num3</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(num1, num2, num3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.call(<span class="string">&#x27;call&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">//[String: &#x27;call&#x27;] 1 2 3</span></span><br><span class="line">foo.call(&#123; <span class="attr">name</span>: <span class="string">&#x27;yzx&#x27;</span> &#125;) <span class="comment">//&#123; name: &#x27;yzx&#x27; &#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>apply（ ）绑定，其第一参数为指定 this 绑定对象，第二参数为一个数组，其中包含了将要传入的参数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num1, num2, num3</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(num1, num2, num3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.apply(<span class="string">&#x27;apply&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">//[String: &#x27;apply&#x27;]  1 2 3</span></span><br><span class="line">foo.apply(&#123; <span class="attr">name</span>: <span class="string">&#x27;yzx&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;) <span class="comment">//&#123; name: &#x27;yzx&#x27;, age: 18 &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="通过-bind-方法实现显示绑定"><a href="#通过-bind-方法实现显示绑定" class="headerlink" title="通过 bind 方法实现显示绑定"></a>通过 bind 方法实现显示绑定</h3><ul>
<li>我们可以通过.bind 方法实现显示绑定</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span>, <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">  <span class="attr">fn</span>: foo,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">//window</span></span><br><span class="line">obj.fn() <span class="comment">//obj</span></span><br><span class="line"><span class="keyword">var</span> fn = obj.fn.bind(&#123; <span class="attr">name</span>: <span class="string">&#x27;Bind&#x27;</span> &#125;)</span><br><span class="line">fn() <span class="comment">//Bind</span></span><br></pre></td></tr></table></figure>

<h2 id="规则四：new-绑定"><a href="#规则四：new-绑定" class="headerlink" title="规则四：new 绑定"></a>规则四：new 绑定</h2><p>JavaScript 中的函数可以当做一个类的构造函数来使用，也就是使用 new 关键字。</p>
<p>使用 new 关键字来调用函数是，会执行如下的操作：</p>
<ol>
<li><p>创建一个全新的对象；</p>
</li>
<li><p>这个新对象会被执行 prototype 连接；</p>
</li>
<li><p>这个新对象会绑定到函数调用的 this 上（this 的绑定在这个步骤完成）；</p>
</li>
<li><p>如果函数没有返回其他对象，表达式会返回这个新对象；</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">//Person&#123;&#125;</span></span><br><span class="line">  <span class="built_in">this</span>.name = name <span class="comment">//Person&#123;name:Oliverxuan&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;Oliverxuan&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p)</span><br></pre></td></tr></table></figure>

<h1 id="内置函数-this-绑定"><a href="#内置函数-this-绑定" class="headerlink" title="内置函数 this 绑定"></a>内置函数 this 绑定</h1><h2 id="setTimeout（）"><a href="#setTimeout（）" class="headerlink" title="setTimeout（）"></a>setTimeout（）</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. setTimeout</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">//window</span></span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure>

<h2 id="监听点击"><a href="#监听点击" class="headerlink" title="监听点击"></a>监听点击</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> boxDiv = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;box&#x27;</span>)</span><br><span class="line">boxDiv.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">//boxDiv&#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组：filter-map-forEach-等高阶函数"><a href="#数组：filter-map-forEach-等高阶函数" class="headerlink" title="数组：filter/map/forEach 等高阶函数"></a>数组：filter/map/forEach 等高阶函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;cba&#x27;</span>]</span><br><span class="line"></span><br><span class="line">names.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item, <span class="built_in">this</span>) <span class="comment">//abc&#123;&#125;</span></span><br><span class="line">&#125;, <span class="string">&#x27;abc&#x27;</span>) <span class="comment">//此处进行了this绑定</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> names = [<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;cba&#x27;</span>]</span><br><span class="line">names.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item, <span class="built_in">this</span>) <span class="comment">// window</span></span><br><span class="line">&#125;) <span class="comment">//此处没有进行this的绑定</span></span><br></pre></td></tr></table></figure>

<h1 id="规则优先级"><a href="#规则优先级" class="headerlink" title="规则优先级"></a>规则优先级</h1><h2 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h2><p>学习了四条规则，接下来开发中我们只需要去查找函数的调用应用了哪条规则即可，但是如果一个函数调用位置应用了多条规则，优先级谁更高呢？</p>
<p><strong>1. 默认规则的优先级最低</strong></p>
<ul>
<li>毫无疑问，默认规则的优先级是最低的，因为存在其他规则时，就会通过其他规则的方式来绑定 this</li>
</ul>
<p><strong>2. 显示绑定优先级高于默认绑定</strong></p>
<ul>
<li>代码测试：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.foo() <span class="comment">// name:&#123; name: &#x27;obj&#x27;, foo: [Function: foo] &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>3 .显示绑定优先级高于隐式绑定</strong></p>
<ul>
<li>代码测试：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.foo.call(<span class="string">&#x27;abc&#x27;</span>) <span class="comment">//[String: &#x27;abc&#x27;]</span></span><br><span class="line">obj.foo.apply(<span class="string">&#x27;abc&#x27;</span>) <span class="comment">//[String: &#x27;abc&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. bind 的优先级，高于隐式绑定</strong></p>
<ul>
<li>代码测试：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo.bind(<span class="string">&#x27;aaa&#x27;</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.foo() <span class="comment">//[String: &#x27;aaa&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><strong>6. new 绑定优先级高于显示绑定</strong></p>
<ul>
<li>new 绑定和<strong>call、apply 是不允许同时使用的</strong>，所以不存在谁的优先级更高</li>
<li>new 绑定可以和 bind 一起使用，new 绑定优先级更高</li>
<li>代码测试：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> obj.foo() <span class="comment">//foo&#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>7. 小小总结</strong></p>
<ul>
<li>bind 优先级比较高</li>
<li>new &gt; 显示 &gt; 隐式 &gt; 默认绑定（独立函数调用）</li>
</ul>
<h2 id="规则之外"><a href="#规则之外" class="headerlink" title="规则之外"></a>规则之外</h2><h3 id="常规情况"><a href="#常规情况" class="headerlink" title="常规情况"></a>常规情况</h3><ol>
<li><p>忽略显示绑定</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.apply(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line">foo.apply(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">foo.apply(<span class="literal">null</span>) <span class="comment">//window 全局对象</span></span><br><span class="line">foo.apply(<span class="literal">undefined</span>) <span class="comment">//window 全局对象</span></span><br><span class="line">foo.bind(<span class="literal">null</span>) <span class="comment">//window 全局对象</span></span><br><span class="line">foo.bind(<span class="literal">undefined</span>) <span class="comment">//window 全局对象</span></span><br><span class="line"><span class="keyword">var</span> bar = foo.bind(<span class="literal">null</span>)</span><br><span class="line">bar()</span><br></pre></td></tr></table></figure></li>
<li><p>间接函数引用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj2&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line">obj2.bar = obj.foo</span><br><span class="line">obj2.bar() <span class="comment">//&#123; name: &#x27;obj2&#x27;, bar: [Function: foo] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj2&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line">obj2.bar = obj.foo</span><br><span class="line">obj2.bar()(</span><br><span class="line">  <span class="comment">//&#123; name: &#x27;obj2&#x27;, bar: [Function: foo] &#125;</span></span><br><span class="line">  (obj2.bar = obj.foo)</span><br><span class="line">)() <span class="comment">// 没有 分号（；）无法运行 与上面的代码看成整体</span></span><br><span class="line">;(obj2.bar = obj.foo)() <span class="comment">// 有 分号（；）window 独立调用</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><h4 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h4><ul>
<li><strong>箭头函数</strong>中 是<strong>不会绑定 this/arguments 属性</strong></li>
<li>箭头函数<strong>不能作为函数构造器</strong>使用</li>
<li><strong>四大规则 对箭头函数不适用</strong></li>
</ul>
<h4 id="简写："><a href="#简写：" class="headerlink" title="简写："></a>简写：</h4><ol>
<li><p>如果参数只有一个 小括号可以省略</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">nums.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>如果函数的函数执行体只有一行代码，大括号也可以省略</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">nums.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="built_in">console</span>.log(item))</span><br><span class="line"><span class="comment">// 并且会默认地将代码的执行结果作为返回值</span></span><br><span class="line"><span class="keyword">var</span> num = nums.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> item % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(num)</span><br></pre></td></tr></table></figure></li>
<li><p>如果一个箭头函数它的返回值，只有一行代码，且只返回一个对象 如果想简写 返回对象 需要在外层套一个（）以示整体</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="function">() =&gt;</span> (&#123; <span class="attr">name</span>: <span class="string">&#x27;oliver&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>JS 中的 this 十分灵活，需要结合各种情况进行分析。但是万变不离其宗。掌握特性，方可以一眼看穿真相！</p>
<p>JS 的优点是灵活，缺点也是灵活。想要真正掌握 JS 中的晦涩语法。还需要继续修炼内功</p>
<p>感谢 coderwhy 老师的课程以及公众号，能够让我细节地，全面地学习 JS</p>
]]></content>
      <categories>
        <category>底层逻辑</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Js中的this练习题</title>
    <url>/2021/09/09/Js%E4%B8%AD%E7%9A%84this%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<h1 id="习题："><a href="#习题：" class="headerlink" title="习题："></a>习题：</h1><h2 id="练习题-1"><a href="#练习题-1" class="headerlink" title="练习题 1:"></a>练习题 1:</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;person&#x27;</span>,</span><br><span class="line">  <span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sss = person.sayName</span><br><span class="line">  sss()</span><br><span class="line">  person.sayName()</span><br><span class="line">  person.sayName()</span><br><span class="line">  ;(b = person.sayName)()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="练习题-2"><a href="#练习题-2" class="headerlink" title="练习题 2:"></a>练习题 2:</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;person1&#x27;</span>,</span><br><span class="line">  <span class="attr">foo1</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">foo2</span>: <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name),</span><br><span class="line">  <span class="attr">foo3</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">foo4</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;person2&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line">person1.foo1()</span><br><span class="line">person1.foo1.call(person2)</span><br><span class="line"></span><br><span class="line">person1.foo2()</span><br><span class="line">person1.foo2.call(person2)</span><br><span class="line"></span><br><span class="line">person1.foo3()()</span><br><span class="line">person1.foo3.call(person2)()</span><br><span class="line">person1.foo3().call(person2)</span><br><span class="line"></span><br><span class="line">person1.foo4()()</span><br><span class="line">person1.foo4.call(person2)()</span><br><span class="line">person1.foo4().call(person2)</span><br></pre></td></tr></table></figure>

<h2 id="练习题-3"><a href="#练习题-3" class="headerlink" title="练习题 3:"></a>练习题 3:</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  ;(<span class="built_in">this</span>.foo1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;),</span><br><span class="line">    (<span class="built_in">this</span>.foo2 = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)),</span><br><span class="line">    (<span class="built_in">this</span>.foo3 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    (<span class="built_in">this</span>.foo4 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&#x27;person1&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">&#x27;person2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">person1.foo1()</span><br><span class="line">person1.foo1.call(person2)</span><br><span class="line"></span><br><span class="line">person1.foo2()</span><br><span class="line">person1.foo2.call(person2)</span><br><span class="line"></span><br><span class="line">person1.foo3()()</span><br><span class="line">person1.foo3.call(person2)()</span><br><span class="line">person1.foo3().call(person2)</span><br><span class="line"></span><br><span class="line">person1.foo4()()</span><br><span class="line">person1.foo4.call(person2)()</span><br><span class="line">person1.foo4().call(person2)</span><br></pre></td></tr></table></figure>

<h2 id="练习题-4"><a href="#练习题-4" class="headerlink" title="练习题 4:"></a>练习题 4:</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">    <span class="attr">foo1</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">foo2</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&#x27;person1&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">&#x27;person2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">person1.obj.foo1()()</span><br><span class="line">person1.obj.foo1.call(person2)()</span><br><span class="line">person1.obj.foo1().call(person2)</span><br><span class="line"></span><br><span class="line">person1.obj.foo2()()</span><br><span class="line">person1.obj.foo2.call(person2)()</span><br><span class="line">person1.obj.foo2().call(person2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//上层作用域的理解</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 上层作用域是全局</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="习题题解："><a href="#习题题解：" class="headerlink" title="习题题解："></a>习题题解：</h1><h2 id="练习题-1-1"><a href="#练习题-1-1" class="headerlink" title="练习题 1:"></a>练习题 1:</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;person&#x27;</span>,</span><br><span class="line">  <span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sss = person.sayName</span><br><span class="line">  sss() <span class="comment">//window 默认绑定，独立函数调用</span></span><br><span class="line"></span><br><span class="line">  person.sayName() <span class="comment">//person 隐式绑定，通过person调用sayName（）</span></span><br><span class="line"></span><br><span class="line">  person.sayName() <span class="comment">//person 隐式绑定，通过person调用sayName（），</span></span><br><span class="line">  <span class="comment">//实质上（）没有用，本身就是一个整体，只是用来混淆视听。</span></span><br><span class="line">  ;(b = person.sayName)() <span class="comment">//window 默认绑定，独立函数调用，b接收了sayName（）后被独立调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="练习题-2-1"><a href="#练习题-2-1" class="headerlink" title="练习题 2:"></a>练习题 2:</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;person1&#x27;</span>,</span><br><span class="line">  <span class="attr">foo1</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">foo2</span>: <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name),</span><br><span class="line">  <span class="attr">foo3</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">foo4</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;person2&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line">person1.foo1() <span class="comment">//person1 隐式绑定，通过person1来调用函数</span></span><br><span class="line"></span><br><span class="line">person1.foo1.call(person2) <span class="comment">//person2 显式绑定，首先拿到了foo1的函数体，再通过call方法调用，																												//其中指定绑定了this为person2</span></span><br><span class="line"></span><br><span class="line">person1.foo2() <span class="comment">//window  默认绑定，由于foo2是箭头函数，箭头函数不接受this对象，向上层寻找，上层是对象。</span></span><br><span class="line"><span class="comment">//由于对象没有this指定，则它的this就指向了全局</span></span><br><span class="line"></span><br><span class="line">person1.foo2.call(person2) <span class="comment">//window  默认绑定，拿到foo2后通过call（）调用，但是箭头函数不接受this对象，故为window</span></span><br><span class="line"></span><br><span class="line">person1.foo3()() <span class="comment">//window  独立函数调用，通过person1拿到foo3函数体后，函数再执行。相当于是函数的独立调用</span></span><br><span class="line"></span><br><span class="line">person1.foo3.call(person2)() <span class="comment">//person2 首先拿到了foo3函数，通过call我们拿到了return 的函数 再执行，相当于独立调用。</span></span><br><span class="line"></span><br><span class="line">person1.foo3().call(person2) <span class="comment">//person2 显式绑定，通过foo3（）拿到了return函数，再通过call绑定了this运行。</span></span><br><span class="line"></span><br><span class="line">person1.foo4()() <span class="comment">//person1 隐式绑定，首先foo4（）拿到了箭头函数，（）再执行，箭头函数中没有this指定</span></span><br><span class="line"><span class="comment">//向上查找，由于上层为foo4（）foo4是由person1 调用执行的，故为隐式绑定</span></span><br><span class="line"></span><br><span class="line">person1.foo4.call(person2)() <span class="comment">//person2 首先拿到了foo4 对其进行call绑定，foo4的作用域中this指向了person2</span></span><br><span class="line"><span class="comment">//然后箭头函数向上查找，foo4的this以及变成了person2</span></span><br><span class="line"></span><br><span class="line">person1.foo4().call(person2) <span class="comment">//person1 首先拿到了箭头函数，由于箭头函数不传值，直接调用，向上查找foo4的作用域</span></span><br><span class="line"><span class="comment">//中this的指向，为person1</span></span><br></pre></td></tr></table></figure>

<h2 id="练习题-3-1"><a href="#练习题-3-1" class="headerlink" title="练习题 3:"></a>练习题 3:</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  ;(<span class="built_in">this</span>.foo1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;),</span><br><span class="line">    (<span class="built_in">this</span>.foo2 = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)),</span><br><span class="line">    (<span class="built_in">this</span>.foo3 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    (<span class="built_in">this</span>.foo4 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&#x27;person1&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">&#x27;person2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">person1.foo1() <span class="comment">//perosn1</span></span><br><span class="line">person1.foo1.call(person2) <span class="comment">//perosn2 显式绑定</span></span><br><span class="line"></span><br><span class="line">person1.foo2() <span class="comment">//person1 上级作用域中this指向的是person1</span></span><br><span class="line">person1.foo2.call(person2) <span class="comment">//person1 call并不会改变箭头函数的this指向，上级作用域中this指向的是person1</span></span><br><span class="line"></span><br><span class="line">person1.foo3()() <span class="comment">//window  独立函数调用</span></span><br><span class="line">person1.foo3.call(person2)() <span class="comment">//window  独立函数调用</span></span><br><span class="line">person1.foo3().call(person2) <span class="comment">//person2 显示绑定</span></span><br><span class="line"></span><br><span class="line">person1.foo4()() <span class="comment">//perosn1 隐式绑定，拿到了箭头函数，再（），箭头函数向上查找，上级作用域this为perosn1</span></span><br><span class="line">person1.foo4.call(person2)() <span class="comment">//perosn2 首先改变了foo4的this为perosn2，当箭头函数找的时候上级作用域已改变</span></span><br><span class="line">person1.foo4().call(person2) <span class="comment">//perosn1 call无法改变箭头函数的this绑定值，箭头函数向上查找，为perosn1</span></span><br></pre></td></tr></table></figure>

<h2 id="练习题-4-1"><a href="#练习题-4-1" class="headerlink" title="练习题 4:"></a>练习题 4:</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">    <span class="attr">foo1</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">foo2</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&#x27;person1&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">&#x27;person2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">person1.obj.foo1()() <span class="comment">//window  独立函数调用</span></span><br><span class="line">person1.obj.foo1.call(person2)() <span class="comment">//window  独立函数调用</span></span><br><span class="line">person1.obj.foo1().call(person2) <span class="comment">//perosn2 显示绑定了person2</span></span><br><span class="line"></span><br><span class="line">person1.obj.foo2()() <span class="comment">//obj，首先，我们foo2（），拿到了箭头函数，箭头函数向上查找，foo2是通过obj进行调用的</span></span><br><span class="line"><span class="comment">//所以foo2的作用域中this为obj</span></span><br><span class="line"></span><br><span class="line">person1.obj.foo2.call(person2)() <span class="comment">//perosn2 foo2的this通过call改变了，所以，箭头函数向上查找this时时person2</span></span><br><span class="line">person1.obj.foo2().call(person2) <span class="comment">//obj call无法改变箭头函数的this</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上层作用域的理解</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 上层作用域是全局</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>首先感谢 coderwhy 老师提供的练习题与讲解，本文中的题解为个人理解，仅供参考。</p>
<ol>
<li>关于箭头函数，不要忘记向上查找的规则</li>
<li>关于最后的（）要分析好是否为函数的独立调用</li>
<li>箭头函数向上查找的时候需要判断上层作用域到底是哪一个</li>
</ol>
]]></content>
      <categories>
        <category>练习题</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Js中的构造函数及原型</title>
    <url>/2021/09/22/Js%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%8A%E5%8E%9F%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>Js 中的构造函数与 Java 的构造函数思想区别不大，只是需要注意下细节。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 规范: 构造函数的首字母一般是大写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, height, address</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">  <span class="built_in">this</span>.height = height</span><br><span class="line">  <span class="built_in">this</span>.address = address</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.eating = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;在吃东西~&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.running = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;在跑步&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;张三&#x27;</span>, <span class="number">18</span>, <span class="number">1.88</span>, <span class="string">&#x27;广州市&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">&#x27;李四&#x27;</span>, <span class="number">20</span>, <span class="number">1.98</span>, <span class="string">&#x27;北京市&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1)</span><br><span class="line"><span class="built_in">console</span>.log(p2)</span><br><span class="line">p1.eating()</span><br><span class="line">p2.eating()</span><br></pre></td></tr></table></figure>

<p>构造函数的缺点：容易产生很多的代码冗余，例如这里的 eating，running。</p>
<h2 id="构造函数中的-new"><a href="#构造函数中的-new" class="headerlink" title="构造函数中的 new"></a>构造函数中的 new</h2><p><strong>如果一个函数被使用 new 操作符调用了，那么它会执行如下操作：</strong></p>
<ol>
<li><p>在<strong>内存</strong>中创建一个新的对象（空对象）；</p>
</li>
<li><p>这个对象内部的[[prototype]]属性会被赋值为该构造函数的 prototype 属性；</p>
</li>
<li><p>构造函数内部的 this，会指向创建出来的新对象；</p>
</li>
<li><p>执行函数的内部代码（函数体代码）；</p>
</li>
<li><p>如果构造函数没有返回非空对象，则返回创建出来的新对象；</p>
</li>
</ol>
<h1 id="对象原型"><a href="#对象原型" class="headerlink" title="对象原型"></a>对象原型</h1><p>JavaScript 当中每个对象都有一个特殊的内置属性 [[prototype]]，这个特殊的对象可以指向另外一个对象。</p>
<p>我们可以通过 _ proto _ / Object.getPrototypeOf 来查看对象的对象原型</p>
<p><strong>所有的函数都有一个 prototype 属性</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数也是一个对象</span></span><br><span class="line"><span class="comment">// console.log(foo.__proto__) // 函数作为对象来说, 它也是有[[prototype]] 隐式原型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数它因为是一个函数, 所以它还会多出来一个显示原型属性: prototype</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.prototype)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> foo()</span><br><span class="line"><span class="keyword">var</span> f2 = <span class="keyword">new</span> foo()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f1.__proto__ === foo.prototype)</span><br><span class="line"><span class="built_in">console</span>.log(f2.__proto__ === foo.prototype)</span><br></pre></td></tr></table></figure>

<h2 id="new-创建新的对象时"><a href="#new-创建新的对象时" class="headerlink" title="new 创建新的对象时"></a>new 创建新的对象时</h2><ol>
<li><p>在内存中创建一个新的对象（空对象）；</p>
</li>
<li><p>这个对象内部的[[prototype]]属性会被赋值为该构造函数的 prototype 属性；</p>
</li>
</ol>
<h2 id="对象原型的应用"><a href="#对象原型的应用" class="headerlink" title="对象原型的应用"></a>对象原型的应用</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, height, address</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">  <span class="built_in">this</span>.height = height</span><br><span class="line">  <span class="built_in">this</span>.address = address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在上构造函数的方式创建对象时，有一个弊端：会创建出重复的函数，比如running、eating这些函数</span></span><br><span class="line"><span class="comment">//所以我们这里使用prototype来给对象原型添加方法，属性</span></span><br><span class="line">Person.prototype.eating = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;在吃东西~&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.running = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;在跑步~&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;OLiver&#x27;</span>, <span class="number">18</span>, <span class="number">1.88</span>, <span class="string">&#x27;北京市&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">&#x27;kobe&#x27;</span>, <span class="number">20</span>, <span class="number">1.98</span>, <span class="string">&#x27;洛杉矶市&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p1.eating()</span><br><span class="line">p2.eating()</span><br><span class="line"></span><br><span class="line">Person.prototype.page = <span class="string">&#x27;xuan&#x27;</span></span><br><span class="line"></span><br><span class="line">p1.eating() <span class="comment">// Oliver在吃东西~</span></span><br><span class="line">p2.eating() <span class="comment">// kobe在吃东西~</span></span><br><span class="line"><span class="comment">//当当前的p1对象中没有定义page时则会向上查找，此处为Person中的page</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.page) <span class="comment">// xuan</span></span><br><span class="line">p2.page = <span class="string">&#x27;Oliver-xuan&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(p2.page) <span class="comment">// Oliver-xuan</span></span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Js 中的对象原型给我的感觉就像是 JAVA 中的父类，我们在父类中定义一些方法，子类可以继承该方法，属性。</p>
<p>例如此处我们定义了 eating running 两个方法，我们在子类中并没有对其进行一些定义赋值，但是我们可以用 new 出来的对象直接使用。</p>
<p>正是因为 this 的存在，在构造器中的 this 也会以一种隐式绑定的方式，this 绑定到调用的对象上。如 p1.running 这里 running 的 this 就是 p1.</p>
]]></content>
      <categories>
        <category>底层逻辑</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Js纯函数及函数柯里化</title>
    <url>/2021/09/14/Js%E7%BA%AF%E5%87%BD%E6%95%B0%E5%8F%8A%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
    <content><![CDATA[<p>在函数式编程中，有一个非常重要的概念：纯函数。</p>
<p>那究竟什么是纯函数呢？</p>
<h1 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h1><h2 id="纯函数的定义"><a href="#纯函数的定义" class="headerlink" title="纯函数的定义"></a>纯函数的定义</h2><ul>
<li>维基百科：<ol>
<li>此函数在<strong>相同的输入值</strong>时需<strong>产生相同的输出</strong>。</li>
<li>函数的<strong>输出和输入值以外的其他隐藏信息或状态无关</strong>，也和<strong>I/O 设备产生的外部输出</strong>无关。</li>
<li>该函数<strong>不能有语义上可观察的函数副作用</strong>，诸如<strong>“触发事件”</strong>，<strong>使输出设备输出，或更改输出值以外物件的内容</strong>等。</li>
</ol>
</li>
</ul>
<p>维基百科的解释很严谨，但是未免有些晦涩。</p>
<ul>
<li>我的理解：<ol>
<li>一个函数，有确定的输入，一定会产生确定的输出。</li>
<li>我们在执行函数的时候，不会对外界产生任何的副作用。</li>
</ol>
</li>
</ul>
<h2 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h2><p><strong><em>副作用：比如改变了函数外的变量，造成全局变量被篡改。</em></strong></p>
<p>eg：slice 与 splice 的比较</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// slice函数是一个纯函数：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. slice只要给它传入一个start/end, 那么对于同一个数组来说, 它会给我们返回确定的值</span></span><br><span class="line"><span class="comment">// 2. slice函数本身它是不会修改原来的数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// slice -&gt; this</span></span><br><span class="line"><span class="comment">// slice函数本身就是一个纯函数</span></span><br><span class="line"><span class="comment">// var new numbers1 =  numbers.slice(0, 3)</span></span><br><span class="line"><span class="comment">// console.log(numbers1)</span></span><br><span class="line"><span class="comment">// console.log( numbers)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// splice函数不是一个纯函数：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// splice在执行时, 有修改掉调用的数组对象本身, 修改的这个操作就是产生的副作用</span></span><br><span class="line"><span class="keyword">var</span> numbers2 = numbers.splice(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(numbers2)</span><br><span class="line"><span class="built_in">console</span>.log(numbers)</span><br></pre></td></tr></table></figure>

<p>纯函数的理解很简单，只需要关注好重点就可以了。</p>
<h1 id="函数的柯里化"><a href="#函数的柯里化" class="headerlink" title="函数的柯里化"></a>函数的柯里化</h1><h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><p>用我自己的话简单来说：就是把一件事情进行拆分。</p>
<p>可以把这个过程看成造车：</p>
<p>函数柯里化就是自动化的流水线，流水线的工人各司其职共同造一台车。</p>
<p>普通函数则是一个工人去造一台车。</p>
<p>这样函数柯里化的优点就很明显了：当某个环节的工人出现问题的时候，我们可以快速找到该员工，进行批评教育。</p>
<p>但是如果是普通函数，那么我们则需要从一个人的身上慢慢找问题。整个工作也都停了。</p>
<h3 id="函数演示"><a href="#函数演示" class="headerlink" title="函数演示"></a>函数演示</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Psum</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y + z</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数柯里化以后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">z</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> x + y + z</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么一看貌似柯里化真的就是自找麻烦一样，但是如果这里不是简单的相加操作呢？</p>
<p>在真实的开发环境里，可能我们这的一个相加操作就是几十行业务代码。如果把它全部放在一个函数里，维护成本，可阅读性真的就太差了。</p>
<h2 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  x = x + <span class="number">2</span></span><br><span class="line">  y = y * <span class="number">2</span></span><br><span class="line">  z = z * z</span><br><span class="line">  <span class="keyword">return</span> x + y + z</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  x = x + <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">    y = y * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">z</span>) </span>&#123;</span><br><span class="line">      z = z * z</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> x + y + z</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">10</span>)(<span class="number">20</span>)(<span class="number">30</span>))</span><br></pre></td></tr></table></figure>

<p>从这段代码中，我们可以看出 在 sum 函数中，每一个函数都是各司其职，专注干好自己的事情。等所有都处理好了。再统一返回。</p>
<h2 id="逻辑复用"><a href="#逻辑复用" class="headerlink" title="逻辑复用"></a>逻辑复用</h2><p>假如我们需要设计一个函数，实现传入两个参数，第一个为指定基础数字 X，另一个是与 X 相加的数字。</p>
<p>我们很快可以用传统方法写出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">m, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> m + n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假如在程序中,我们经常需要把5和另外一个数字进行相加</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">5</span>, <span class="number">10</span>))</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">5</span>, <span class="number">14</span>))</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">5</span>, <span class="number">1100</span>))</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">5</span>, <span class="number">555</span>))</span><br></pre></td></tr></table></figure>

<p>但是未免有点繁琐</p>
<p>所以我们在此引出，函数柯里化，逻辑复用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个makeAdder函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAdder</span>(<span class="params">count</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//在此时如果只传入了一个参数，那么我们目前只确定了 return function中的count 但是</span></span><br><span class="line">  <span class="comment">//num的值我们还未确定。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count + num</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入count值，创造makeAdder5的函数</span></span><br><span class="line"><span class="keyword">var</span> adder5 = makeAdder(<span class="number">5</span>)</span><br><span class="line">adder5(<span class="number">10</span>)</span><br><span class="line">adder5(<span class="number">14</span>)</span><br><span class="line">adder5(<span class="number">1100</span>)</span><br><span class="line">adder5(<span class="number">555</span>)</span><br></pre></td></tr></table></figure>

<p>从这里开始，我们就可以慢慢体会函数柯里化的好处了！</p>
<h1 id="手写柯里化函数"><a href="#手写柯里化函数" class="headerlink" title="手写柯里化函数"></a>手写柯里化函数</h1><p>首先 我们可以从最外层，最浅显的入手</p>
<ul>
<li>传入一个函数，返回一个函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myCurrying</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">curried</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> curried</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>接收参数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myCurrying</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">curried</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//判断args接收的参数是否已经足够   fn.length是函数fn里接受的参数个数</span></span><br><span class="line">    <span class="keyword">if</span> (args.length &gt;= fn.length) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> curried</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>情况一： fn（）直调</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myCurrying</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">curried</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length &gt;= fn.length) &#123;</span><br><span class="line">      <span class="comment">//在此处如果直接使用fn（）调用，如果之后是使用call的方式调用新函数，则fn可能并不是之前的fn。而是被call指定了其他的this</span></span><br><span class="line">      fn(...args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> curried</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>apply /call 调用</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myCurrying</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">curried</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length &gt;= fn.length) &#123;</span><br><span class="line">      <span class="comment">//此处直接显示绑定this，该this为curried对象</span></span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> curried</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>没有传入足够参数时，执行 else</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myCurrying</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">curried</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length &gt;= fn.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, args)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//递归思想 curried2接收剩余参数</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">curried2</span>(<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//再次调用curried 传入this=&gt;curried 解构拼接两个参数</span></span><br><span class="line">        <span class="keyword">return</span> curried.apply(<span class="built_in">this</span>, [...args, ...args2])</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//返回curried2方法 为下次接收参数做准备</span></span><br><span class="line">      <span class="keyword">return</span> curried2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回新函数</span></span><br><span class="line">  <span class="keyword">return</span> curried</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过这次学习，深刻理解了纯函数，函数的柯里化。也自己尝试着实现了函数的柯里化。希望能在后续的开发学习中能及时运用这些方法。</p>
]]></content>
      <categories>
        <category>底层逻辑</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Js常用数组高阶函数</title>
    <url>/2021/09/06/Js%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>js 中有很多高阶函数，能在日常的代码编写工作中提高效率。下面列举一些常用 js 的数组高阶函数</p>
<h2 id="FOO-数组"><a href="#FOO-数组" class="headerlink" title="FOO 数组"></a>FOO 数组</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = [<span class="number">10</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">100</span>, <span class="number">55</span>]</span><br></pre></td></tr></table></figure>

<h3 id="filter-过滤"><a href="#filter-过滤" class="headerlink" title="filter: 过滤"></a>filter: 过滤</h3><p>返回布尔类型 可以传递三个值 item 当前的的元素，index 当前数组下标， arr 当前整个数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组取偶操作</span></span><br><span class="line"><span class="keyword">var</span> numbers = nums.filter(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(numbers)</span><br></pre></td></tr></table></figure>

<h3 id="map-映射"><a href="#map-映射" class="headerlink" title="map: 映射"></a>map: 映射</h3><p>对所有的 item 进行操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对每个item进行*10操作</span></span><br><span class="line"><span class="keyword">var</span> nums2 = nums.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item * <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(nums2)</span><br></pre></td></tr></table></figure>

<h3 id="forEach-迭代"><a href="#forEach-迭代" class="headerlink" title="forEach: 迭代"></a>forEach: 迭代</h3><p>无返回值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历数组，无返回值！</span></span><br><span class="line">nums.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="find-findIndex-查找"><a href="#find-findIndex-查找" class="headerlink" title="find/findIndex :查找"></a>find/findIndex :查找</h3><p>查找 item/返还该 item/itemIndex</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> item = nums.find(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item == <span class="number">11</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(item)</span><br></pre></td></tr></table></figure>

<h3 id="reduce-累加"><a href="#reduce-累加" class="headerlink" title="reduce :累加"></a>reduce :累加</h3><p>preValue 前数据;</p>
<p>0:基础数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组累加操作</span></span><br><span class="line"><span class="keyword">var</span> total = nums.reduce(<span class="function">(<span class="params">preValue, item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> preValue + item</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(total)</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>js 中很多高阶函数，我们还需继续探索。慢慢感受 js 的魅力！</p>
]]></content>
      <categories>
        <category>技术实现</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>React 初体验</title>
    <url>/2021/09/15/React-%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><p>React 基本上是高级前端工程师的必备技能，相较于 Vue 也更加灵活。可以说是 Facebook 工程师们智慧的结晶。</p>
<p>在现阶段，学习 React 可以提高自己对前端的理解，扩大及自己的技术广度。为以后开发中大型项目奠基。</p>
<h1 id="初体验"><a href="#初体验" class="headerlink" title="初体验"></a>初体验</h1><h3 id="完成点击按钮修改文字的操作"><a href="#完成点击按钮修改文字的操作" class="headerlink" title="完成点击按钮修改文字的操作"></a>完成点击按钮修改文字的操作</h3><ul>
<li>创建一个 html 文件 引入 React 相关 CDN 链接</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">      <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react@16/umd/react.development.js&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">crossorigin</span></span></span><br><span class="line"><span class="tag">    &gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">      <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">crossorigin</span></span></span><br><span class="line"><span class="tag">    &gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>React 和 Vue 不一样，React 的理念更像是类纯函数。我们从 CDN 也可以看出分别引入了 React 核心文件，React-dom，Babel 转译。每个都各司其职。而 Vue 则是全部打包在一起直接引入。</strong></p>
<p>成功引入相关依赖后，这样我们就可以开始我们的 React 开发了</p>
<ul>
<li>实现功能</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 需要渲染的地方，通过id来实现挂载 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 导入相关依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">      <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react@16/umd/react.development.js&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">crossorigin</span></span></span><br><span class="line"><span class="tag">    &gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">      <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">crossorigin</span></span></span><br><span class="line"><span class="tag">    &gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开始开发 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注意事项：想在script使用jsx 需要添加标签 type=“text/babel” --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- jsx多个组件在根的层面，只能有一个标签，就如同 Vue：div 来包裹--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="comment">//封装App组件，该App类继承了React.Component</span></span></span><br><span class="line"><span class="javascript">      <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//变量放在constructor()中</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">//由于是继承类，需要调用一下super（）</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">super</span>()</span></span><br><span class="line"><span class="javascript">          <span class="comment">//动态数据，统一存放在this.state中</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.state = &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">mes</span>: <span class="string">&#x27;Hello world&#x27;</span>,</span></span><br><span class="line"><span class="javascript">          &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">//	render（）渲染</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> (</span></span><br><span class="line"><span class="javascript">            <span class="comment">//如同Vue一样，需要用唯一的&lt;div&gt;&lt;/div&gt;来包裹内容</span></span></span><br><span class="line"><span class="javascript">            <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="javascript">              // 调用动态数据注意是this.state.的方式</span></span></span><br><span class="line"><span class="xml"><span class="javascript">              <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;this.state.mes&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="javascript">              //React是声明式编程，这里绑定方法用的是onClick（）=&#123;&#125;</span></span></span><br><span class="line"><span class="xml"><span class="javascript">              的方式进行的，切需要.bind来给它指定一个this</span></span></span><br><span class="line"><span class="xml"><span class="javascript">              <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.btnCLick.bind(this)&#125;</span>&gt;</span>改变文字<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="javascript">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="javascript">          )</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//  永远不要手动调用render（）</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 相关函数</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">btnCLick</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">&#x27;按钮发生了点击&#x27;</span>)</span></span><br><span class="line"><span class="javascript">          <span class="comment">//通过this.setState的方式来修改state里面的内容</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.setState(&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">mes</span>: <span class="string">&#x27;Hello React&#x27;</span>,</span></span><br><span class="line"><span class="javascript">          &#125;)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="comment">//渲染组件       渲染内容，挂载对象</span></span></span><br><span class="line"><span class="javascript">      ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>))</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>React 总体上要比 Vue 难很多，但是也带来了灵活的特性。希望通过自己的坚持，能够掌握 React 的开发技术！</p>
]]></content>
      <categories>
        <category>技术实现</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Js中的严格模式</title>
    <url>/2021/09/16/Js%E4%B8%AD%E7%9A%84%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>在 JavaScript 中，我们常常在非严格模式/松散模式下进行编译。Js 会将一些语法的错误保持静默，像是睁一只眼闭一只眼。在严格模式下，这些错误就会被 Js 揪出来。</p>
<h1 id="JS-语法补充"><a href="#JS-语法补充" class="headerlink" title="JS 语法补充"></a>JS 语法补充</h1><h3 id="with-语句"><a href="#with-语句" class="headerlink" title="with 语句"></a>with 语句</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">mes</span>: <span class="string">&#x27;like&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//现在obj里找，没有就一直向上找</span></span><br><span class="line">    <span class="keyword">with</span> (obj) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(mes)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  bar()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>在 with 语句中，我们可以给其指定一个对象，使其中的语句优先查找对象中的相关内容。</p>
<p>如果该对象中没有改属性，则就一直向上查找，直到全局。</p>
<p><strong>并不建议使用 with，其代码可读性差，容易产生混淆错误兼容性问题。</strong></p>
<h3 id="eval-函数"><a href="#eval-函数" class="headerlink" title="eval 函数"></a>eval 函数</h3><p>eval 是一个特殊的函数，它可以将传入的字符串当做 JavaScript 代码来运行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> evalString = <span class="string">`var message = &quot;Hello&quot;;console.log(message);`</span></span><br><span class="line"><span class="built_in">eval</span>(evalString)</span><br><span class="line"><span class="built_in">console</span>.log(message)</span><br></pre></td></tr></table></figure>

<p>十分不建议在实际开发中使用，其容易被劫持，存在很大的安全隐患！</p>
<ol>
<li><p>eval 代码的可读性非常的差（代码的可读性是高质量代码的重要原则）</p>
</li>
<li><p>eval 是一个字符串，那么有可能在执行的过程中被刻意篡改，那么可能会造成被攻击的风险；</p>
</li>
<li><p>eval 的执行必须经过 JS 解释器，不能被 JS 引擎优化</p>
</li>
</ol>
<h1 id="非严格模式静默"><a href="#非严格模式静默" class="headerlink" title="非严格模式静默"></a>非严格模式静默</h1><h3 id="非严格模式"><a href="#非严格模式" class="headerlink" title="非严格模式"></a>非严格模式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mes = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(mes)</span><br><span class="line">&#125;</span><br><span class="line">foo() <span class="comment">//123</span></span><br><span class="line"><span class="comment">//在非严格模式下 此处能打印mes的值</span></span><br></pre></td></tr></table></figure>

<p>我们并没有用 var 来声明变量，而是直接赋值。这是一种错误的语法，但是在非严格模式下，js 保持静默。</p>
<h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开启严格模式</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line">mes = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(mes)</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>在严格模式下，js 会严格查找语法中的错误，此处的 mes 会报错，为： mes is not defined</p>
<h1 id="严格模式-1"><a href="#严格模式-1" class="headerlink" title="严格模式"></a>严格模式</h1><h2 id="严格模式概述"><a href="#严格模式概述" class="headerlink" title="严格模式概述"></a>严格模式概述</h2><ol>
<li><p>在 ECMAScript5 标准中，JavaScript 提出了<strong>严格模式的概念（Strict Mode）</strong></p>
<ul>
<li>严格模式很好理解，是一种具有限制性的 JavaScript 模式，从而使代码隐式的脱离了 ”懒散（sloppy）模式“</li>
<li>支持严格模式的浏览器在检测到代码中有严格模式时，会以更加严格的方式对代码进行检测和执行</li>
</ul>
</li>
<li><p>严格模式对正常的 JavaScript 语义进行了一些限制：</p>
<ul>
<li><p>严格模式通过 抛出错误 来消除一些原有的 静默（silent）错误</p>
</li>
<li><p>严格模式让 JS 引擎在执行代码时可以进行更多的优化（不需要对一些特殊的语法进行处理）</p>
</li>
<li><p>严格模式禁用了在 ECMAScript 未来版本中可能会定义的一些语法</p>
<p>​ <em>Text from why：coderwhy</em></p>
</li>
</ul>
</li>
</ol>
<h2 id="严格模式的开启方式"><a href="#严格模式的开启方式" class="headerlink" title="严格模式的开启方式"></a>严格模式的开启方式</h2><h3 id="文件开启"><a href="#文件开启" class="headerlink" title="文件开启"></a>文件开启</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//	文件开启的方式</span></span><br><span class="line"><span class="comment">// &#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line">mes = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(mes)</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<h3 id="函数内开启"><a href="#函数内开启" class="headerlink" title="函数内开启"></a>函数内开启</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">use</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// //函数内开启严格模式</span></span><br><span class="line">  <span class="comment">// &#x27;use strict&#x27;</span></span><br><span class="line">  <span class="literal">true</span>.foo = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">use()</span><br></pre></td></tr></table></figure>

<h2 id="严格模式的限制"><a href="#严格模式的限制" class="headerlink" title="严格模式的限制"></a>严格模式的限制</h2><ol>
<li><p>无法意外地创建出全局变量。</p>
</li>
<li><p>所有的静默失效，会以异常的方式抛出。</p>
</li>
<li><p>如果试图删除不可删除的属性，将会报错。</p>
</li>
<li><p>不允许函数中传入两个相同的变量名（非严格模式下，x，y，x。接受的为最后一个 x）</p>
</li>
<li><p>不允许使用 0 的八进制语法</p>
</li>
<li><p>不允许使用 with</p>
</li>
<li><p>eval 不能再引用上层变量</p>
</li>
<li><p>this 不会转换为默认对象，（而是变成 undefined）</p>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>js 中的严格模式，在新手使用中，是一种很好的保护方式。可以在严格的语法纠错中，找的自己的问题出在哪里。不为后续的开发留下安全隐患。</p>
]]></content>
      <categories>
        <category>底层逻辑</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>axios拦截</title>
    <url>/2021/08/30/axios%E6%8B%A6%E6%88%AA/</url>
    <content><![CDATA[<h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><p>实现在 axios 每次请求/响应时，对请求/响应进行相关的处理。我们把这种处理方式称之为拦截。</p>
<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><ol>
<li>request.js 文件的封装</li>
</ol>
<h4 id="首先我们要将-axios-主要的请求封装在-request-js-文件中，这样我们可以降低代码的耦合度，提高整体的效率，方便后期的维护。"><a href="#首先我们要将-axios-主要的请求封装在-request-js-文件中，这样我们可以降低代码的耦合度，提高整体的效率，方便后期的维护。" class="headerlink" title="首先我们要将 axios 主要的请求封装在 request.js 文件中，这样我们可以降低代码的耦合度，提高整体的效率，方便后期的维护。"></a>首先我们要将 axios 主要的请求封装在 request.js 文件中，这样我们可以降低代码的耦合度，提高整体的效率，方便后期的维护。</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将axios插件导入</span></span><br><span class="line"><span class="keyword">import</span> axios from <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建axios方法，并将该方法导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> request(<span class="keyword">config</span>) &#123;</span><br><span class="line">  <span class="comment">// 1.创建axios的实例</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">instance</span> = axios<span class="variable">.create</span>(&#123;</span><br><span class="line">    baseURL: <span class="string">&quot;*******&quot;</span>,</span><br><span class="line">    timeout: <span class="number">5000</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 2.设立请求/响应拦截</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.发送真正的网络请求</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">instance</span>(<span class="keyword">config</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>axios 拦截器</li>
</ol>
<ul>
<li>请求拦截</li>
</ul>
<p>可以在任何的请求上进行修饰，改变。此处我以添加 Authorization：Token 的方法为例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用axios的请求拦截方法</span></span><br><span class="line">instance.interceptors.request.use(</span><br><span class="line">  <span class="comment">//对参数进行处理</span></span><br><span class="line">    <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//具体操作</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">localStorage</span>.getItem(<span class="string">&quot;Authorization&quot;</span>)) &#123;</span><br><span class="line">        config.headers.Authorization = <span class="built_in">localStorage</span>.getItem(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//最后注意需要返回修饰后的参数</span></span><br><span class="line">      <span class="keyword">return</span> config;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//如果请求是错误的，我们将异常抛出</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>

<ul>
<li>响应拦截</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//axios响应拦截方法</span></span><br><span class="line">instance.interceptors.response.use(</span><br><span class="line">    <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//获取响应参数，并返回</span></span><br><span class="line">      <span class="keyword">return</span> res.data;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//如果返还错误，提取相关的Status响应码，进行错误提示</span></span><br><span class="line">      <span class="keyword">const</span> &#123; response &#125; = err;</span><br><span class="line">      <span class="keyword">if</span> ((response.status = <span class="number">401</span>)) &#123;</span><br><span class="line">        <span class="built_in">localStorage</span>.removeItem(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="built_in">localStorage</span>.removeItem(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">        <span class="built_in">localStorage</span>.removeItem(<span class="string">&quot;userId&quot;</span>);</span><br><span class="line">        alert(<span class="string">&quot;请登陆后再使用哦～&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>后续调用</li>
</ol>
<p>如需对接后端接口，仅需要创建相关 js 文件，并写入具体请求方法。</p>
<ul>
<li>user.js</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入我们之前封装好的request文件</span></span><br><span class="line"><span class="keyword">import</span> &#123; request &#125; <span class="keyword">from</span> <span class="string">&quot;./request&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写具体的对接接口的方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">GetUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> request(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;/users/name&quot;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传参类：</span></span><br><span class="line"><span class="comment">//将需要的参数写在方法内</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ChangeUserSkin</span>(<span class="params">flag, <span class="keyword">type</span>, fix</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> request(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;/users/skintest&quot;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">    <span class="comment">//将所需的数据创建好。</span></span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">flag</span>: flag,</span><br><span class="line">      <span class="attr">type</span>: <span class="keyword">type</span>,</span><br><span class="line">      <span class="attr">fix</span>: fix</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>axios 在日常的 vue 开发中是使用频率很高的组件，用来进行前后端数据交互工作。整体上并不难。需要我们熟练掌握相关的方法，逻辑。其中也需要注意代码的规范，体现封装性。</p>
]]></content>
      <categories>
        <category>技术实现</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title>node.js 用户登陆初体验</title>
    <url>/2021/08/14/node-js-%E7%94%A8%E6%88%B7%E7%99%BB%E9%99%86%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<h2 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h2><p>写一个接口，实现从用户输入中获得数据</p>
<h2 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h2><h4 id="文件夹功能分类"><a href="#文件夹功能分类" class="headerlink" title="文件夹功能分类"></a>文件夹功能分类</h4><ol>
<li>app (app 操作文件夹)</li>
</ol>
<ul>
<li>index.js (导入所使用的插件，中间件)</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入所需的插件，中间件</span></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="keyword">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="keyword">require</span>(<span class="string">&#x27;koa-bodyparser&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> userRouter = <span class="keyword">require</span>(<span class="string">&#x27;../router/user.router&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化Koa对象</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册/使用插件，中间件</span></span><br><span class="line">app.<span class="keyword">use</span>(bodyParser())</span><br><span class="line">app.<span class="keyword">use</span>(userRouter.routes())</span><br><span class="line">app.<span class="keyword">use</span>(userRouter.allowedMethods())</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出app 以便其他模块使用</span></span><br><span class="line">module.exports = app</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>config.js (配置操作)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入插件</span></span><br><span class="line"><span class="keyword">const</span> dotenv = require(<span class="string">&#x27;dotenv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用插件的方法，导入写好的配置文件（.env）</span></span><br><span class="line">dotenv.config()</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span>.<span class="keyword">exports</span> = &#123; APP_PORT &#125; = process.env</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>main.js (程序的总入口)</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入之前的Koa实例化的对象app。 导入配置文件</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">&#x27;./app&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&#x27;./app/config&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建服务器，并利用config的APP_PORT参数</span></span><br><span class="line">app.listen(config.APP_PORT, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`服务器在<span class="subst">$&#123;config.APP_PORT&#125;</span>端口已启动`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>router (所有的路由管理文件夹)</li>
</ol>
<ul>
<li>user.router.js (user 的路由管理)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路由相关的js 注册接口适用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//导入koa-router组件</span></span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>)</span><br><span class="line"><span class="comment">//导入方法</span></span><br><span class="line"><span class="keyword">const</span> &#123; create &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../controller/user.controller&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册路由 其路径为/users</span></span><br><span class="line"><span class="keyword">const</span> userRouter = <span class="keyword">new</span> Router(&#123; <span class="attr">prefix</span>: <span class="string">&#x27;/users&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置路由的响应方式，响应方法</span></span><br><span class="line">userRouter.post(<span class="string">&#x27;/&#x27;</span>, create)</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出路由</span></span><br><span class="line"><span class="built_in">module</span>.exports = userRouter</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>controller (管理不同路径下的不同的情况下的方法，操作)</li>
</ol>
<ul>
<li>user.controller.js (user 的一些方法，操作)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入写好的方法</span></span><br><span class="line"><span class="keyword">const</span> service = <span class="built_in">require</span>(<span class="string">&#x27;../service/user.service&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建类 其中包含了不同情况下的不同方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">create</span>(<span class="params">ctx, next</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//获取用户请求的参数</span></span><br><span class="line">    <span class="keyword">const</span> user = ctx.request.body</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询数据</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> service.create(user)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回数据</span></span><br><span class="line">    ctx.body = result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> UserController()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>service (业务层，其一般对接着 mysql 数据库操作)</li>
</ol>
<ul>
<li>user.service.js</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">create</span>(<span class="params">user</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;将用户数据保存到数据库中&#x27;</span>, user)</span><br><span class="line">    <span class="comment">//将user存储到数据库中</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;创建用户成功&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> UserService()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>utils (工具类)</p>
</li>
<li><p>.env (配置文件)</p>
</li>
</ol>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务器端口号</span></span><br><span class="line"><span class="attr">APP_PORT</span>=<span class="number">8000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="实现结果"><a href="#实现结果" class="headerlink" title="实现结果"></a>实现结果</h2><p><img src="/2021/08/14/node-js-%E7%94%A8%E6%88%B7%E7%99%BB%E9%99%86%E5%88%9D%E4%BD%93%E9%AA%8C/1.png" alt="node 运行结果"><br><img src="/2021/08/14/node-js-%E7%94%A8%E6%88%B7%E7%99%BB%E9%99%86%E5%88%9D%E4%BD%93%E9%AA%8C/2.png" alt="接口响应结果"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次实现了一个小功能，主要目的是想让自己理清楚这个文件与文件之间的关系，以及不同的文件之间的分工。</p>
]]></content>
      <categories>
        <category>技术实现</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo s 时4000端口被占用问题</title>
    <url>/2021/07/25/hexo-s-%E6%97%B64000%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>hexo s 启动的时候遇到了 4000 端口无法创建使用的问题。<br>具体打开 localhost：4000 发现 4000 端口下 hexo 依然在运行！</p>
<h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><p>(mac 环境):</p>
<ol>
<li>sudo lsof -i tcp:4000<br><strong>查询当前端口的进程</strong></li>
<li>报错：</li>
</ol>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">COMMAND</span>   PID USER   FD   TYPE             DEVICE SIZE/<span class="literal">OFF</span> NODE NAME</span><br><span class="line"><span class="attribute">node</span>    <span class="number">19087</span> root   <span class="number">23</span>u  IPv<span class="number">6</span> <span class="number">0</span>xe<span class="number">0</span>d<span class="number">367</span>ae<span class="number">3505</span>eeb<span class="number">3</span>      <span class="number">0</span>t<span class="number">0</span>  TCP *:terabase (LISTEN)</span><br></pre></td></tr></table></figure>

<p>发现进程 19087</p>
<ol start="3">
<li>sudo kill 19087</li>
</ol>
<p><strong>再次打开就没有 hexo 的页面了</strong></p>
<h2 id="最后成功在-4000-默认端口下启动-hexo"><a href="#最后成功在-4000-默认端口下启动-hexo" class="headerlink" title="最后成功在 4000 默认端口下启动 hexo"></a>最后成功在 4000 默认端口下启动 hexo</h2>]]></content>
      <categories>
        <category>Obstacle</category>
      </categories>
      <tags>
        <tag>技术踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>mmjd项目的完成情况</title>
    <url>/2021/08/25/mmjd%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%AE%8C%E6%88%90%E6%83%85%E5%86%B5/</url>
    <content><![CDATA[<h2 id="项目进度"><a href="#项目进度" class="headerlink" title="项目进度:"></a>项目进度:</h2><p>最近一直在做那个护肤品测评网站，可谓是从无到有，功能也都在慢慢实现。目前已经完成了 90% 剩余的就是 Debug 和样式</p>
<h2 id="接口功能："><a href="#接口功能：" class="headerlink" title="接口功能："></a>接口功能：</h2><h3 id="不多说了，直接上图！"><a href="#不多说了，直接上图！" class="headerlink" title="不多说了，直接上图！"></a>不多说了，直接上图！</h3><ol>
<li>后端接口：<br><img src="/2021/08/25/mmjd%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%AE%8C%E6%88%90%E6%83%85%E5%86%B5/user.png" alt="接口功能图"><br><img src="/2021/08/25/mmjd%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%AE%8C%E6%88%90%E6%83%85%E5%86%B5/end.png" alt="接口功能图"></li>
</ol>
<p>真的是完完整地做完了整个项目的后端接口。从中真的学会了很多！慢慢也熟悉了 Node.js + Koa 开发接口的开发逻辑。</p>
<ol start="2">
<li>Mysql：<br><img src="/2021/08/25/mmjd%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%AE%8C%E6%88%90%E6%83%85%E5%86%B5/mysql1.png" alt="mysql"><br><img src="/2021/08/25/mmjd%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%AE%8C%E6%88%90%E6%83%85%E5%86%B5/mysql2.png" alt="mysql"><br><img src="/2021/08/25/mmjd%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%AE%8C%E6%88%90%E6%83%85%E5%86%B5/mysql3.png" alt="mysql"></li>
</ol>
<p>从中也重新回忆起了很多的 sql 语句（真的好久不用生疏了！）比如：left join ，json_object….</p>
<h2 id="前端界面："><a href="#前端界面：" class="headerlink" title="前端界面："></a>前端界面：</h2><p><img src="/2021/08/25/mmjd%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%AE%8C%E6%88%90%E6%83%85%E5%86%B5/font1.png" alt="font"><br>现在的前端界面真的奇丑无比，等着这两天我调好了我们再看！</p>
<h2 id="技术栈："><a href="#技术栈：" class="headerlink" title="技术栈："></a>技术栈：</h2><ol>
<li>前端：Html JavaScript CSS Vue Vuex VueRouter axios Webpack node.js Bootstrap</li>
<li>后端：node.js Koa mysql</li>
<li>数据库: mysql</li>
</ol>
<h2 id="收获："><a href="#收获：" class="headerlink" title="收获："></a>收获：</h2><p>通过这次完完整整地独自开发前后端的项目，很多东西真的就是要亲自来才能深刻体会！<br>希望自己以后能参与或创造更多的项目！</p>
<h2 id="开源地址"><a href="#开源地址" class="headerlink" title="开源地址:"></a>开源地址:</h2><ol>
<li>前端：<br><a href="https://github.com/Oliverxuan/mmjd">https://github.com/Oliverxuan/mmjd</a></li>
<li>后端：<br><a href="https://github.com/Oliverxuan/MMJD-node">https://github.com/Oliverxuan/MMJD-node</a></li>
</ol>
]]></content>
      <categories>
        <category>CodeLife</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>vue表单提交时自动刷新</title>
    <url>/2021/08/31/vue%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4%E6%97%B6%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在之前 mmjd 的项目中，我设计了一个登陆的界面。发现当第一次提交的时候，会默认刷新一次。导致用户提交的表单是空的。从而报错。</p>
<p>这直接导致了很不好的用户体验。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>vue 中使用表单 form 默认提交行为是刷新一下，在这儿我们使用事件修饰符 prevent 来阻止 form 表单的默认行为</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;input <span class="attribute">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attribute">value</span>=<span class="string">&quot;提交&quot;</span> @click.<span class="attribute">prevent</span>=<span class="string">&#x27;had&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个点似曾相识，在以前学习的时候老师好像提到过。自己没注意到细节上的东西。反向说明了自己对 vue 的一些细节，和项目经验不足。需要继续提高！</p>
]]></content>
      <categories>
        <category>Obstacle</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>node后端项目初始化</title>
    <url>/2021/10/25/node%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>技术实现</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>关于大三一年的计划</title>
    <url>/2021/07/25/%E5%85%B3%E4%BA%8E%E5%A4%A7%E4%B8%89%E4%B8%80%E5%B9%B4%E7%9A%84%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<p>大三这一年真的是无比关键.想着明年的今天就是我实习的日子.心里多少还是有些焦虑。</p>
<h3 id="回顾自身："><a href="#回顾自身：" class="headerlink" title="回顾自身："></a>回顾自身：</h3><p>大一光顾着玩耍，等到大一暑假的时候突然感觉”玩的索然无味“玩的甚至有点空虚。觉得这不是自己想要的生活。于是放下了我喜欢的游戏。打开了哔哩哔哩，搜起了关于 Java 的教学视频，我还记着我第一次装 Jdk 第一次配置环境变量的时候的一脸懵逼。（这和我学的 C 不一样呀）好奇心促使我继续坚持学习了下去。就这样，我听着尚硅谷的宋红康老师的 Java 课程度过了第一个充实的暑假，也是在那个暑假，我渐渐地明白了，计算机的路，我才刚刚开始。等到了大二，我渐渐尝试着做一些简单的静态页面，跟着做一些简单的 JavaWeb 项目。当我第一次在我自己的数据库接收到前端页面发来的数据的时候，我真的无比激动！这真的是一件很有成就感的事情！<br>到了大二的下学期，在好朋友的指引下，我渐渐接触一些更深层次的东西，我学习了 CoderWhy 老师的 Vue，学完了 Vue 我也深刻体会到组件化开发的便利性。真的佩服我们的尤大佬！能开发出这么好的框架！我什么时候才能到达他这种能力呀！<br>大二这一年，是我学习进步最快的一年，我渐渐明白到了真正的差距到底有多大。所以我想在我大三这一年，有计划有目标地进行学习！争取在一年后的今天能取得互联网大厂的 offer！</p>
<h3 id="大三规划："><a href="#大三规划：" class="headerlink" title="大三规划："></a>大三规划：</h3><h4 id="大方向：扎实内功，基础。深入底层逻辑，原理。追求技术深度。多总结，多学习。"><a href="#大方向：扎实内功，基础。深入底层逻辑，原理。追求技术深度。多总结，多学习。" class="headerlink" title="大方向：扎实内功，基础。深入底层逻辑，原理。追求技术深度。多总结，多学习。"></a>大方向：扎实内功，基础。深入底层逻辑，原理。追求技术深度。多总结，多学习。</h4><h4 id="具体目标，步骤"><a href="#具体目标，步骤" class="headerlink" title="具体目标，步骤:"></a>具体目标，步骤:</h4><ol>
<li>复习巩固计算机原理，数据结构等计算机基础。（巩固基础）</li>
<li>leetcode 坚持每天刷题。（巩固基础）</li>
<li>学习 Node.js 以达到能够做出前后端分离的全栈完整项目。（完善自己的技术面）</li>
<li>学习 uniapp 或 flutter 以达到跨平台，多处运用的目的。（完善自己的技术面）</li>
<li>深入研究 Javascript，Vue 的底层逻辑，以及源码。以达到一定的技术深度。（提高自己技术深度）</li>
<li>多做项目，多参加比赛。提高自己的眼界，技术的多样性，学习别人的优点，改善自己的不足。（提高自己技术深度）</li>
</ol>
]]></content>
      <categories>
        <category>CodeLife</category>
      </categories>
      <tags>
        <tag>规划</tag>
      </tags>
  </entry>
  <entry>
    <title>创建用户并验证合法性</title>
    <url>/2021/08/16/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E5%B9%B6%E9%AA%8C%E8%AF%81%E5%90%88%E6%B3%95%E6%80%A7/</url>
    <content><![CDATA[<h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><p>实现一个接口，可以读取用户的输入信息，并检查其合法性。<br>如果其合法，将其录入数据库中，如果不合法，返回其不合法的类型。</p>
<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><h3 id="1-创建数据库："><a href="#1-创建数据库：" class="headerlink" title="1.创建数据库："></a>1.创建数据库：</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `users`(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line"><span class="type">name</span> <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line"><span class="keyword">password</span> <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">createAt <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">updateAt <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="2-连接数据库"><a href="#2-连接数据库" class="headerlink" title="2.连接数据库"></a>2.连接数据库</h3><h4 id="1-配置数据库信息"><a href="#1-配置数据库信息" class="headerlink" title="1.配置数据库信息"></a>1.配置数据库信息</h4><ol>
<li>将数据库的配置写入 .env 文件中</li>
</ol>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mysql配置</span></span><br><span class="line"><span class="attr">MYSQL_HOST</span>=xxxxxx</span><br><span class="line"><span class="attr">MYSQL_PORT</span>=xxxx</span><br><span class="line"><span class="attr">MYSQL_DATABASE</span>=xxxxx</span><br><span class="line"><span class="attr">MYSQL_ROOT</span>=xxxxx</span><br><span class="line"><span class="attr">MYSQL_PASSWORD</span>=xxxxxx</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将数据库信息在 config.js 文件中导入</li>
</ol>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line"><span class="built_in">  APP_PORT,</span></span><br><span class="line"><span class="built_in">  MYSQL_HOST,</span></span><br><span class="line"><span class="built_in">  MYSQL_PORT,</span></span><br><span class="line"><span class="built_in">  MYSQL_DATABASE,</span></span><br><span class="line"><span class="built_in">  MYSQL_ROOT,</span></span><br><span class="line"><span class="built_in">  MYSQL_PASSWORD,</span></span><br><span class="line">&#125; = process.env</span><br></pre></td></tr></table></figure>

<h3 id="2-建立数据库连接"><a href="#2-建立数据库连接" class="headerlink" title="2.建立数据库连接"></a>2.建立数据库连接</h3><ol>
<li>在全局文件夹（app）里新建关于数据库操作的 database.js 文件</li>
<li>导入 mysql 插件</li>
</ol>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">const</span> <span class="variable">mysql</span> = <span class="function"><span class="title">require</span>(<span class="string">&#x27;mysql2&#x27;</span>)</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>将配置信息导入</li>
</ol>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">const</span> <span class="variable">config</span> = <span class="function"><span class="title">require</span>(<span class="string">&#x27;./config&#x27;</span>)</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>创建数据库连接池,并将相关配置导入</li>
</ol>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> connections = mysql.<span class="built_in">createPool</span>(&#123;</span><br><span class="line">  host: config.MYSQL_HOST,</span><br><span class="line">  port: config.MYSQL_PORT,</span><br><span class="line">  database: config.MYSQL_DATABASE,</span><br><span class="line">  user: config.MYSQL_ROOT,</span><br><span class="line">  password: config.MYSQL_PASSWORD,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>取得数据库连接，并设置数据库启动提示</li>
</ol>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">connections.getConnection(<span class="function"><span class="params">(err, conn)</span> =&gt;</span> &#123;</span><br><span class="line">  conn.connect(<span class="function"><span class="params">(err)</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;数据库连接失败!&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;数据库连接成功！&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>将 connections 导出，从而达到封装。</li>
</ol>
<figure class="highlight mercury"><table><tr><td class="code"><pre><span class="line">//操作都是建立在connections.<span class="keyword">promise</span>（）上的，所以在导出的时候连带<span class="keyword">promise</span>()</span><br><span class="line"><span class="keyword">module</span>.exports <span class="built_in">=</span> connections.<span class="keyword">promise</span>()</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>在 main.js 中引入 database.js，从而达到加载目的</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">require</span><span class="params">(<span class="string">&#x27;./app/database&#x27;</span>)</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="8">
<li>测试连接,得到回应：<br><img src="/2021/08/16/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E5%B9%B6%E9%AA%8C%E8%AF%81%E5%90%88%E6%B3%95%E6%80%A7/database.png" alt="数据库连接成功"></li>
</ol>
<h3 id="3-实现数据库的存入"><a href="#3-实现数据库的存入" class="headerlink" title="3.实现数据库的存入"></a>3.实现数据库的存入</h3><ol>
<li>实现 create 方法</li>
</ol>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询数据</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">result</span> = <span class="keyword">await</span> service.create(user)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 service 的 user.service.js 中写入数据库操作</li>
</ol>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">//操作都是异步的所以要加上async await</span><br><span class="line">async <span class="keyword">create</span>(<span class="keyword">user</span>) &#123;</span><br><span class="line">  //从<span class="keyword">user</span>中获取<span class="keyword">user</span>，<span class="keyword">password</span></span><br><span class="line">    const &#123; <span class="type">name</span>, <span class="keyword">password</span> &#125; = <span class="keyword">user</span></span><br><span class="line">    //<span class="keyword">sql</span>语句</span><br><span class="line">    const <span class="keyword">statement</span> = <span class="string">&#x27;INSERT INTO users (name,password) VALUES (?,?);&#x27;</span></span><br><span class="line">    //执行<span class="keyword">sql</span>语句，并将查询结果返还至result中</span><br><span class="line">    const result = await <span class="keyword">connection</span>.<span class="keyword">execute</span>(<span class="keyword">statement</span>, [<span class="type">name</span>, <span class="keyword">password</span>])</span><br><span class="line">    <span class="keyword">return</span> result[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>执行结果<br><img src="/2021/08/16/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E5%B9%B6%E9%AA%8C%E8%AF%81%E5%90%88%E6%B3%95%E6%80%A7/result.png" alt="result"></li>
</ol>
<h3 id="优化过程：验证输入的合法性"><a href="#优化过程：验证输入的合法性" class="headerlink" title="优化过程：验证输入的合法性"></a>优化过程：验证输入的合法性</h3><ol>
<li>创建验证中间件 verifyUser ,并写入 UserRouter 中</li>
</ol>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">userRouter.<span class="built_in">post</span>(<span class="string">&#x27;/&#x27;</span>, verifyUser, <span class="built_in">create</span>)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>由于此类型的中间件在后续开发中会频繁创建，故统一在 middleware.js 中创建</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  导入错误类型</span></span><br><span class="line"><span class="keyword">const</span> errorType = <span class="built_in">require</span>(<span class="string">&#x27;../constants/error-types&#x27;</span>)</span><br><span class="line"><span class="comment">// 导入service 利用其中的getUserByName来验证是否已存在该用户</span></span><br><span class="line"><span class="keyword">const</span> service = <span class="built_in">require</span>(<span class="string">&#x27;../service/user.service&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建中间件，注意其也是异步操作！</span></span><br><span class="line"><span class="keyword">const</span> verifyUser = <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">//获取用户名，密码</span></span><br><span class="line">  <span class="keyword">const</span> &#123; name, password &#125; = ctx.request.body</span><br><span class="line"></span><br><span class="line">  <span class="comment">//判断不能为空</span></span><br><span class="line">  <span class="keyword">if</span> (!name || !password) &#123;</span><br><span class="line">    <span class="comment">//如果为空，则新建Error，其错误类型为：NAME_OR_PASSWORD_IS_REQUIRED</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(errorType.NAME_OR_PASSWORD_IS_REQUIRED)</span><br><span class="line">    <span class="comment">//将错误发射出去</span></span><br><span class="line">    <span class="keyword">return</span> ctx.app.emit(<span class="string">&#x27;error&#x27;</span>, error, ctx)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//判断本次注册的用户名是否被注册</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> service.getUserByNanme(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果返还不为NULL</span></span><br><span class="line">  <span class="keyword">if</span> (result.length) &#123;</span><br><span class="line">    <span class="comment">//新建error 错误类型为：USER_ALREADY_EXISTS</span></span><br><span class="line">    <span class="keyword">const</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(errorType.USER_ALREADY_EXISTS)</span><br><span class="line">    <span class="comment">//将错误发射出去</span></span><br><span class="line">    <span class="keyword">return</span> ctx.app.emit(<span class="string">&#x27;error&#x27;</span>, error, ctx)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果以上都未执行，则进行下一个中间件：create</span></span><br><span class="line">  <span class="keyword">await</span> next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出verifyUser</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  verifyUser,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>errorType 的创建<br>由于以后的错误类型会有很多，所以统一写入在 errorType 中</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> NAME_OR_PASSWORD_IS_REQUIRED = <span class="string">&#x27;name_or_password_is_required&#x27;</span></span><br><span class="line"><span class="keyword">const</span> USER_ALREADY_EXISTS = <span class="string">&#x27;user_already_exists&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span>.<span class="keyword">exports</span> = &#123;</span><br><span class="line">  NAME_OR_PASSWORD_IS_REQUIRED,</span><br><span class="line">  USER_ALREADY_EXISTS,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>service 中的 getUserByName 方法</li>
</ol>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">async getUserByNanme(<span class="type">name</span>) &#123;</span><br><span class="line">  const <span class="keyword">statement</span> = `<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> <span class="type">name</span> = ?;`</span><br><span class="line"></span><br><span class="line">  const result = await <span class="keyword">connection</span>.<span class="keyword">execute</span>(<span class="keyword">statement</span>, [<span class="type">name</span>])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在 index.js 中接收报错信息</li>
</ol>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">app</span>.<span class="keyword">on</span>(&#x27;<span class="keyword">error</span>&#x27;, errorHandler)</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>创建错误处理 error-handle.js<br>在其中统一处理错误信息</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入错误类型</span></span><br><span class="line"><span class="keyword">const</span> errorTypes = <span class="built_in">require</span>(<span class="string">&#x27;../constants/error-types&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入之前发射出来的参数error，ctx，并进行分析处理</span></span><br><span class="line"><span class="keyword">const</span> errorHandler = <span class="function">(<span class="params">error, ctx</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//建立状态变量，和报错提示</span></span><br><span class="line">  <span class="keyword">let</span> status, message</span><br><span class="line"></span><br><span class="line">  <span class="comment">//通过传入的错误类型来判断处理方式</span></span><br><span class="line">  <span class="keyword">switch</span> (error.message) &#123;</span><br><span class="line">    <span class="keyword">case</span> errorTypes.NAME_OR_PASSWORD_IS_REQUIRED:</span><br><span class="line">      status = <span class="number">400</span> <span class="comment">//Bad request</span></span><br><span class="line">      message = <span class="string">&#x27;用户名或者密码为空&#x27;</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> errorTypes.USER_ALREADY_EXISTS:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">      status = <span class="number">409</span> <span class="comment">//Conflict</span></span><br><span class="line">      message = <span class="string">&#x27;用户名已存在&#x27;</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      status = <span class="number">404</span></span><br><span class="line">      message = <span class="string">&#x27;NOT FOUND&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将错误信息导入ctx中</span></span><br><span class="line">  ctx.status = status</span><br><span class="line">  ctx.body = message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = errorHandler</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>错误展示<br>用户已存在：<br><img src="/2021/08/16/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E5%B9%B6%E9%AA%8C%E8%AF%81%E5%90%88%E6%B3%95%E6%80%A7/useretsis.png" alt="用户已存在"><br>状态码：<br><img src="/2021/08/16/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E5%B9%B6%E9%AA%8C%E8%AF%81%E5%90%88%E6%B3%95%E6%80%A7/status1.png" alt="状态码"></li>
</ol>
<p>用户输入名或密码为空:<br><img src="/2021/08/16/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E5%B9%B6%E9%AA%8C%E8%AF%81%E5%90%88%E6%B3%95%E6%80%A7/null.png" alt="null"><br>状态码：<br><img src="/2021/08/16/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E5%B9%B6%E9%AA%8C%E8%AF%81%E5%90%88%E6%B3%95%E6%80%A7/status2.png" alt="状态码"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过今天的汇总，逐渐将其中的思路理清楚，为以后开发接口提供了思路。</p>
]]></content>
      <categories>
        <category>技术实现</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>岛屿问题的实现</title>
    <url>/2021/07/31/%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给你一个由  ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/number-of-islands">https://leetcode-cn.com/problems/number-of-islands</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>此问题与上一期的门墙算法的实现的思想基本一致，属于利用队列，以及广度优先搜索（dfs）的方式解决问题。但是并不是完全的相同。本问题需要注意在于广度优先搜索的时候，需要有“感染”的思想。 首先遍历整个二维数组，寻找数组中的岛 再在孤岛的基础上 遍历他的上下左右临格元素 是否也为“1”岛屿 如果是 将它感染。</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">        public <span class="keyword">int</span> numIslands(char[][] <span class="keyword">grid</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">grid</span>.length==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">grid</span>.length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">grid</span>[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="keyword">grid</span>[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                        count++;</span><br><span class="line">                        dfs(<span class="keyword">grid</span>,i,j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    private void dfs(char[][] <span class="keyword">grid</span>, <span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;= <span class="keyword">grid</span>.length || j&lt;<span class="number">0</span> || j&gt;=<span class="keyword">grid</span>[<span class="number">0</span>].length || <span class="keyword">grid</span>[i][j]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">grid</span>[i][j]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        dfs(<span class="keyword">grid</span>, i - <span class="number">1</span>, j);</span><br><span class="line">        dfs(<span class="keyword">grid</span>, i + <span class="number">1</span>, j);</span><br><span class="line">        dfs(<span class="keyword">grid</span>, i, j + <span class="number">1</span>);</span><br><span class="line">        dfs(<span class="keyword">grid</span>, i, j - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Problems</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>循环队列的实现</title>
    <url>/2021/07/28/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。</p>
<p>循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。</p>
<p>你的实现应该支持如下操作：</p>
<p>MyCircularQueue(k): 构造器，设置队列长度为 k 。<br>Front: 从队首获取元素。如果队列为空，返回 -1 。<br>Rear: 获取队尾元素。如果队列为空，返回 -1 。<br>enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。<br>deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。<br>isEmpty(): 检查循环队列是否为空。<br>isFull(): 检查循环队列是否已满。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/design-circular-queue">https://leetcode-cn.com/problems/design-circular-queue</a></p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3<br>circularQueue.enQueue(1);  // 返回 true<br>circularQueue.enQueue(2);  // 返回 true<br>circularQueue.enQueue(3);  // 返回 true<br>circularQueue.enQueue(4);  // 返回 false，队列已满<br>circularQueue.Rear();  // 返回 3<br>circularQueue.isFull();  // 返回 true<br>circularQueue.deQueue();  // 返回 true<br>circularQueue.enQueue(4);  // 返回 true<br>circularQueue.Rear();  // 返回 4</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><ol>
<li>首先要明白循环队列的原理</li>
<li>如何设计循环队列中的两个指针</li>
<li>细节处理</li>
</ol>
<p>循环队列原理<br><a href="https://www.bilibili.com/video/BV1yx411e7nb?from=search&amp;seid=13632348157331521482/">https://www.bilibili.com/video/BV1yx411e7nb?from=search&amp;seid=13632348157331521482/</a></p>
<h3 id="实现难点："><a href="#实现难点：" class="headerlink" title="实现难点："></a>实现难点：</h3><ol>
<li>为什么要在 eg：head（head+1）% size 取模？</li>
<li>为什么 get tail 的时候不能直接返回？</li>
<li>细节处理</li>
</ol>
<h3 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCircularQueue</span> &#123;</span></span><br><span class="line">    <span class="comment">//构造原始数组</span></span><br><span class="line">    <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="comment">//数组长度</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">//头指针，记录循环列表的头部</span></span><br><span class="line">    <span class="keyword">int</span> head;</span><br><span class="line">    <span class="comment">//尾指针，记录循环列表的尾部</span></span><br><span class="line">    <span class="keyword">int</span> tail;</span><br><span class="line">    <span class="comment">//计数器，记录总共有多少个元素</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器，将原始的数组arr转化为实体，以及一些变量的初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCircularQueue</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        size = k;</span><br><span class="line">        head = <span class="number">0</span>;</span><br><span class="line">        tail = <span class="number">0</span>;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先判断队列是否已满。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isFull</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[tail] = value;</span><br><span class="line">        <span class="comment">//关键点！此处的指针也应该跟着循环，不能说到了数组的size（最大长度）就一直无限延续</span></span><br><span class="line">        <span class="comment">//所以这里需要取模运算&quot;%&quot; 例：k=size=7  tail=7 tail=（7+1%7=1 所以下次tail</span></span><br><span class="line">        <span class="comment">//的位置就在下角标为 1 的位置 从而达到循环指针的目的 后面的head指针同理</span></span><br><span class="line">        tail = (tail + <span class="number">1</span>) % size;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = (head + <span class="number">1</span>) % size;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//取头元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[head];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Rear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此处需要注意tail的真实位置到底指向的是哪里。</span></span><br><span class="line">        <span class="comment">//注意数据的处理不能取负。</span></span><br><span class="line">        <span class="keyword">return</span> arr[(tail - <span class="number">1</span> + size) % size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断满</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size==count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>在对循环队列实现的时候，注意的细节点有很多，需要做到指针循环才能达到整体的循环目的。<br>总的来说还是难度中等。</p>
]]></content>
      <categories>
        <category>Problems</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Js面向对象</title>
    <url>/2021/09/22/%E6%B5%85%E8%B0%88Js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>万事万物皆对象。这句话是我以前在学习 JAVA 时的感悟。</p>
<p>现实生活中的万事万物，都可以抽象为程序中的对象。比如人：多高，多重，性别，姓名，能吃饭，唱歌。我们都可以把他抽象为代码中的对象，该对象的属性，方法，对应了人的特征，能做什么。</p>
<h1 id="Js-面向对象"><a href="#Js-面向对象" class="headerlink" title="Js 面向对象"></a>Js 面向对象</h1><ol>
<li>JavaScript 其实支持多种编程范式的，包括<strong>函数式编程和面向对象编程</strong>：</li>
</ol>
<ul>
<li><p>JavaScript 中的对象被设计成一组属性的无序集合，像是一个哈希表，有 key 和 value 组成；</p>
</li>
<li><p>key 是一个标识符名称，value 可以是任意类型，也可以是其他对象或者函数类型； eg: name:Oliver</p>
</li>
<li><p>如果值是一个函数，那么我们可以称之为是对象的方法；</p>
</li>
</ul>
<h2 id="JS-创建对象的方式"><a href="#JS-创建对象的方式" class="headerlink" title="JS 创建对象的方式"></a>JS 创建对象的方式</h2><ul>
<li>通过 new 的方式来创建：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">obj.name = <span class="string">&#x27;Oliver&#x27;</span></span><br><span class="line">obj.age = <span class="number">21</span></span><br><span class="line">obj.height = <span class="number">1.8</span></span><br><span class="line">obj.running = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;在跑步~&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>字面量形式</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> info = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Oliver&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">  <span class="attr">height</span>: <span class="number">1.8</span>,</span><br><span class="line">  <span class="attr">eating</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;在吃东西~&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Js-属性操作"><a href="#Js-属性操作" class="headerlink" title="Js 属性操作"></a>Js 属性操作</h2><ul>
<li>常规操作</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//赋值</span></span><br><span class="line">obj.name = <span class="string">&#x27;Oliver&#x27;</span></span><br><span class="line"><span class="comment">//获取</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.name)</span><br><span class="line"><span class="comment">//遍历 打印对象中所存在的属性</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="defineProperty-方法"><a href="#defineProperty-方法" class="headerlink" title="defineProperty 方法"></a>defineProperty 方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Oliver&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">21</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性描述符是一个对象</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;height&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 很多的配置</span></span><br><span class="line">  <span class="attr">value</span>: <span class="number">1.88</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">//&#123; name: &#x27;why&#x27;, age: 18 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.height) <span class="comment">//1.88</span></span><br></pre></td></tr></table></figure>

<h1 id="对属性操作的控制"><a href="#对属性操作的控制" class="headerlink" title="对属性操作的控制"></a>对属性操作的控制</h1><p>以前在 Java 中，我们常常会用到 Private 对一些对象的属性进行限制。那 Js 中是否也存在这种操作呢？</p>
<h3 id="defineProperty-数据属性描述符"><a href="#defineProperty-数据属性描述符" class="headerlink" title="defineProperty 数据属性描述符"></a><strong>defineProperty 数据属性描述符</strong></h3><ul>
<li><p><strong>Object.defineProperty(obj,prop,descriptor)</strong> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此</p>
</li>
<li><p>可接收三个参数：</p>
<ol>
<li><p>obj 要定义属性的对象；</p>
</li>
<li><p>prop 要定义或修改的属性的名称或 Symbol；</p>
</li>
<li><p>descriptor 要定义或修改的属性描述符；</p>
</li>
</ol>
</li>
<li><p>返回值：被传递给函数的对象。</p>
</li>
</ul>
<p>对象。</p>
<ol>
<li><p> <strong>value</strong> 该属性的<strong>值</strong>； 默认值 undefined ；</p>
</li>
<li><p> <strong>configurable ** 该属性是否能</strong>修改**，配置； 默认值 false</p>
</li>
<li><p> <strong>enumerable</strong> 该属性是否能<strong>枚举</strong>； 默认值 false</p>
</li>
<li><p><strong>writable</strong> 该属性是否能<strong>赋值</strong>，<strong>写入</strong>； 默认值 false</p>
<p> <em>直接给对象的属性定义的时候，configurable，enumerable，writable 都为 true</em></p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Oliver&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">21</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;address&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&quot;四川省&quot;</span> <span class="comment">// 默认值undefined</span></span><br><span class="line">  <span class="comment">// 是否可以配置 该特殊不可删除/也不可以重新定义属性描述符</span></span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span>, <span class="comment">// 默认值false</span></span><br><span class="line">  <span class="comment">// 该特殊是配置对应的属性(address)是否是可以枚举，通过log等等方式</span></span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="comment">// 默认值false</span></span><br><span class="line">  <span class="comment">// 该特性是属性是否是可以赋值(写入值)</span></span><br><span class="line">   <span class="attr">writable</span>: <span class="literal">false</span> <span class="comment">// 默认值false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="defineProperties-数据属性描述符（多个）"><a href="#defineProperties-数据属性描述符（多个）" class="headerlink" title="defineProperties()数据属性描述符（多个）"></a><strong>defineProperties()数据属性描述符（多个）</strong></h3><ul>
<li><strong>Object.defineProperties()</strong> 方法直接在一个对象上定义 <strong>多个</strong> 新的属性或修改现有属性，并且返回该对象。</li>
</ul>
<h3 id="存储属性描述符"><a href="#存储属性描述符" class="headerlink" title="存储属性描述符"></a>存储属性描述符</h3><ul>
<li><p>存取属性描述符</p>
<ol>
<li><p>隐藏某一个私有属性被希望直接被外界使用和赋值</p>
</li>
<li><p>如果我们希望截获某一个属性它访问和设置值的过程时, 也会使用存储属性描述符</p>
</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;oliver&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">21</span>,</span><br><span class="line">  <span class="comment">//约定俗成，在变量属性前添加 _ “下划线”表示该属性为私有的，不想别人随意改变其中的内容</span></span><br><span class="line">  <span class="attr">_address</span>: <span class="string">&#x27;四川省&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;address&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// get方法获取对象中的私有属性</span></span><br><span class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._address</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//set方法来设置私有属性的值</span></span><br><span class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    bar()</span><br><span class="line">    <span class="built_in">this</span>._address = value</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.address)</span><br><span class="line"></span><br><span class="line">obj.address = <span class="string">&#x27;上海市&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.address)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;获取了一次address的值&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;设置了addres的值&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他方法补充"><a href="#其他方法补充" class="headerlink" title="其他方法补充"></a>其他方法补充</h3><p><strong>getOwnPropertyDescriptor</strong></p>
<p>可以获取对象的某一属性的属性描述符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取某一个特性属性的属性描述符</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;name&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p><strong>getOwnPropertyDescriptors</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取对象的所有属性描述符</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(obj))</span><br></pre></td></tr></table></figure>

<p><strong>preventExtensions</strong></p>
<p>禁止对象扩展新属性</p>
<ul>
<li>给一个对象添加新的属性会失败（在严格模式下会报错）；</li>
</ul>
<p><strong>seal</strong></p>
<ul>
<li><p>密封对象，不允许配置和删除属性</p>
</li>
<li><p>实际是调用<em>preventExtensions</em></p>
</li>
<li><p>并且将现有属性的<em>configurable:false</em></p>
</li>
</ul>
<p><strong>freeze</strong></p>
<ul>
<li><p>冻结对象，不允许修改现有属性：</p>
</li>
<li><p>实际上是调用<em>seal</em></p>
</li>
<li><p>并且将现有属性的<em>writable: false</em></p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Javascript 中的创建对象的思想，其实和 Java 中也算是大同小异，包括一些构造器，Js 中使用 function 来作为构造器的使用。其中的一些私有的方法在 JavaScript 中也有体现。</p>
<p>总的来说 Js 中的对象使用上更灵活，方法也更多。需要勤加使用练习。</p>
]]></content>
      <categories>
        <category>底层逻辑</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈js闭包</title>
    <url>/2021/09/05/%E6%B5%85%E8%B0%88js%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<p>最近在学习 Javascript 高级语法，研究到了一些底层逻辑，有了很多的心得体会。赶紧记录下来！</p>
<h1 id="什么是-Js-闭包？"><a href="#什么是-Js-闭包？" class="headerlink" title="什么是 Js 闭包？"></a>什么是 Js 闭包？</h1><p><img src="/2021/09/05/%E6%B5%85%E8%B0%88js%E9%97%AD%E5%8C%85/book.png" alt="描述"></p>
<h2 id="js-中函数是一等公民"><a href="#js-中函数是一等公民" class="headerlink" title="js 中函数是一等公民"></a>js 中函数是一等公民</h2><h3 id="什么是一等公民？"><a href="#什么是一等公民？" class="headerlink" title="什么是一等公民？"></a>什么是一等公民？</h3><p>就好比 java 中的对象。js 中的函数十分灵活！</p>
<ul>
<li>函数可以作为另一个函数的参数，也可以作为另一个函数的返回值来使用</li>
<li>自己可以编写高阶函数</li>
<li>可以使用内置的高阶函数</li>
</ul>
<h3 id="代码演示："><a href="#代码演示：" class="headerlink" title="代码演示："></a>代码演示：</h3><ul>
<li>函数作为一等公民，可以作为参数传入其他的函数中</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calc</span>(<span class="params">num1, num2, fnc</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(fnc(num1, num2))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line">calc(<span class="number">20</span>, <span class="number">30</span>, add)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>js 允许函数的嵌套定义</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fn = foo()</span><br><span class="line">fn()</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">makeAdder</span>(<span class="params">count</span>)</span></span><br><span class="line"><span class="function">   <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num</span>) </span>&#123;</span></span><br><span class="line"><span class="function">     <span class="title">return</span> <span class="title">count</span> + <span class="title">num</span></span></span><br><span class="line"><span class="function">   &#125;</span></span><br><span class="line"><span class="function">   <span class="title">return</span> <span class="title">add</span></span></span><br><span class="line"><span class="function"> &#125;</span></span><br><span class="line"><span class="function"> <span class="title">var</span> <span class="title">add5</span> = <span class="title">makeAdder</span>(<span class="params"><span class="number">5</span></span>)</span></span><br><span class="line"><span class="function"> <span class="title">var</span> <span class="title">add10</span> = <span class="title">makeAdder</span>(<span class="params"><span class="number">10</span></span>)</span></span><br><span class="line"><span class="function"> <span class="title">console</span>.<span class="title">log</span>(<span class="params">add5(<span class="number">10</span>)</span>)</span></span><br><span class="line"><span class="function"> <span class="title">console</span>.<span class="title">log</span>(<span class="params">add10(<span class="number">10</span>)</span>)</span></span><br></pre></td></tr></table></figure></li>
<li><p>高阶函数:把一个函数，接受另一个函数的返回值，作为参数使用，称为高阶函数。</p>
</li>
</ul>
<h2 id="js-中的闭包定义"><a href="#js-中的闭包定义" class="headerlink" title="js 中的闭包定义"></a>js 中的闭包定义</h2><h3 id="官方式定义："><a href="#官方式定义：" class="headerlink" title="官方式定义："></a>官方式定义：</h3><h4 id="在计算机科学中对闭包的定义（维基百科）："><a href="#在计算机科学中对闭包的定义（维基百科）：" class="headerlink" title="在计算机科学中对闭包的定义（维基百科）："></a>在计算机科学中对闭包的定义（维基百科）：</h4><ul>
<li><p>闭包（英语：Closure），又称<strong>词法闭包</strong>（Lexical Closure）或<strong>函数闭包</strong>（function closures）；</p>
</li>
<li><p>是在支持 <strong>头等函数</strong> 的编程语言中，实现词法绑定的一种技术；</p>
</li>
<li><p>闭包在实现上是一个结构体，它存储了一个函数和一个关联的环境（相当于一个符号查找表）；</p>
</li>
<li><p>闭包跟函数最大的区别在于，当捕捉闭包的时候，它的 <strong>自由变量</strong> 会在捕捉时被确定，这样即使脱离了捕捉时的上下文，它也能照常运行；</p>
</li>
</ul>
<h4 id="MDN-对-JavaScript-闭包的解释："><a href="#MDN-对-JavaScript-闭包的解释：" class="headerlink" title="MDN 对 JavaScript 闭包的解释："></a>MDN 对 JavaScript 闭包的解释：</h4><ul>
<li><p>一个函数和对其周围状态（<strong>lexical environment，词法环境</strong>）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是<strong>闭包</strong>（<strong>closure</strong>）；</p>
</li>
<li><p>也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域；</p>
</li>
<li><p>在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来；</p>
</li>
</ul>
<h4 id="我对-Js-闭包的理解："><a href="#我对-Js-闭包的理解：" class="headerlink" title="我对 Js 闭包的理解："></a>我对 Js 闭包的理解：</h4><ul>
<li>广义上来讲，js 中的函数都是闭包</li>
<li>狭义上来讲，js 中的一个函数，如果访问了外层作用域的变量，那它就是一个闭包。</li>
<li>闭包：函数+可以访问的自由变量</li>
</ul>
<h3 id="简单的闭包，以及逻辑："><a href="#简单的闭包，以及逻辑：" class="headerlink" title="简单的闭包，以及逻辑："></a>简单的闭包，以及逻辑：</h3><p><img src="/2021/09/05/%E6%B5%85%E8%B0%88js%E9%97%AD%E5%8C%85/1.png" alt="1"></p>
<p>简单描述逻辑：GO 对象，执行上下文调用栈 EcStack-&gt;全局执行上下文，VO：GO-&gt;解析函数，创建函数对象,上层作用域,函数执行体-&gt;函数执行上下文-&gt;执行代码-&gt;执行上下文销毁，AO 也销毁</p>
<h2 id="闭包中的问题"><a href="#闭包中的问题" class="headerlink" title="闭包中的问题"></a>闭包中的问题</h2><h3 id="闭包中的某些-AO-为什么不会被销毁？"><a href="#闭包中的某些-AO-为什么不会被销毁？" class="headerlink" title="闭包中的某些 AO 为什么不会被销毁？"></a>闭包中的某些 AO 为什么不会被销毁？</h3><p>这就涉及到 Js 的内存回收机制：垃圾回收器会定期从这个根开始，找所有从根开始有引用到的对象，对于哪些没有引用到的对象，就认为是不可用的对象；</p>
<p>我们可以参考：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name)</span><br><span class="line">    <span class="built_in">console</span>.log(age)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = foo()</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/05/%E6%B5%85%E8%B0%88js%E9%97%AD%E5%8C%85/2.png" alt="2"></p>
<p>我们对 function bar 进行研究。</p>
<ol>
<li>创建 GO 对象，包含了 fn：undefined ，foo：undefined</li>
<li>运行 foo（）</li>
<li>创建 foo 函数对象，其中包含了他作用域链，函数执行体；创建 foo AO 对象，name：undefined …，并对 bar（）进行预加载</li>
<li>执行 foo 函数，对 foo AO 进行修改。</li>
<li>创建 bar 函数对象，bar AO</li>
</ol>
<p>其中 bar 的函数对象中 父级作用域是 foo，指向 foo AO 。</p>
<ol start="6">
<li>返回 bar（）</li>
<li>fn 存储 bar 的地址</li>
<li>运行 fn（）</li>
<li>bar 开始寻找相关的 name，age，bar AO 无，则向 foo AO 中寻找。</li>
<li>找到相关数据，执行函数。</li>
</ol>
<p>由于我们可以很清楚地找到一条线：GO 的 fn（）-&gt; bar-&gt;bar AO 父级作用域指向 foo 的 AO</p>
<p>所以此时的 foo AO 不会被销毁，因为我们可以从根目录开始寻找这一条线路。</p>
<h3 id="闭包内存泄漏"><a href="#闭包内存泄漏" class="headerlink" title="闭包内存泄漏"></a>闭包内存泄漏</h3><p>由于某些 AO 一直存在，就有着内存泄漏的问题存在。</p>
<p>解决方法就直接将其指向 null</p>
<p>如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name)</span><br><span class="line">    <span class="built_in">console</span>.log(age)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = foo()</span><br><span class="line">fn()</span><br><span class="line"></span><br><span class="line">fn = <span class="literal">null</span></span><br><span class="line">foo = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>就可以解决这个问题</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JavaScript 博大精深，还需继续努力，深入研究其中的原理。冲冲冲！</p>
]]></content>
      <categories>
        <category>底层逻辑</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>通过node如何创建一个接口</title>
    <url>/2021/08/31/%E9%80%9A%E8%BF%87node%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><p>通过 node.js 环境与 Koa 框架，编写一个接口</p>
<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><ul>
<li>app 文件夹</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- index.js --&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导入Koa框架</span></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;koa-bodyparser&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> errorHandler = <span class="built_in">require</span>(<span class="string">&#x27;./error-handle&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> useRoutes = <span class="built_in">require</span>(<span class="string">&#x27;../router&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//新建Koa实例</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"></span><br><span class="line">app.use(bodyParser())</span><br><span class="line">useRoutes(app)</span><br><span class="line">app.on(<span class="string">&#x27;error&#x27;</span>, errorHandler)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = app</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>main.js 文件</li>
</ul>
<p>main.js 文件一般是程序的主要入口</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入之前创建的app实例</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">&#x27;./app&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//导入数据库相关配置</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./app/database&#x27;</span>)</span><br><span class="line"><span class="comment">//导入相关配置</span></span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&#x27;./app/config&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建启动服务器</span></span><br><span class="line">app.listen(config.APP_PORT, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`服务器在<span class="subst">$&#123;config.APP_PORT&#125;</span>端口已启动`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>router 文件夹<br>index.js 文件 主要用来配置 router（路由）相关信息</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入fs插件</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建useRoutes</span></span><br><span class="line"><span class="keyword">const</span> useRoutes = <span class="function">(<span class="params">app</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//自动生成router相关配置</span></span><br><span class="line">  fs.readdirSync(__dirname).forEach(<span class="function">(<span class="params">file</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (file === <span class="string">&#x27;index.js&#x27;</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">`./<span class="subst">$&#123;file&#125;</span>`</span>)</span><br><span class="line">    app.use(router.routes())</span><br><span class="line">    app.use(router.allowedMethods())</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = useRoutes</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>img.router.js 具体的路由文件</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入koa路由</span></span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//制定接口的路径</span></span><br><span class="line"><span class="keyword">const</span> imgRouter = <span class="keyword">new</span> Router(&#123; <span class="attr">prefix</span>: <span class="string">&#x27;/mmjd&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//导入相关方法/中间件</span></span><br><span class="line"><span class="keyword">const</span> &#123; getImgs,personType,personImgs &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../controller/img.controller&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; verifyAuth &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../middleware/auth.middleware&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册接口，并标明请求方法</span></span><br><span class="line">imgRouter.get(<span class="string">&#x27;/&#x27;</span>, getImgs)</span><br><span class="line">imgRouter.post(<span class="string">&#x27;/personimg&#x27;</span>,verifyAuth,personType,personImgs)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = imgRouter</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>其次就是在 middleware 或者 controller，service 中写具体操作了</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其中还是有很多细节的东西没有掌握好，此点需要以后继续深入研究！</p>
]]></content>
      <categories>
        <category>技术实现</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>门与墙算法的实现</title>
    <url>/2021/07/29/%E9%97%A8%E4%B8%8E%E5%A2%99%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>你被给定一个  m × n  的二维网格 rooms ，网格中有以下三种可能的初始化值：-1  表示墙或是障碍物 0  表示一扇门<br>INF  无限表示一个空的房间。然后，我们用  231 - 1 = 2147483647  代表  INF。你可以认为通往门的距离总是小于  2147483647  的。<br>你要给每个空房间位上填上该房间到   最近门的距离 ，如果无法到达门，则填  INF  即可。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/walls-and-gates">https://leetcode-cn.com/problems/walls-and-gates</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li>建立基本数据以及辅助坐标</li>
<li>先寻找门坐标，将其入队</li>
<li>取出队头元素 A 进行解析</li>
<li>分析 A 上下左右 block 是否可用 合法 A 是否未赋值</li>
<li>将合法的 block 进行赋值（步数）</li>
<li>将新的 block 入队</li>
</ol>
<h2 id="结束条件"><a href="#结束条件" class="headerlink" title="结束条件"></a>结束条件</h2><p>当取出的区域 上下左右都已经赋值 ｜｜ 为墙，为门 则无需处理，退出处理队列</p>
<h2 id="本题的突破点"><a href="#本题的突破点" class="headerlink" title="本题的突破点:"></a>本题的突破点:</h2><ol>
<li>理解队列先进先出的性质</li>
<li>广度优先搜索的性质</li>
<li>先找门，后赋值的思路</li>
</ol>
<p><em>ps：block 我的定义是 INF 即可用的房间</em></p>
<p><strong>实现难点</strong></p>
<ol>
<li>如何寻找 block 的上下左右房间</li>
<li>该房间的周围空间是否有用</li>
<li>能否联想到新的 block 就当作是一个新门，再从新门找他的上下左右 block</li>
<li>如何进行数据处理</li>
<li>细节处理</li>
</ol>
<h2 id="象形理解"><a href="#象形理解" class="headerlink" title="象形理解"></a>象形理解</h2><p>把每一个门当作一个大的问题小孩（类似孩子王），队列就是记录未解决问题小孩的清单。<br>我们把每一个 INF 区域当作一个医生，安排医生用最小的距离去解决这些问题小孩。<br>我们先在房间里寻找大问题小孩，将他们全部记录在清单上。<br>我们开始分析他周围是否也有问题小孩（孩子王的小跟班）（上下左右检查）<br>如果有（该区域为空）且该问题其他医生没有解决（未赋值）<br>我们就指派该区域的医生去解决这个问题小孩，并且记录该问题小孩离孩子王有多远。（为 block 赋值）<br>如果周围的问题小孩已经有医生解决了，我们就不管。<br>将新的问题小孩记录在队列上，原先的孩子王的下线已经全盘供出，所以他从问题清单上划除。<br>继续解决清单上的新的问题小孩….<br>（可能有点不怎么容易理解。。。。我真的尽力了 源码 yyds ）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="comment">//定义空房间的特征值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INF = <span class="number">2147483647</span>;</span><br><span class="line">    <span class="comment">//定义门的特殊值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DOOR = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//定义辅助坐标 以此来表示房间的上下左右</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;<span class="keyword">int</span>[]&gt; DIRECTIONS = Arrays.<span class="built_in">asList</span>(</span><br><span class="line">            <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wallsAndGates</span><span class="params">(<span class="keyword">int</span>[][] rooms)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//记录房间的长宽</span></span><br><span class="line">        <span class="keyword">int</span> m= rooms.length;</span><br><span class="line">        <span class="keyword">int</span> n=rooms[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建队列</span></span><br><span class="line">        Queue&lt;<span class="keyword">int</span> []&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历rooms 寻找所有的门</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; m; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">                <span class="comment">//当检测到该地区为门的时候 将门的坐标元素入队</span></span><br><span class="line">                <span class="keyword">if</span>(rooms[row][col]==DOOR)&#123;</span><br><span class="line">                    queue.<span class="built_in">add</span>(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;row,col&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//核心区域 （当队列不为空的时候，继续执行）</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">            <span class="comment">//取出队头的元素 也是最先入队的元素 （   d,c,b,a   =&gt; a)</span></span><br><span class="line">            <span class="keyword">int</span>[] block = queue.<span class="built_in">poll</span>();</span><br><span class="line">            <span class="comment">//记录原生的行，列数据</span></span><br><span class="line">            <span class="keyword">int</span> row=block[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> col=block[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//制造当前block的上下左右block 利用辅助坐标快速制作出新的坐标数据</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> [] direction:</span><br><span class="line">                 DIRECTIONS) &#123;</span><br><span class="line">               <span class="keyword">int</span> r=row+direction[<span class="number">0</span>];</span><br><span class="line">               <span class="keyword">int</span> c=col+direction[<span class="number">1</span>];</span><br><span class="line">               <span class="comment">//判断新的坐标是否合法 是否存在障碍物            ！！（重点！）是否之前已经被被赋值过！！</span></span><br><span class="line">                <span class="comment">//如果已经被赋值 说明当前值就是该区域的最短路径，再次改变就是不准确值</span></span><br><span class="line">                <span class="comment">// 因为是广度优先 所以当前值一定是最优值</span></span><br><span class="line">               <span class="keyword">if</span>(r&lt;<span class="number">0</span> || c&lt;<span class="number">0</span> || r&gt;=rooms.length || c&gt;=rooms[<span class="number">0</span>].length || rooms[r][c]!=INF)&#123;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//细节点  需要在前一个block的值上进行+1 否则步数全为1</span></span><br><span class="line">               rooms[r][c]=rooms[row][col]+<span class="number">1</span>;</span><br><span class="line">               <span class="comment">//如果都不是 则为全新的为赋值block 将其加入队列（列尾）</span></span><br><span class="line">                queue.<span class="built_in">add</span>(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r,c&#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Problems</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
</search>
