{"meta":{"title":"Oliver-xuan","subtitle":"记录我的程序员生涯","description":"","author":"Oliverxuan","url":"http://oliverxuan.github.io","root":"/"},"pages":[{"title":"分类","date":"2021-07-29T16:58:11.125Z","updated":"2021-07-29T16:58:11.125Z","comments":true,"path":"categories/index.html","permalink":"http://oliverxuan.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-07-29T16:57:59.520Z","updated":"2021-07-29T16:57:59.520Z","comments":true,"path":"tags/index.html","permalink":"http://oliverxuan.github.io/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-07-29T16:58:19.069Z","updated":"2021-07-29T16:58:19.069Z","comments":true,"path":"about/index.html","permalink":"http://oliverxuan.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Js中call,apply,bind的实现","slug":"Js中call-apply-bind的实现","date":"2021-09-12T08:42:43.000Z","updated":"2021-09-12T13:59:59.845Z","comments":true,"path":"2021/09/12/Js中call-apply-bind的实现/","link":"","permalink":"http://oliverxuan.github.io/2021/09/12/Js%E4%B8%ADcall-apply-bind%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"在 Js 中，我们常常会用到 call，apply，bind。进行一些 this 操作。我们不禁对其产生了好奇。 Js 中，这些方法是通过 C++实现的，那么我们尝试用 Js 来实现一下。 call 将手写的 mycall 方法，绑定在函数原型上。 实现所有函数都可以通过 foo（）.mycall 的方式调用。 12//Function.prototype :函数原型Function.prototype.mycall = function() 拿到调用 mycall（）的对象。 12//不难发现，此处是一个隐式绑定，函数foo（）.mycall。我们可以通过this拿到目标函数var fn = this 目前，我们完成了最基本的通过 mycall 执行函数体的方法。 12345678910Function.prototype.mycall = function () &#123; var fn = this fn()&#125;function foo() &#123; console.log(&#x27;foo函数被调用&#x27;)&#125;foo.mycall() //foo函数被调用","text":"在 Js 中，我们常常会用到 call，apply，bind。进行一些 this 操作。我们不禁对其产生了好奇。 Js 中，这些方法是通过 C++实现的，那么我们尝试用 Js 来实现一下。 call 将手写的 mycall 方法，绑定在函数原型上。 实现所有函数都可以通过 foo（）.mycall 的方式调用。 12//Function.prototype :函数原型Function.prototype.mycall = function() 拿到调用 mycall（）的对象。 12//不难发现，此处是一个隐式绑定，函数foo（）.mycall。我们可以通过this拿到目标函数var fn = this 目前，我们完成了最基本的通过 mycall 执行函数体的方法。 12345678910Function.prototype.mycall = function () &#123; var fn = this fn()&#125;function foo() &#123; console.log(&#x27;foo函数被调用&#x27;)&#125;foo.mycall() //foo函数被调用 实现函数可传入指定的 this 我们知道在 js 的 call（）中，是可以转入指定的对象，用该对象进行函数的调用。 但是也有一些特殊的情况。 undefined，null。传入该值后，实际上 this 是 window。 传入数字，字符串。实际上是 number/String 对象 我们针对这些特性，进行函数优化。 这里使用到： Object（）：_将传入的值变成对象类型_； 三元运算符：_判断是否为特殊情况_。 1234567891011121314151617181920212223//修改函数体，传入指定的Function.prototype.mycall = function (thisArg) &#123; var fn = this //对传入的thisArg进行判断，是否为null，undefined，如果是：window，不是 Object(thisArg)。 thisArg = thisArg !== null &amp;&amp; thisArg !== undefined ? Object(thisArg) : window //保存原this thisArg.fn = fn //执行原函数体，并保存结果 var result = thisArg.fn() //防止作用域污染，及时删除 delete thisArg.fn //返回执行结果 return result&#125;function foo() &#123; console.log(&#x27;foo函数被调用&#x27;) console.log(this)&#125;foo.mycall(&#x27;abc&#x27;) //String&#123;&#x27;abc&#x27;&#125;foo.mycall() //window 实现函数可传入参数 在这里，我们用到了…args （展开运算符），实现可传入未知个数的参数 1234567891011121314151617181920212223242526272829//...args 用于传入未知个数的参数Function.prototype.mycall = function (thisArg, ...args) &#123; var fn = this thisArg = thisArg !== null &amp;&amp; thisArg !== undefined ? Object(thisArg) : window thisArg.fn = fn //将参数传入执行函数中 var result = thisArg.fn(...args) delete thisArg.fn return result&#125;function foo() &#123; console.log(&#x27;foo函数被调用&#x27;) console.log(this)&#125;function sum(num1, num2) &#123; console.log(&#x27;sum函数被执行&#x27;, this, num1, num2) return num1 + num2&#125;var name = &#x27;window&#x27;// foo.call(&#x27;abc&#x27;)// foo.mycall(&#x27;abc&#x27;)// foo.call()// foo.mycall()console.log(sum.mycall(&#123;&#125;, 1, 2)) //sum函数被执行 &#123;fn: ƒ&#125;[[Prototype]]: Object 1 2 3 目前我们己完成了 mycall（）的手写。 apply 基础部分 此部分和 call 基本一致。 123456789Function.prototype.myapply = function (thisArgs) &#123; var fn = this thisArgs = thisArgs !== null &amp;&amp; thisArs !== undefined ? Object(thisArgs) : window thisArgs.fn = fn var result = thisArgs.fn() delete thisArgs.fn return result&#125; apply 传参处理 12345678910111213141516171819//apple传参是数组类型，所以我们这里只需要传入目标数组就行Function.prototype.myapply = function (thisArgs, array) &#123; var fn = this thisArgs = thisArgs !== null &amp;&amp; thisArgs !== undefined ? Object(thisArgs) : window thisArgs.fn = fn //array = array ? array: [] array = array || [] var result = thisArgs.fn(...array) delete thisArgs.fn return result&#125;function sum(num1, num2) &#123; console.log(&#x27;sum函数被执行&#x27;, this, num1, num2) return num1 + num2&#125;console.log(sum.myapply(&#123;&#125;, [1, 2])) //sum函数被执行 &#123;fn: ƒ&#125; 1 2 3 bind 基础部分 基础部分和前文一致 1234Function.prototype.mybind = function (thisArg) &#123; var fn = this thisArg = thisArg !== null &amp;&amp; thisArg !== undefined ? Object(thisArg) : window&#125; 传参处理 由于 bind 的特殊用法，我们可以在 bind（）里传入参数，也可以在新的函数中传入参数，或者都传入参数，所以我们需要特殊处理。 123456789101112131415161718192021222324252627Function.prototype.mybind = function (thisArg, ...myargs) &#123; var fn = this thisArg = thisArg !== null &amp;&amp; thisArg !== undefined ? Object(thisArg) : window //设立一个代理函数 function pxfn(...arg) &#123; thisArg.fn = fn //合并参数 var finalArray = [...myargs, ...arg] //执行函数体 var result = thisArg.fn(...finalArray) delete thisArg.fn //返回执行结果 return result &#125; //返回pxfn函数 return pxfn&#125;function sum(num1, num2, num3, num4) &#123; console.log(num1, num2, num3, num4)&#125;var bar = foo.mybind(&#x27;123&#x27;)bar() //foo被执行 String &#123;&#x27;123&#x27;, fn: ƒ&#125;var bar2 = sum.mybind(&#x27;1234&#x27;, 1, 2, 3, 4)bar2() //1 2 3 4 总结通过这次手写 Js 中的一些重要方法，我理解到 this 在实际开发的重要性，也学会了，如何处理数据，以及一些边界情况的处理。总的来说，这是一次很好的学习经验。","categories":[{"name":"底层逻辑","slug":"底层逻辑","permalink":"http://oliverxuan.github.io/categories/%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://oliverxuan.github.io/tags/JavaScript/"}]},{"title":"Js中的this练习题","slug":"Js中的this练习题","date":"2021-09-09T07:05:22.000Z","updated":"2021-09-09T08:05:03.446Z","comments":true,"path":"2021/09/09/Js中的this练习题/","link":"","permalink":"http://oliverxuan.github.io/2021/09/09/Js%E4%B8%AD%E7%9A%84this%E7%BB%83%E4%B9%A0%E9%A2%98/","excerpt":"习题：练习题 1:12345678910111213141516var name = &#x27;window&#x27;var person = &#123; name: &#x27;person&#x27;, sayName: function () &#123; console.log(this.name) &#125;,&#125;function sayName() &#123; var sss = person.sayName sss() person.sayName() person.sayName() ;(b = person.sayName)()&#125; 练习题 2:1234567891011121314151617181920212223242526272829303132333435var name = &#x27;window&#x27;var person1 = &#123; name: &#x27;person1&#x27;, foo1: function () &#123; console.log(this.name) &#125;, foo2: () =&gt; console.log(this.name), foo3: function () &#123; return function () &#123; console.log(this.name) &#125; &#125;, foo4: function () &#123; return () =&gt; &#123; console.log(this.name) &#125; &#125;,&#125;var person2 = &#123; name: &#x27;person2&#x27; &#125;person1.foo1()person1.foo1.call(person2)person1.foo2()person1.foo2.call(person2)person1.foo3()()person1.foo3.call(person2)()person1.foo3().call(person2)person1.foo4()()person1.foo4.call(person2)()person1.foo4().call(person2) 练习题 3:123456789101112131415161718192021222324252627282930313233343536var name = &#x27;window&#x27;function Person(name) &#123; this.name = name ;(this.foo1 = function () &#123; console.log(this.name) &#125;), (this.foo2 = () =&gt; console.log(this.name)), (this.foo3 = function () &#123; return function () &#123; console.log(this.name) &#125; &#125;), (this.foo4 = function () &#123; return () =&gt; &#123; console.log(this.name) &#125; &#125;)&#125;var person1 = new Person(&#x27;person1&#x27;)var person2 = new Person(&#x27;person2&#x27;)person1.foo1()person1.foo1.call(person2)person1.foo2()person1.foo2.call(person2)person1.foo3()()person1.foo3.call(person2)()person1.foo3().call(person2)person1.foo4()()person1.foo4.call(person2)()person1.foo4().call(person2) 练习题 4:12345678910111213141516171819202122232425262728293031323334353637var name = &#x27;window&#x27;function Person(name) &#123; this.name = name this.obj = &#123; name: &#x27;obj&#x27;, foo1: function () &#123; return function () &#123; console.log(this.name) &#125; &#125;, foo2: function () &#123; return () =&gt; &#123; console.log(this.name) &#125; &#125;, &#125;&#125;var person1 = new Person(&#x27;person1&#x27;)var person2 = new Person(&#x27;person2&#x27;)person1.obj.foo1()()person1.obj.foo1.call(person2)()person1.obj.foo1().call(person2)person1.obj.foo2()()person1.obj.foo2.call(person2)()person1.obj.foo2().call(person2)//上层作用域的理解var obj = &#123; name: &#x27;obj&#x27;, foo: function () &#123; // 上层作用域是全局 &#125;,&#125; 习题题解：","text":"习题：练习题 1:12345678910111213141516var name = &#x27;window&#x27;var person = &#123; name: &#x27;person&#x27;, sayName: function () &#123; console.log(this.name) &#125;,&#125;function sayName() &#123; var sss = person.sayName sss() person.sayName() person.sayName() ;(b = person.sayName)()&#125; 练习题 2:1234567891011121314151617181920212223242526272829303132333435var name = &#x27;window&#x27;var person1 = &#123; name: &#x27;person1&#x27;, foo1: function () &#123; console.log(this.name) &#125;, foo2: () =&gt; console.log(this.name), foo3: function () &#123; return function () &#123; console.log(this.name) &#125; &#125;, foo4: function () &#123; return () =&gt; &#123; console.log(this.name) &#125; &#125;,&#125;var person2 = &#123; name: &#x27;person2&#x27; &#125;person1.foo1()person1.foo1.call(person2)person1.foo2()person1.foo2.call(person2)person1.foo3()()person1.foo3.call(person2)()person1.foo3().call(person2)person1.foo4()()person1.foo4.call(person2)()person1.foo4().call(person2) 练习题 3:123456789101112131415161718192021222324252627282930313233343536var name = &#x27;window&#x27;function Person(name) &#123; this.name = name ;(this.foo1 = function () &#123; console.log(this.name) &#125;), (this.foo2 = () =&gt; console.log(this.name)), (this.foo3 = function () &#123; return function () &#123; console.log(this.name) &#125; &#125;), (this.foo4 = function () &#123; return () =&gt; &#123; console.log(this.name) &#125; &#125;)&#125;var person1 = new Person(&#x27;person1&#x27;)var person2 = new Person(&#x27;person2&#x27;)person1.foo1()person1.foo1.call(person2)person1.foo2()person1.foo2.call(person2)person1.foo3()()person1.foo3.call(person2)()person1.foo3().call(person2)person1.foo4()()person1.foo4.call(person2)()person1.foo4().call(person2) 练习题 4:12345678910111213141516171819202122232425262728293031323334353637var name = &#x27;window&#x27;function Person(name) &#123; this.name = name this.obj = &#123; name: &#x27;obj&#x27;, foo1: function () &#123; return function () &#123; console.log(this.name) &#125; &#125;, foo2: function () &#123; return () =&gt; &#123; console.log(this.name) &#125; &#125;, &#125;&#125;var person1 = new Person(&#x27;person1&#x27;)var person2 = new Person(&#x27;person2&#x27;)person1.obj.foo1()()person1.obj.foo1.call(person2)()person1.obj.foo1().call(person2)person1.obj.foo2()()person1.obj.foo2.call(person2)()person1.obj.foo2().call(person2)//上层作用域的理解var obj = &#123; name: &#x27;obj&#x27;, foo: function () &#123; // 上层作用域是全局 &#125;,&#125; 习题题解：练习题 1:12345678910111213141516171819var name = &#x27;window&#x27;var person = &#123; name: &#x27;person&#x27;, sayName: function () &#123; console.log(this.name) &#125;,&#125;function sayName() &#123; var sss = person.sayName sss() //window 默认绑定，独立函数调用 person.sayName() //person 隐式绑定，通过person调用sayName（） person.sayName() //person 隐式绑定，通过person调用sayName（）， //实质上（）没有用，本身就是一个整体，只是用来混淆视听。 ;(b = person.sayName)() //window 默认绑定，独立函数调用，b接收了sayName（）后被独立调用&#125; 练习题 2:123456789101112131415161718192021222324252627282930313233343536373839404142434445var name = &#x27;window&#x27;var person1 = &#123; name: &#x27;person1&#x27;, foo1: function () &#123; console.log(this.name) &#125;, foo2: () =&gt; console.log(this.name), foo3: function () &#123; return function () &#123; console.log(this.name) &#125; &#125;, foo4: function () &#123; return () =&gt; &#123; console.log(this.name) &#125; &#125;,&#125;var person2 = &#123; name: &#x27;person2&#x27; &#125;person1.foo1() //person1 隐式绑定，通过person1来调用函数person1.foo1.call(person2) //person2 显式绑定，首先拿到了foo1的函数体，再通过call方法调用， //其中指定绑定了this为person2person1.foo2() //window 默认绑定，由于foo2是箭头函数，箭头函数不接受this对象，向上层寻找，上层是对象。//由于对象没有this指定，则它的this就指向了全局person1.foo2.call(person2) //window 默认绑定，拿到foo2后通过call（）调用，但是箭头函数不接受this对象，故为windowperson1.foo3()() //window 独立函数调用，通过person1拿到foo3函数体后，函数再执行。相当于是函数的独立调用person1.foo3.call(person2)() //person2 首先拿到了foo3函数，通过call我们拿到了return 的函数 再执行，相当于独立调用。person1.foo3().call(person2) //person2 显式绑定，通过foo3（）拿到了return函数，再通过call绑定了this运行。person1.foo4()() //person1 隐式绑定，首先foo4（）拿到了箭头函数，（）再执行，箭头函数中没有this指定//向上查找，由于上层为foo4（）foo4是由person1 调用执行的，故为隐式绑定person1.foo4.call(person2)() //person2 首先拿到了foo4 对其进行call绑定，foo4的作用域中this指向了person2//然后箭头函数向上查找，foo4的this以及变成了person2person1.foo4().call(person2) //person1 首先拿到了箭头函数，由于箭头函数不传值，直接调用，向上查找foo4的作用域//中this的指向，为person1 练习题 3:123456789101112131415161718192021222324252627282930313233343536var name = &#x27;window&#x27;function Person(name) &#123; this.name = name ;(this.foo1 = function () &#123; console.log(this.name) &#125;), (this.foo2 = () =&gt; console.log(this.name)), (this.foo3 = function () &#123; return function () &#123; console.log(this.name) &#125; &#125;), (this.foo4 = function () &#123; return () =&gt; &#123; console.log(this.name) &#125; &#125;)&#125;var person1 = new Person(&#x27;person1&#x27;)var person2 = new Person(&#x27;person2&#x27;)person1.foo1() //perosn1person1.foo1.call(person2) //perosn2 显式绑定person1.foo2() //person1 上级作用域中this指向的是person1person1.foo2.call(person2) //person1 call并不会改变箭头函数的this指向，上级作用域中this指向的是person1person1.foo3()() //window 独立函数调用person1.foo3.call(person2)() //window 独立函数调用person1.foo3().call(person2) //person2 显示绑定person1.foo4()() //perosn1 隐式绑定，拿到了箭头函数，再（），箭头函数向上查找，上级作用域this为perosn1person1.foo4.call(person2)() //perosn2 首先改变了foo4的this为perosn2，当箭头函数找的时候上级作用域已改变person1.foo4().call(person2) //perosn1 call无法改变箭头函数的this绑定值，箭头函数向上查找，为perosn1 练习题 4:123456789101112131415161718192021222324252627282930313233343536373839var name = &#x27;window&#x27;function Person(name) &#123; this.name = name this.obj = &#123; name: &#x27;obj&#x27;, foo1: function () &#123; return function () &#123; console.log(this.name) &#125; &#125;, foo2: function () &#123; return () =&gt; &#123; console.log(this.name) &#125; &#125;, &#125;&#125;var person1 = new Person(&#x27;person1&#x27;)var person2 = new Person(&#x27;person2&#x27;)person1.obj.foo1()() //window 独立函数调用person1.obj.foo1.call(person2)() //window 独立函数调用person1.obj.foo1().call(person2) //perosn2 显示绑定了person2person1.obj.foo2()() //obj，首先，我们foo2（），拿到了箭头函数，箭头函数向上查找，foo2是通过obj进行调用的//所以foo2的作用域中this为objperson1.obj.foo2.call(person2)() //perosn2 foo2的this通过call改变了，所以，箭头函数向上查找this时时person2person1.obj.foo2().call(person2) //obj call无法改变箭头函数的this//上层作用域的理解var obj = &#123; name: &#x27;obj&#x27;, foo: function () &#123; // 上层作用域是全局 &#125;,&#125; 总结首先感谢 coderwhy 老师提供的练习题与讲解，本文中的题解为个人理解，仅供参考。 关于箭头函数，不要忘记向上查找的规则 关于最后的（）要分析好是否为函数的独立调用 箭头函数向上查找的时候需要判断上层作用域到底是哪一个","categories":[{"name":"练习题","slug":"练习题","permalink":"http://oliverxuan.github.io/categories/%E7%BB%83%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://oliverxuan.github.io/tags/JavaScript/"}]},{"title":"Js中的This指向","slug":"Js中的This指向","date":"2021-09-08T03:02:23.000Z","updated":"2021-09-09T07:04:09.709Z","comments":true,"path":"2021/09/08/Js中的This指向/","link":"","permalink":"http://oliverxuan.github.io/2021/09/08/Js%E4%B8%AD%E7%9A%84This%E6%8C%87%E5%90%91/","excerpt":"Js 中什么是 This？为什么需要 this?在 Java 中 this 常用在关于类的操作中，我们常常可以用 this.的方式调用类的属性，方法。 相对于 Java。 Js 中的 this 用法可比 Java 中更灵活。 正也是因为灵活，让 Js 中的 this 常常让人摸不清头脑。 在 Js 中我们可以通过 this 方法，在不同的情况下，拿到不同的对象。有可能是全局对象(window)，也有可能是一个 Obj 对象,或者我们可以直接给我们的 this 指定绑定上一个对象。 this 指向什么呢？ 在全局的情况下，this 指向 window 1234console.log(this) //windowvar name = &#x27;Oliver&#x27;console.log(this.name) //oliverconsole.log(window.name) //oliver 但是，开发中很少直接在全局作用域下去使用 this，通常都是在函数中使用。 所有的函数在被调用时，都会创建一个执行上下文： 这个上下文中记录着函数的调用栈、AO 对象等； this 也是其中的一条记录； 我们先来看一个让人困惑的问题： 定义一个函数，我们采用三种不同的方式对它进行调用，它产生了三种不同的结果","text":"Js 中什么是 This？为什么需要 this?在 Java 中 this 常用在关于类的操作中，我们常常可以用 this.的方式调用类的属性，方法。 相对于 Java。 Js 中的 this 用法可比 Java 中更灵活。 正也是因为灵活，让 Js 中的 this 常常让人摸不清头脑。 在 Js 中我们可以通过 this 方法，在不同的情况下，拿到不同的对象。有可能是全局对象(window)，也有可能是一个 Obj 对象,或者我们可以直接给我们的 this 指定绑定上一个对象。 this 指向什么呢？ 在全局的情况下，this 指向 window 1234console.log(this) //windowvar name = &#x27;Oliver&#x27;console.log(this.name) //oliverconsole.log(window.name) //oliver 但是，开发中很少直接在全局作用域下去使用 this，通常都是在函数中使用。 所有的函数在被调用时，都会创建一个执行上下文： 这个上下文中记录着函数的调用栈、AO 对象等； this 也是其中的一条记录； 我们先来看一个让人困惑的问题： 定义一个函数，我们采用三种不同的方式对它进行调用，它产生了三种不同的结果 12345678910111213function foo() &#123; console.log(this)&#125;foo() //window 默认绑定var obj = &#123; name: &#x27;obj&#x27;, foo: foo,&#125;obj.foo() //obj对象 隐式绑定foo.apply(&#x27;abc&#x27;) //abc 显式绑定 这个的案例可以给我们什么样的启示呢？ 函数在调用时，JavaScript 会默认给 this 绑定一个值； this 的绑定和定义的位置（编写的位置）没有关系； this 的绑定和调用方式以及调用的位置有关系； this 是在运行时被绑定的； 重要结论： this 的指向，和它所处的位置无关和调用位置有关！ this 在被调用运行的时候，才会给他 this 绑定一个值！ this 绑定规则：绑定一：默认绑定绑定二：隐式绑定绑定三：显示绑定绑定四：new 绑定规则一：默认绑定什么情况下使用默认绑定呢？独立的函数调用 我们可以理解成函数没有被绑定到某个对象上进行调用 下面是一些默认绑定演示： 12345678910111213141516171819202122232425262728293031323334353637383940//1. windowfunction foo() &#123; console.log(this)&#125;foo()//2. windowfunction foo1() &#123; console.log(this)&#125;function foo2() &#123; console.log(this) foo1()&#125;function foo3() &#123; console.log(this) foo2()&#125;foo3()//3. windowvar obj = &#123; name: &#x27;obj&#x27;, foo: function () &#123; console.log(this) &#125;,&#125;var bar = obj.foo //将该对象中的方法传递给了bar 那么其实bar就是一个单独调用bar()//5. windowfunction foo() &#123; function bar() &#123; console.log(this) &#125; return bar&#125;var fn = foo() //实质上就是在调用bar 然后将bar传递给了fnfn() 默认绑定，独立函数调用 规则二：隐式绑定另外一种比较常见的调用方式是通过某个对象进行调用的： 也就是它的调用位置中，是通过某个对象发起的函数调用。 123456789101112function foo() &#123; console.log(this)&#125;var obj = &#123; name: &#x27;obj&#x27;, age: 19, fn: foo,&#125;//使用对象调用的方式来执行函数。obj.fn() //在对象里，将foo函数传递给了fn 实质上就是通过obj在调用 隐式绑定有前提条件： 必须在调用的对象内部有一个对函数的引用（比如一个属性）； 如果没有这样的引用，在进行调用时，会报找不到该函数的错误； 正是通过这个引用，间接的将this 绑定到了这个对象上； 规则三：显示绑定如果我们不希望在 对象内部 包含这个函数的引用，同时又希望在这个对象上进行强制调用，该怎么做呢？ JavaScript 所有的函数都可以使用call 和 apply 方法（这个和 Prototype 有关）。 其实非常简单，第一个参数是相同的，后面的参数，apply 为数组，call 为参数列表； 这两个函数的第一个参数都要求是一个对象，这个对象的作用是什么呢？就是给 this 准备的。 在调用这个函数时，会将 this 绑定到这个传入的对象上。 因为上面的过程，我们明确的绑定了 this 指向的对象，所以称之为 显示绑定。 通过 call 或者 apply 绑定 this 对象 call（ ）绑定，其第一参数为指定的 this 绑定对象，第二，三，N，参数为将要传入的参数 1234567function foo(num1, num2, num3) &#123; console.log(this) console.log(num1, num2, num3)&#125;foo.call(&#x27;call&#x27;, 1, 2, 3) //[String: &#x27;call&#x27;] 1 2 3foo.call(&#123; name: &#x27;yzx&#x27; &#125;) //&#123; name: &#x27;yzx&#x27; &#125; apply（ ）绑定，其第一参数为指定 this 绑定对象，第二参数为一个数组，其中包含了将要传入的参数 1234567function foo(num1, num2, num3) &#123; console.log(this) console.log(num1, num2, num3)&#125;foo.apply(&#x27;apply&#x27;, [1, 2, 3]) //[String: &#x27;apply&#x27;] 1 2 3foo.apply(&#123; name: &#x27;yzx&#x27;, age: 18 &#125;) //&#123; name: &#x27;yzx&#x27;, age: 18 &#125; 通过 bind 方法实现显示绑定 我们可以通过.bind 方法实现显示绑定 12345678910111213function foo() &#123; name: &#x27;foo&#x27;, console.log(this)&#125;var obj = &#123; name: &#x27;obj&#x27;, fn: foo,&#125;foo() //windowobj.fn() //objvar fn = obj.fn.bind(&#123; name: &#x27;Bind&#x27; &#125;)fn() //Bind 规则四：new 绑定JavaScript 中的函数可以当做一个类的构造函数来使用，也就是使用 new 关键字。 使用 new 关键字来调用函数是，会执行如下的操作： 创建一个全新的对象； 这个新对象会被执行 prototype 连接； 这个新对象会绑定到函数调用的 this 上（this 的绑定在这个步骤完成）； 如果函数没有返回其他对象，表达式会返回这个新对象； 1234567function Person(name) &#123; console.log(this) //Person&#123;&#125; this.name = name //Person&#123;name:Oliverxuan&#125;&#125;var p = new Person(&#x27;Oliverxuan&#x27;)console.log(p) 内置函数 this 绑定setTimeout（）1234//1. setTimeoutsetTimeout(function () &#123; console.log(this) //window&#125;, 2000) 监听点击1234const boxDiv = document.querySelector(&#x27;box&#x27;)boxDiv.onclick = function () &#123; console.log(this) //boxDiv&#123;&#125;&#125; 数组：filter/map/forEach 等高阶函数12345678910var names = [&#x27;abc&#x27;, &#x27;cba&#x27;]names.forEach(function (item) &#123; console.log(item, this) //abc&#123;&#125;&#125;, &#x27;abc&#x27;) //此处进行了this绑定var names = [&#x27;abc&#x27;, &#x27;cba&#x27;]names.forEach(function (item) &#123; console.log(item, this) // window&#125;) //此处没有进行this的绑定 规则优先级基本规则学习了四条规则，接下来开发中我们只需要去查找函数的调用应用了哪条规则即可，但是如果一个函数调用位置应用了多条规则，优先级谁更高呢？ 1. 默认规则的优先级最低 毫无疑问，默认规则的优先级是最低的，因为存在其他规则时，就会通过其他规则的方式来绑定 this 2. 显示绑定优先级高于默认绑定 代码测试： 12345678var obj = &#123; name: &#x27;obj&#x27;, foo: function () &#123; console.log(this) &#125;,&#125;obj.foo() // name:&#123; name: &#x27;obj&#x27;, foo: [Function: foo] &#125; 3 .显示绑定优先级高于隐式绑定 代码测试： 12345678910111213var obj = &#123; name: &#x27;obj&#x27;, foo: function () &#123; console.log(this) &#125;,&#125;obj.foo.call(&#x27;abc&#x27;) //[String: &#x27;abc&#x27;]obj.foo.apply(&#x27;abc&#x27;) //[String: &#x27;abc&#x27;]function foo() &#123; console.log(this)&#125; 4. bind 的优先级，高于隐式绑定 代码测试： 123456var obj = &#123; name: &#x27;obj&#x27;, foo: foo.bind(&#x27;aaa&#x27;),&#125;obj.foo() //[String: &#x27;aaa&#x27;] 6. new 绑定优先级高于显示绑定 new 绑定和call、apply 是不允许同时使用的，所以不存在谁的优先级更高 new 绑定可以和 bind 一起使用，new 绑定优先级更高 代码测试： 12345678var obj = &#123; name: &#x27;obj&#x27;, foo: function () &#123; console.log(this) &#125;,&#125;var f = new obj.foo() //foo&#123;&#125; 7. 小小总结 bind 优先级比较高 new &gt; 显示 &gt; 隐式 &gt; 默认绑定（独立函数调用） 规则之外常规情况 忽略显示绑定 12345678910111213function foo() &#123; console.log(this)&#125;foo.apply(&#x27;abc&#x27;)foo.apply(&#123;&#125;)foo.apply(null) //window 全局对象foo.apply(undefined) //window 全局对象foo.bind(null) //window 全局对象foo.bind(undefined) //window 全局对象var bar = foo.bind(null)bar() 间接函数引用 1234567891011121314151617181920212223242526272829var obj = &#123; name: &#x27;obj&#x27;, foo: function () &#123; console.log(this) &#125;,&#125;var obj2 = &#123; name: &#x27;obj2&#x27;,&#125;obj2.bar = obj.fooobj2.bar() //&#123; name: &#x27;obj2&#x27;, bar: [Function: foo] &#125;var obj = &#123; name: &#x27;obj&#x27;, foo: function () &#123; console.log(this) &#125;,&#125;var obj2 = &#123; name: &#x27;obj2&#x27;,&#125;obj2.bar = obj.fooobj2.bar()( //&#123; name: &#x27;obj2&#x27;, bar: [Function: foo] &#125; (obj2.bar = obj.foo))() // 没有 分号（；）无法运行 与上面的代码看成整体;(obj2.bar = obj.foo)() // 有 分号（；）window 独立调用 箭头函数特性： 箭头函数中 是不会绑定 this/arguments 属性 箭头函数不能作为函数构造器使用 四大规则 对箭头函数不适用 简写： 如果参数只有一个 小括号可以省略 123nums.forEach((item) =&gt; &#123; console.log(item)&#125;) 如果函数的函数执行体只有一行代码，大括号也可以省略 1234nums.forEach((item) =&gt; console.log(item))// 并且会默认地将代码的执行结果作为返回值var num = nums.filter((item) =&gt; item % 2 == 0)console.log(num) 如果一个箭头函数它的返回值，只有一行代码，且只返回一个对象 如果想简写 返回对象 需要在外层套一个（）以示整体 1var bar = () =&gt; (&#123; name: &#x27;oliver&#x27;, age: 12 &#125;) 总结JS 中的 this 十分灵活，需要结合各种情况进行分析。但是万变不离其宗。掌握特性，方可以一眼看穿真相！ JS 的优点是灵活，缺点也是灵活。想要真正掌握 JS 中的晦涩语法。还需要继续修炼内功 感谢 coderwhy 老师的课程以及公众号，能够让我细节地，全面地学习 JS","categories":[{"name":"底层逻辑","slug":"底层逻辑","permalink":"http://oliverxuan.github.io/categories/%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://oliverxuan.github.io/tags/JavaScript/"}]},{"title":"Js常用数组高阶函数","slug":"Js中的高阶函数","date":"2021-09-06T04:54:54.000Z","updated":"2021-09-08T08:16:24.023Z","comments":true,"path":"2021/09/06/Js中的高阶函数/","link":"","permalink":"http://oliverxuan.github.io/2021/09/06/Js%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/","excerpt":"js 中有很多高阶函数，能在日常的代码编写工作中提高效率。下面列举一些常用 js 的数组高阶函数 FOO 数组1var nums = [10, 5, 11, 100, 55] filter: 过滤返回布尔类型 可以传递三个值 item 当前的的元素，index 当前数组下标， arr 当前整个数组 12345//数组取偶操作var numbers = nums.filter((item, index, arr) =&gt; &#123; return item % 2 == 0&#125;)console.log(numbers) map: 映射对所有的 item 进行操作 12345//对每个item进行*10操作var nums2 = nums.map((item) =&gt; &#123; return item * 10&#125;)console.log(nums2) forEach: 迭代","text":"js 中有很多高阶函数，能在日常的代码编写工作中提高效率。下面列举一些常用 js 的数组高阶函数 FOO 数组1var nums = [10, 5, 11, 100, 55] filter: 过滤返回布尔类型 可以传递三个值 item 当前的的元素，index 当前数组下标， arr 当前整个数组 12345//数组取偶操作var numbers = nums.filter((item, index, arr) =&gt; &#123; return item % 2 == 0&#125;)console.log(numbers) map: 映射对所有的 item 进行操作 12345//对每个item进行*10操作var nums2 = nums.map((item) =&gt; &#123; return item * 10&#125;)console.log(nums2) forEach: 迭代无返回值 1234//遍历数组，无返回值！nums.forEach((item) =&gt; &#123; console.log(item)&#125;) find/findIndex :查找查找 item/返还该 item/itemIndex 1234var item = nums.find((item) =&gt; &#123; return item == 11&#125;)console.log(item) reduce :累加preValue 前数据; 0:基础数据 12345//数组累加操作var total = nums.reduce((preValue, item) =&gt; &#123; return preValue + item&#125;, 0)console.log(total) 总结js 中很多高阶函数，我们还需继续探索。慢慢感受 js 的魅力！","categories":[{"name":"technology","slug":"technology","permalink":"http://oliverxuan.github.io/categories/technology/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://oliverxuan.github.io/tags/JavaScript/"}]},{"title":"浅谈js闭包","slug":"浅谈js闭包","date":"2021-09-05T11:53:27.000Z","updated":"2021-09-05T13:43:02.040Z","comments":true,"path":"2021/09/05/浅谈js闭包/","link":"","permalink":"http://oliverxuan.github.io/2021/09/05/%E6%B5%85%E8%B0%88js%E9%97%AD%E5%8C%85/","excerpt":"最近在学习 Javascript 高级语法，研究到了一些底层逻辑，有了很多的心得体会。赶紧记录下来！ 什么是 Js 闭包？ js 中函数是一等公民什么是一等公民？就好比 java 中的对象。js 中的函数十分灵活！ 函数可以作为另一个函数的参数，也可以作为另一个函数的返回值来使用 自己可以编写高阶函数 可以使用内置的高阶函数 代码演示： 函数作为一等公民，可以作为参数传入其他的函数中 1234567function calc(num1, num2, fnc) &#123; console.log(fnc(num1, num2))&#125;function add(num1, num2) &#123; return num1 + num2&#125;calc(20, 30, add)","text":"最近在学习 Javascript 高级语法，研究到了一些底层逻辑，有了很多的心得体会。赶紧记录下来！ 什么是 Js 闭包？ js 中函数是一等公民什么是一等公民？就好比 java 中的对象。js 中的函数十分灵活！ 函数可以作为另一个函数的参数，也可以作为另一个函数的返回值来使用 自己可以编写高阶函数 可以使用内置的高阶函数 代码演示： 函数作为一等公民，可以作为参数传入其他的函数中 1234567function calc(num1, num2, fnc) &#123; console.log(fnc(num1, num2))&#125;function add(num1, num2) &#123; return num1 + num2&#125;calc(20, 30, add) js 允许函数的嵌套定义 12345678910111213141516171819function foo() &#123; function bar() &#123; console.log(&#x27;bar&#x27;) &#125; return bar&#125;var fn = foo()fn() function makeAdder(count) function add(num) &#123; return count + num &#125; return add &#125; var add5 = makeAdder(5) var add10 = makeAdder(10) console.log(add5(10)) console.log(add10(10)) 高阶函数:把一个函数，接受另一个函数的返回值，作为参数使用，称为高阶函数。 js 中的闭包定义官方式定义：在计算机科学中对闭包的定义（维基百科）： 闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures）； 是在支持 头等函数 的编程语言中，实现词法绑定的一种技术； 闭包在实现上是一个结构体，它存储了一个函数和一个关联的环境（相当于一个符号查找表）； 闭包跟函数最大的区别在于，当捕捉闭包的时候，它的 自由变量 会在捕捉时被确定，这样即使脱离了捕捉时的上下文，它也能照常运行； MDN 对 JavaScript 闭包的解释： 一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）； 也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域； 在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来； 我对 Js 闭包的理解： 广义上来讲，js 中的函数都是闭包 狭义上来讲，js 中的一个函数，如果访问了外层作用域的变量，那它就是一个闭包。 闭包：函数+可以访问的自由变量 简单的闭包，以及逻辑： 简单描述逻辑：GO 对象，执行上下文调用栈 EcStack-&gt;全局执行上下文，VO：GO-&gt;解析函数，创建函数对象,上层作用域,函数执行体-&gt;函数执行上下文-&gt;执行代码-&gt;执行上下文销毁，AO 也销毁 闭包中的问题闭包中的某些 AO 为什么不会被销毁？这就涉及到 Js 的内存回收机制：垃圾回收器会定期从这个根开始，找所有从根开始有引用到的对象，对于哪些没有引用到的对象，就认为是不可用的对象； 我们可以参考： 12345678910111213function foo() &#123; var name = &#x27;foo&#x27; var age = 18 function bar() &#123; console.log(name) console.log(age) &#125; return bar&#125;var fn = foo()fn() 我们对 function bar 进行研究。 创建 GO 对象，包含了 fn：undefined ，foo：undefined 运行 foo（） 创建 foo 函数对象，其中包含了他作用域链，函数执行体；创建 foo AO 对象，name：undefined …，并对 bar（）进行预加载 执行 foo 函数，对 foo AO 进行修改。 创建 bar 函数对象，bar AO 其中 bar 的函数对象中 父级作用域是 foo，指向 foo AO 。 返回 bar（） fn 存储 bar 的地址 运行 fn（） bar 开始寻找相关的 name，age，bar AO 无，则向 foo AO 中寻找。 找到相关数据，执行函数。 由于我们可以很清楚地找到一条线：GO 的 fn（）-&gt; bar-&gt;bar AO 父级作用域指向 foo 的 AO 所以此时的 foo AO 不会被销毁，因为我们可以从根目录开始寻找这一条线路。 闭包内存泄漏由于某些 AO 一直存在，就有着内存泄漏的问题存在。 解决方法就直接将其指向 null 如： 12345678910111213141516function foo() &#123; var name = &#x27;foo&#x27; var age = 18 function bar() &#123; console.log(name) console.log(age) &#125; return bar&#125;var fn = foo()fn()fn = nullfoo = null 就可以解决这个问题 总结JavaScript 博大精深，还需继续努力，深入研究其中的原理。冲冲冲！","categories":[{"name":"底层逻辑","slug":"底层逻辑","permalink":"http://oliverxuan.github.io/categories/%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://oliverxuan.github.io/tags/JavaScript/"}]},{"title":"vue表单提交时自动刷新","slug":"vue表单提交时自动刷新","date":"2021-08-31T05:41:29.000Z","updated":"2021-08-31T07:47:23.348Z","comments":true,"path":"2021/08/31/vue表单提交时自动刷新/","link":"","permalink":"http://oliverxuan.github.io/2021/08/31/vue%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4%E6%97%B6%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0/","excerpt":"问题描述在之前 mmjd 的项目中，我设计了一个登陆的界面。发现当第一次提交的时候，会默认刷新一次。导致用户提交的表单是空的。从而报错。 这直接导致了很不好的用户体验。 解决方案vue 中使用表单 form 默认提交行为是刷新一下，在这儿我们使用事件修饰符 prevent 来阻止 form 表单的默认行为 1&lt;input type=&quot;submit&quot; value=&quot;提交&quot; @click.prevent=&#x27;had&#x27;&gt; 总结这个点似曾相识，在以前学习的时候老师好像提到过。自己没注意到细节上的东西。反向说明了自己对 vue 的一些细节，和项目经验不足。需要继续提高！","text":"问题描述在之前 mmjd 的项目中，我设计了一个登陆的界面。发现当第一次提交的时候，会默认刷新一次。导致用户提交的表单是空的。从而报错。 这直接导致了很不好的用户体验。 解决方案vue 中使用表单 form 默认提交行为是刷新一下，在这儿我们使用事件修饰符 prevent 来阻止 form 表单的默认行为 1&lt;input type=&quot;submit&quot; value=&quot;提交&quot; @click.prevent=&#x27;had&#x27;&gt; 总结这个点似曾相识，在以前学习的时候老师好像提到过。自己没注意到细节上的东西。反向说明了自己对 vue 的一些细节，和项目经验不足。需要继续提高！","categories":[{"name":"Obstacle","slug":"Obstacle","permalink":"http://oliverxuan.github.io/categories/Obstacle/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://oliverxuan.github.io/tags/vue/"}]},{"title":"通过node如何创建一个接口","slug":"通过node如何创建一个接口","date":"2021-08-31T05:18:58.000Z","updated":"2021-08-31T05:36:11.991Z","comments":true,"path":"2021/08/31/通过node如何创建一个接口/","link":"","permalink":"http://oliverxuan.github.io/2021/08/31/%E9%80%9A%E8%BF%87node%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3/","excerpt":"主要功能通过 node.js 环境与 Koa 框架，编写一个接口 实现方法 app 文件夹 1234567891011121314151617&lt;!-- index.js --&gt;//导入Koa框架const Koa = require(&#x27;koa&#x27;)const bodyParser = require(&#x27;koa-bodyparser&#x27;)const errorHandler = require(&#x27;./error-handle&#x27;)const useRoutes = require(&#x27;../router&#x27;)//新建Koa实例const app = new Koa()app.use(bodyParser())useRoutes(app)app.on(&#x27;error&#x27;, errorHandler)module.exports = app main.js 文件 main.js 文件一般是程序的主要入口 12345678910111213//导入之前创建的app实例const app = require(&#x27;./app&#x27;)//导入数据库相关配置require(&#x27;./app/database&#x27;)//导入相关配置const config = require(&#x27;./app/config&#x27;)//创建启动服务器app.listen(config.APP_PORT, () =&gt; &#123; console.log(`服务器在$&#123;config.APP_PORT&#125;端口已启动`)&#125;) router 文件夹index.js 文件 主要用来配置 router（路由）相关信息 12345678910111213141516//导入fs插件const fs = require(&#x27;fs&#x27;)//创建useRoutesconst useRoutes = (app) =&gt; &#123; //自动生成router相关配置 fs.readdirSync(__dirname).forEach((file) =&gt; &#123; if (file === &#x27;index.js&#x27;) return const router = require(`./$&#123;file&#125;`) app.use(router.routes()) app.use(router.allowedMethods()) &#125;)&#125;module.exports = useRoutes","text":"主要功能通过 node.js 环境与 Koa 框架，编写一个接口 实现方法 app 文件夹 1234567891011121314151617&lt;!-- index.js --&gt;//导入Koa框架const Koa = require(&#x27;koa&#x27;)const bodyParser = require(&#x27;koa-bodyparser&#x27;)const errorHandler = require(&#x27;./error-handle&#x27;)const useRoutes = require(&#x27;../router&#x27;)//新建Koa实例const app = new Koa()app.use(bodyParser())useRoutes(app)app.on(&#x27;error&#x27;, errorHandler)module.exports = app main.js 文件 main.js 文件一般是程序的主要入口 12345678910111213//导入之前创建的app实例const app = require(&#x27;./app&#x27;)//导入数据库相关配置require(&#x27;./app/database&#x27;)//导入相关配置const config = require(&#x27;./app/config&#x27;)//创建启动服务器app.listen(config.APP_PORT, () =&gt; &#123; console.log(`服务器在$&#123;config.APP_PORT&#125;端口已启动`)&#125;) router 文件夹index.js 文件 主要用来配置 router（路由）相关信息 12345678910111213141516//导入fs插件const fs = require(&#x27;fs&#x27;)//创建useRoutesconst useRoutes = (app) =&gt; &#123; //自动生成router相关配置 fs.readdirSync(__dirname).forEach((file) =&gt; &#123; if (file === &#x27;index.js&#x27;) return const router = require(`./$&#123;file&#125;`) app.use(router.routes()) app.use(router.allowedMethods()) &#125;)&#125;module.exports = useRoutes img.router.js 具体的路由文件 12345678910111213141516//导入koa路由const Router = require(&#x27;koa-router&#x27;)//制定接口的路径const imgRouter = new Router(&#123; prefix: &#x27;/mmjd&#x27; &#125;)//导入相关方法/中间件const &#123; getImgs,personType,personImgs &#125; = require(&#x27;../controller/img.controller&#x27;)const &#123; verifyAuth &#125; = require(&#x27;../middleware/auth.middleware&#x27;)//注册接口，并标明请求方法imgRouter.get(&#x27;/&#x27;, getImgs)imgRouter.post(&#x27;/personimg&#x27;,verifyAuth,personType,personImgs)module.exports = imgRouter 其次就是在 middleware 或者 controller，service 中写具体操作了 总结其中还是有很多细节的东西没有掌握好，此点需要以后继续深入研究！","categories":[{"name":"technology","slug":"technology","permalink":"http://oliverxuan.github.io/categories/technology/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://oliverxuan.github.io/tags/node-js/"}]},{"title":"axios拦截","slug":"axios拦截","date":"2021-08-30T09:17:04.000Z","updated":"2021-08-30T11:51:34.434Z","comments":true,"path":"2021/08/30/axios拦截/","link":"","permalink":"http://oliverxuan.github.io/2021/08/30/axios%E6%8B%A6%E6%88%AA/","excerpt":"主要功能实现在 axios 每次请求/响应时，对请求/响应进行相关的处理。我们把这种处理方式称之为拦截。 实现方法 request.js 文件的封装 首先我们要将 axios 主要的请求封装在 request.js 文件中，这样我们可以降低代码的耦合度，提高整体的效率，方便后期的维护。12345678910111213141516//将axios插件导入import axios from &quot;axios&quot;;//创建axios方法，并将该方法导出export function request(config) &#123; // 1.创建axios的实例 const instance = axios.create(&#123; baseURL: &quot;*******&quot;, timeout: 5000 &#125;); // 2.设立请求/响应拦截 // 3.发送真正的网络请求 return instance(config);&#125; axios 拦截器 请求拦截 可以在任何的请求上进行修饰，改变。此处我以添加 Authorization：Token 的方法为例： 12345678910111213141516//使用axios的请求拦截方法instance.interceptors.request.use( //对参数进行处理 config =&gt; &#123; //具体操作 if (localStorage.getItem(&quot;Authorization&quot;)) &#123; config.headers.Authorization = localStorage.getItem(&quot;Authorization&quot;); &#125; //最后注意需要返回修饰后的参数 return config; &#125;, error =&gt; &#123; //如果请求是错误的，我们将异常抛出 return Promise.reject(error); &#125; );","text":"主要功能实现在 axios 每次请求/响应时，对请求/响应进行相关的处理。我们把这种处理方式称之为拦截。 实现方法 request.js 文件的封装 首先我们要将 axios 主要的请求封装在 request.js 文件中，这样我们可以降低代码的耦合度，提高整体的效率，方便后期的维护。12345678910111213141516//将axios插件导入import axios from &quot;axios&quot;;//创建axios方法，并将该方法导出export function request(config) &#123; // 1.创建axios的实例 const instance = axios.create(&#123; baseURL: &quot;*******&quot;, timeout: 5000 &#125;); // 2.设立请求/响应拦截 // 3.发送真正的网络请求 return instance(config);&#125; axios 拦截器 请求拦截 可以在任何的请求上进行修饰，改变。此处我以添加 Authorization：Token 的方法为例： 12345678910111213141516//使用axios的请求拦截方法instance.interceptors.request.use( //对参数进行处理 config =&gt; &#123; //具体操作 if (localStorage.getItem(&quot;Authorization&quot;)) &#123; config.headers.Authorization = localStorage.getItem(&quot;Authorization&quot;); &#125; //最后注意需要返回修饰后的参数 return config; &#125;, error =&gt; &#123; //如果请求是错误的，我们将异常抛出 return Promise.reject(error); &#125; ); 响应拦截 1234567891011121314151617181920//axios响应拦截方法instance.interceptors.response.use( res =&gt; &#123; //获取响应参数，并返回 return res.data; &#125;, err =&gt; &#123; //如果返还错误，提取相关的Status响应码，进行错误提示 const &#123; response &#125; = err; if ((response.status = 401)) &#123; localStorage.removeItem(&quot;Authorization&quot;); localStorage.removeItem(&quot;userName&quot;); localStorage.removeItem(&quot;userId&quot;); alert(&quot;请登陆后再使用哦～&quot;); &#125; else &#123; console.log(err); &#125; &#125; ); 后续调用 如需对接后端接口，仅需要创建相关 js 文件，并写入具体请求方法。 user.js 1234567891011121314151617181920212223242526//导入我们之前封装好的request文件import &#123; request &#125; from &quot;./request&quot;;//写具体的对接接口的方法export function GetUser() &#123; return request(&#123; url: &quot;/users/name&quot;, method: &quot;POST&quot; &#125;);&#125;//传参类：//将需要的参数写在方法内export function ChangeUserSkin(flag, type, fix) &#123; return request(&#123; url: &quot;/users/skintest&quot;, method: &quot;POST&quot;, //将所需的数据创建好。 data: &#123; flag: flag, type: type, fix: fix &#125; &#125;);&#125; 总结axios 在日常的 vue 开发中是使用频率很高的组件，用来进行前后端数据交互工作。整体上并不难。需要我们熟练掌握相关的方法，逻辑。其中也需要注意代码的规范，体现封装性。","categories":[{"name":"technology","slug":"technology","permalink":"http://oliverxuan.github.io/categories/technology/"}],"tags":[{"name":"axios","slug":"axios","permalink":"http://oliverxuan.github.io/tags/axios/"}]},{"title":"mmjd项目的完成情况","slug":"mmjd项目的完成情况","date":"2021-08-24T17:24:58.000Z","updated":"2021-08-24T17:43:34.300Z","comments":true,"path":"2021/08/25/mmjd项目的完成情况/","link":"","permalink":"http://oliverxuan.github.io/2021/08/25/mmjd%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%AE%8C%E6%88%90%E6%83%85%E5%86%B5/","excerpt":"项目进度:最近一直在做那个护肤品测评网站，可谓是从无到有，功能也都在慢慢实现。目前已经完成了 90% 剩余的就是 Debug 和样式 接口功能：不多说了，直接上图！ 后端接口： 真的是完完整地做完了整个项目的后端接口。从中真的学会了很多！慢慢也熟悉了 Node.js + Koa 开发接口的开发逻辑。 Mysql： 从中也重新回忆起了很多的 sql 语句（真的好久不用生疏了！）比如：left join ，json_object…. 前端界面：现在的前端界面真的奇丑无比，等着这两天我调好了我们再看！","text":"项目进度:最近一直在做那个护肤品测评网站，可谓是从无到有，功能也都在慢慢实现。目前已经完成了 90% 剩余的就是 Debug 和样式 接口功能：不多说了，直接上图！ 后端接口： 真的是完完整地做完了整个项目的后端接口。从中真的学会了很多！慢慢也熟悉了 Node.js + Koa 开发接口的开发逻辑。 Mysql： 从中也重新回忆起了很多的 sql 语句（真的好久不用生疏了！）比如：left join ，json_object…. 前端界面：现在的前端界面真的奇丑无比，等着这两天我调好了我们再看！ 技术栈： 前端：Html JavaScript CSS Vue Vuex VueRouter axios Webpack node.js Bootstrap 后端：node.js Koa mysql 数据库: mysql 收获：通过这次完完整整地独自开发前后端的项目，很多东西真的就是要亲自来才能深刻体会！希望自己以后能参与或创造更多的项目！ 开源地址: 前端：https://github.com/Oliverxuan/mmjd 后端：https://github.com/Oliverxuan/MMJD-node","categories":[{"name":"CodeLife","slug":"CodeLife","permalink":"http://oliverxuan.github.io/categories/CodeLife/"}],"tags":[{"name":"项目","slug":"项目","permalink":"http://oliverxuan.github.io/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"创建用户并验证合法性","slug":"创建用户并验证合法性","date":"2021-08-15T16:10:04.000Z","updated":"2021-08-15T16:54:39.145Z","comments":true,"path":"2021/08/16/创建用户并验证合法性/","link":"","permalink":"http://oliverxuan.github.io/2021/08/16/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E5%B9%B6%E9%AA%8C%E8%AF%81%E5%90%88%E6%B3%95%E6%80%A7/","excerpt":"主要功能实现一个接口，可以读取用户的输入信息，并检查其合法性。如果其合法，将其录入数据库中，如果不合法，返回其不合法的类型。 实现方法1.创建数据库：1234567CREATE TABLE IF NOT EXISTS `users`(id INT PRIMARY KEY AUTO_INCREMENT,name VARCHAR(30) NOT NULL UNIQUE,password VARCHAR(50) NOT NULL,createAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,updateAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP); 2.连接数据库1.配置数据库信息 将数据库的配置写入 .env 文件中 1234567# mysql配置MYSQL_HOST=xxxxxxMYSQL_PORT=xxxxMYSQL_DATABASE=xxxxxMYSQL_ROOT=xxxxxMYSQL_PASSWORD=xxxxxx 将数据库信息在 config.js 文件中导入","text":"主要功能实现一个接口，可以读取用户的输入信息，并检查其合法性。如果其合法，将其录入数据库中，如果不合法，返回其不合法的类型。 实现方法1.创建数据库：1234567CREATE TABLE IF NOT EXISTS `users`(id INT PRIMARY KEY AUTO_INCREMENT,name VARCHAR(30) NOT NULL UNIQUE,password VARCHAR(50) NOT NULL,createAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,updateAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP); 2.连接数据库1.配置数据库信息 将数据库的配置写入 .env 文件中 1234567# mysql配置MYSQL_HOST=xxxxxxMYSQL_PORT=xxxxMYSQL_DATABASE=xxxxxMYSQL_ROOT=xxxxxMYSQL_PASSWORD=xxxxxx 将数据库信息在 config.js 文件中导入 12345678module.exports = &#123; APP_PORT, MYSQL_HOST, MYSQL_PORT, MYSQL_DATABASE, MYSQL_ROOT, MYSQL_PASSWORD,&#125; = process.env 2.建立数据库连接 在全局文件夹（app）里新建关于数据库操作的 database.js 文件 导入 mysql 插件 1const mysql = require(&#x27;mysql2&#x27;) 将配置信息导入 1const config = require(&#x27;./config&#x27;) 创建数据库连接池,并将相关配置导入 12345678const connections = mysql.createPool(&#123; host: config.MYSQL_HOST, port: config.MYSQL_PORT, database: config.MYSQL_DATABASE, user: config.MYSQL_ROOT, password: config.MYSQL_PASSWORD,&#125;) 取得数据库连接，并设置数据库启动提示 123456789connections.getConnection((err, conn) =&gt; &#123; conn.connect((err) =&gt; &#123; if (err) &#123; console.log(&#x27;数据库连接失败!&#x27;) &#125; else &#123; console.log(&#x27;数据库连接成功！&#x27;) &#125; &#125;)&#125;) 将 connections 导出，从而达到封装。 12//操作都是建立在connections.promise（）上的，所以在导出的时候连带promise()module.exports = connections.promise() 在 main.js 中引入 database.js，从而达到加载目的 12require(&#x27;./app/database&#x27;) 测试连接,得到回应： 3.实现数据库的存入 实现 create 方法 12//查询数据 const result = await service.create(user) 在 service 的 user.service.js 中写入数据库操作 12345678910//操作都是异步的所以要加上async awaitasync create(user) &#123; //从user中获取user，password const &#123; name, password &#125; = user //sql语句 const statement = &#x27;INSERT INTO users (name,password) VALUES (?,?);&#x27; //执行sql语句，并将查询结果返还至result中 const result = await connection.execute(statement, [name, password]) return result[0] &#125; 执行结果 优化过程：验证输入的合法性 创建验证中间件 verifyUser ,并写入 UserRouter 中 1userRouter.post(&#x27;/&#x27;, verifyUser, create) 由于此类型的中间件在后续开发中会频繁创建，故统一在 middleware.js 中创建 12345678910111213141516171819202122232425262728293031323334353637383940// 导入错误类型const errorType = require(&#x27;../constants/error-types&#x27;)// 导入service 利用其中的getUserByName来验证是否已存在该用户const service = require(&#x27;../service/user.service&#x27;)//创建中间件，注意其也是异步操作！const verifyUser = async (ctx, next) =&gt; &#123; //获取用户名，密码 const &#123; name, password &#125; = ctx.request.body //判断不能为空 if (!name || !password) &#123; //如果为空，则新建Error，其错误类型为：NAME_OR_PASSWORD_IS_REQUIRED const error = new Error(errorType.NAME_OR_PASSWORD_IS_REQUIRED) //将错误发射出去 return ctx.app.emit(&#x27;error&#x27;, error, ctx) &#125; //判断本次注册的用户名是否被注册 const result = await service.getUserByNanme(name) //如果返还不为NULL if (result.length) &#123; //新建error 错误类型为：USER_ALREADY_EXISTS const error = new Error(errorType.USER_ALREADY_EXISTS) //将错误发射出去 return ctx.app.emit(&#x27;error&#x27;, error, ctx) &#125; //如果以上都未执行，则进行下一个中间件：create await next()&#125;//导出verifyUsermodule.exports = &#123; verifyUser,&#125; errorType 的创建由于以后的错误类型会有很多，所以统一写入在 errorType 中 1234567const NAME_OR_PASSWORD_IS_REQUIRED = &#x27;name_or_password_is_required&#x27;const USER_ALREADY_EXISTS = &#x27;user_already_exists&#x27;module.exports = &#123; NAME_OR_PASSWORD_IS_REQUIRED, USER_ALREADY_EXISTS,&#125; service 中的 getUserByName 方法 1234567async getUserByNanme(name) &#123; const statement = `SELECT * FROM users WHERE name = ?;` const result = await connection.execute(statement, [name]) return result[0]&#125; 在 index.js 中接收报错信息 12app.on(&#x27;error&#x27;, errorHandler) 创建错误处理 error-handle.js在其中统一处理错误信息 12345678910111213141516171819202122232425262728293031//导入错误类型const errorTypes = require(&#x27;../constants/error-types&#x27;)// 导入之前发射出来的参数error，ctx，并进行分析处理const errorHandler = (error, ctx) =&gt; &#123; //建立状态变量，和报错提示 let status, message //通过传入的错误类型来判断处理方式 switch (error.message) &#123; case errorTypes.NAME_OR_PASSWORD_IS_REQUIRED: status = 400 //Bad request message = &#x27;用户名或者密码为空&#x27; break case errorTypes.USER_ALREADY_EXISTS: console.log(&#x27;1&#x27;) status = 409 //Conflict message = &#x27;用户名已存在&#x27; break default: status = 404 message = &#x27;NOT FOUND&#x27; &#125; //将错误信息导入ctx中 ctx.status = status ctx.body = message&#125;module.exports = errorHandler 错误展示用户已存在：状态码： 用户输入名或密码为空:状态码： 总结经过今天的汇总，逐渐将其中的思路理清楚，为以后开发接口提供了思路。","categories":[{"name":"technology","slug":"technology","permalink":"http://oliverxuan.github.io/categories/technology/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://oliverxuan.github.io/tags/node-js/"}]},{"title":"node.js 用户登陆初体验","slug":"node-js-用户登陆初体验","date":"2021-08-13T16:59:57.000Z","updated":"2021-08-13T17:48:58.913Z","comments":true,"path":"2021/08/14/node-js-用户登陆初体验/","link":"","permalink":"http://oliverxuan.github.io/2021/08/14/node-js-%E7%94%A8%E6%88%B7%E7%99%BB%E9%99%86%E5%88%9D%E4%BD%93%E9%AA%8C/","excerpt":"实现目标写一个接口，实现从用户输入中获得数据 技术点文件夹功能分类 app (app 操作文件夹) index.js (导入所使用的插件，中间件) 12345678910111213141516// 导入所需的插件，中间件const Koa = require(&#x27;koa&#x27;)const bodyParser = require(&#x27;koa-bodyparser&#x27;)const userRouter = require(&#x27;../router/user.router&#x27;)//实例化Koa对象const app = new Koa()//注册/使用插件，中间件app.use(bodyParser())app.use(userRouter.routes())app.use(userRouter.allowedMethods())//导出app 以便其他模块使用module.exports = app config.js (配置操作) 12345678//导入插件const dotenv = require(&#x27;dotenv&#x27;)//使用插件的方法，导入写好的配置文件（.env）dotenv.config()module.exports = &#123; APP_PORT &#125; = process.env main.js (程序的总入口)","text":"实现目标写一个接口，实现从用户输入中获得数据 技术点文件夹功能分类 app (app 操作文件夹) index.js (导入所使用的插件，中间件) 12345678910111213141516// 导入所需的插件，中间件const Koa = require(&#x27;koa&#x27;)const bodyParser = require(&#x27;koa-bodyparser&#x27;)const userRouter = require(&#x27;../router/user.router&#x27;)//实例化Koa对象const app = new Koa()//注册/使用插件，中间件app.use(bodyParser())app.use(userRouter.routes())app.use(userRouter.allowedMethods())//导出app 以便其他模块使用module.exports = app config.js (配置操作) 12345678//导入插件const dotenv = require(&#x27;dotenv&#x27;)//使用插件的方法，导入写好的配置文件（.env）dotenv.config()module.exports = &#123; APP_PORT &#125; = process.env main.js (程序的总入口) 123456789// 导入之前的Koa实例化的对象app。 导入配置文件const app = require(&#x27;./app&#x27;)const config = require(&#x27;./app/config&#x27;)//创建服务器，并利用config的APP_PORT参数app.listen(config.APP_PORT, () =&gt; &#123; console.log(`服务器在$&#123;config.APP_PORT&#125;端口已启动`)&#125;) router (所有的路由管理文件夹) user.router.js (user 的路由管理) 12345678910111213141516// 路由相关的js 注册接口适用//导入koa-router组件const Router = require(&#x27;koa-router&#x27;)//导入方法const &#123; create &#125; = require(&#x27;../controller/user.controller&#x27;)//注册路由 其路径为/usersconst userRouter = new Router(&#123; prefix: &#x27;/users&#x27; &#125;)//设置路由的响应方式，响应方法userRouter.post(&#x27;/&#x27;, create)//导出路由module.exports = userRouter controller (管理不同路径下的不同的情况下的方法，操作) user.controller.js (user 的一些方法，操作) 12345678910111213141516171819//导入写好的方法const service = require(&#x27;../service/user.service&#x27;)//创建类 其中包含了不同情况下的不同方法class UserController &#123; async create(ctx, next) &#123; //获取用户请求的参数 const user = ctx.request.body //查询数据 const result = await service.create(user) //返回数据 ctx.body = result &#125;&#125;module.exports = new UserController() service (业务层，其一般对接着 mysql 数据库操作) user.service.js 1234567891011//创建类class UserService &#123; async create(user) &#123; console.log(&#x27;将用户数据保存到数据库中&#x27;, user) //将user存储到数据库中 return &#x27;创建用户成功&#x27; &#125;&#125;module.exports = new UserService() utils (工具类) .env (配置文件) 123# 服务器端口号APP_PORT=8000 实现结果 总结本次实现了一个小功能，主要目的是想让自己理清楚这个文件与文件之间的关系，以及不同的文件之间的分工。","categories":[{"name":"technology","slug":"technology","permalink":"http://oliverxuan.github.io/categories/technology/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://oliverxuan.github.io/tags/node-js/"}]},{"title":"Better-scroll 中无法滚动问题","slug":"Better-scroll-中无法滚动问题","date":"2021-08-11T06:25:44.000Z","updated":"2021-08-31T05:42:20.684Z","comments":true,"path":"2021/08/11/Better-scroll-中无法滚动问题/","link":"","permalink":"http://oliverxuan.github.io/2021/08/11/Better-scroll-%E4%B8%AD%E6%97%A0%E6%B3%95%E6%BB%9A%E5%8A%A8%E9%97%AE%E9%A2%98/","excerpt":"问题描述在昨天我在使用 Vue 开发前端页面的时候，我遇到了在使用 better-scroll 实现页面滚动的时候无法滚动经过排查，问题出在与 better-scroll 的滚动原理与实际高度之间产生矛盾（图片异步加载问题） 问题分析在之前的 GoodsList 组件中，有一个加载接口图片的操作 12345678910&lt;template&gt; &lt;div class=&quot;goods-item&quot;&gt; &lt;img :src=&quot;goodsItem.img&quot; alt=&quot;&quot; /&gt; &lt;div class=&quot;goods-info&quot;&gt; &lt;p&gt;&#123;&#123; goodsItem.name &#125;&#125;&lt;/p&gt; &lt;span class=&quot;price&quot;&gt;RMB:&#123;&#123; goodsItem.price &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 由于 better-scroll 在计算 wrapper content 高度的时候是在一开始就会计算好 从而达到滚动的目的 但是 Goods list 会加载网路图片，存在一个异步问题加载完后，实际的高度会远超于之前 better-scroll 计算的高度 从而导致 better-scroll 之间计算无效了，最终无法滚动 解决方法123456789&lt;template&gt; &lt;div class=&quot;goods-item&quot;&gt; &lt;img :src=&quot;goodsItem.img&quot; alt=&quot;&quot; @load=&quot;imageload&quot; /&gt; &lt;div class=&quot;goods-info&quot;&gt; &lt;p&gt;&#123;&#123; goodsItem.name &#125;&#125;&lt;/p&gt; &lt;span class=&quot;price&quot;&gt;RMB:&#123;&#123; goodsItem.price &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;","text":"问题描述在昨天我在使用 Vue 开发前端页面的时候，我遇到了在使用 better-scroll 实现页面滚动的时候无法滚动经过排查，问题出在与 better-scroll 的滚动原理与实际高度之间产生矛盾（图片异步加载问题） 问题分析在之前的 GoodsList 组件中，有一个加载接口图片的操作 12345678910&lt;template&gt; &lt;div class=&quot;goods-item&quot;&gt; &lt;img :src=&quot;goodsItem.img&quot; alt=&quot;&quot; /&gt; &lt;div class=&quot;goods-info&quot;&gt; &lt;p&gt;&#123;&#123; goodsItem.name &#125;&#125;&lt;/p&gt; &lt;span class=&quot;price&quot;&gt;RMB:&#123;&#123; goodsItem.price &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 由于 better-scroll 在计算 wrapper content 高度的时候是在一开始就会计算好 从而达到滚动的目的 但是 Goods list 会加载网路图片，存在一个异步问题加载完后，实际的高度会远超于之前 better-scroll 计算的高度 从而导致 better-scroll 之间计算无效了，最终无法滚动 解决方法123456789&lt;template&gt; &lt;div class=&quot;goods-item&quot;&gt; &lt;img :src=&quot;goodsItem.img&quot; alt=&quot;&quot; @load=&quot;imageload&quot; /&gt; &lt;div class=&quot;goods-info&quot;&gt; &lt;p&gt;&#123;&#123; goodsItem.name &#125;&#125;&lt;/p&gt; &lt;span class=&quot;price&quot;&gt;RMB:&#123;&#123; goodsItem.price &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 在原代码 “&lt; img &gt;”标签处新增 @load=”imageload“ 监听事件 12345methods: &#123; imageload() &#123; this.$bus.$emit(&quot;itemImageLoad&quot;); &#125; &#125; 随后在方法里将此事件发射到事件总线里面 注意，需要在 main.js 里注册 事件总线 12345678910111213import Vue from &quot;vue&quot;;import App from &quot;./App.vue&quot;;import router from &quot;./router&quot;;import store from &quot;./store&quot;;Vue.config.productionTip = false;Vue.prototype.$bus = new Vue();new Vue(&#123; router, store, render: h =&gt; h(App)&#125;).$mount(&quot;#app&quot;); 将事件传入事件总线后 需要在 better-scroll 滚动页面里面监听事件 12345mounted() &#123; this.$bus.$on(&quot;itemImageLoad&quot;, () =&gt; &#123; this.$refs.scroll.scroll.refresh(); &#125;); &#125;, 提前设置 better-scroll 中的 refs 从而方便操作 最后监听到图片加载后 调用 scroll 的 refresh（）函数达到重新计算高度的目的 性能优化由于之前的频繁发出事件 image load 导致 实际上会 refresh 很多次 此处就需要 dbounce 防抖函数来处理 ： 12345678910function debounce(fn,delay)&#123; var handle; return function()&#123; clearTimeout(handle) handle=setTimeout(function()&#123; fn() &#125;,delay) &#125; &#125; 从而达到性能优化的目的","categories":[{"name":"Obstacle","slug":"Obstacle","permalink":"http://oliverxuan.github.io/categories/Obstacle/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://oliverxuan.github.io/tags/vue/"}]},{"title":"Hello,好久不见","slug":"Hello-好久不见","date":"2021-08-11T06:04:48.000Z","updated":"2021-08-11T06:25:13.431Z","comments":true,"path":"2021/08/11/Hello-好久不见/","link":"","permalink":"http://oliverxuan.github.io/2021/08/11/Hello-%E5%A5%BD%E4%B9%85%E4%B8%8D%E8%A7%81/","excerpt":"最近都去干什么了？距离上次更新我的博客已经过去了 10 多天了，在这段时间里我开始新的征程 =&gt; 准备 9 月份的 辽宁省大学生移动开发大赛 我计划着开发一个护肤品测评网站，整个网站的架构为：前端：Vue 全家桶，axios 后端：Node.js，express 数据库：Mysql 期间遇到的问题困难由于我之前没有涉及过后端的接口开发，所以我在这 10 天的时间里自学了一点 Node.js 的开发基础。顺便学习了 Express，Koa 框架的基本开发。 到目前为止，我已成功地将写好的使用 Express 的 Js 程序用 Node.js 部署在我的云服务器上。 在这其中我遇到了很多的困难，例如： 在服务器上部署合适的 Node &amp; Mysql 如何在本地通过 ssh 连接远端服务器","text":"最近都去干什么了？距离上次更新我的博客已经过去了 10 多天了，在这段时间里我开始新的征程 =&gt; 准备 9 月份的 辽宁省大学生移动开发大赛 我计划着开发一个护肤品测评网站，整个网站的架构为：前端：Vue 全家桶，axios 后端：Node.js，express 数据库：Mysql 期间遇到的问题困难由于我之前没有涉及过后端的接口开发，所以我在这 10 天的时间里自学了一点 Node.js 的开发基础。顺便学习了 Express，Koa 框架的基本开发。 到目前为止，我已成功地将写好的使用 Express 的 Js 程序用 Node.js 部署在我的云服务器上。 在这其中我遇到了很多的困难，例如： 在服务器上部署合适的 Node &amp; Mysql 如何在本地通过 ssh 连接远端服务器 ssh root@ip 如何在 vs code navicat-mysql ssh 连接远端数据 vs code 通过远程资源管理器 mysql 里设置可远端读写权限 navicat 在建立连接时正确写入服务器中的数据库信息 注意需要在服务器安全组里开放相应的端口 建立数据库，在 Vue 里通过 axios 连接远端数据库 处理接口数据 如何在服务器上一直运行 Node 项目 npm2 管理插件 在此感谢前辈们在遇到困难时留下的宝贵经验，以至于我在后续开发时遇到问题都能及时解决","categories":[{"name":"CodeLife","slug":"CodeLife","permalink":"http://oliverxuan.github.io/categories/CodeLife/"}],"tags":[{"name":"规划","slug":"规划","permalink":"http://oliverxuan.github.io/tags/%E8%A7%84%E5%88%92/"}]},{"title":"岛屿问题的实现","slug":"岛屿问题的实现","date":"2021-07-31T06:42:14.000Z","updated":"2021-07-31T06:51:19.367Z","comments":true,"path":"2021/07/31/岛屿问题的实现/","link":"","permalink":"http://oliverxuan.github.io/2021/07/31/%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"问题描述给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/number-of-islands著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解决方案此问题与上一期的门墙算法的实现的思想基本一致，属于利用队列，以及广度优先搜索（dfs）的方式解决问题。但是并不是完全的相同。本问题需要注意在于广度优先搜索的时候，需要有“感染”的思想。 首先遍历整个二维数组，寻找数组中的岛 再在孤岛的基础上 遍历他的上下左右临格元素 是否也为“1”岛屿 如果是 将它感染。 1234567891011121314151617181920212223242526272829public class Solution &#123; public int numIslands(char[][] grid) &#123; if(grid.length==0)&#123; return 0; &#125; int count=0; for (int i = 0; i &lt; grid.length; i++) &#123; for (int j = 0; j &lt; grid[0].length; j++) &#123; if(grid[i][j]==&#x27;1&#x27;)&#123; count++; dfs(grid,i,j); &#125; &#125; &#125; return count; &#125; private void dfs(char[][] grid, int i, int j) &#123; if(i&lt;0 || i&gt;= grid.length || j&lt;0 || j&gt;=grid[0].length || grid[i][j]==&#x27;0&#x27;)&#123; return; &#125; grid[i][j]=&#x27;0&#x27;; dfs(grid, i - 1, j); dfs(grid, i + 1, j); dfs(grid, i, j + 1); dfs(grid, i, j - 1); &#125;&#125;","text":"问题描述给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/number-of-islands著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解决方案此问题与上一期的门墙算法的实现的思想基本一致，属于利用队列，以及广度优先搜索（dfs）的方式解决问题。但是并不是完全的相同。本问题需要注意在于广度优先搜索的时候，需要有“感染”的思想。 首先遍历整个二维数组，寻找数组中的岛 再在孤岛的基础上 遍历他的上下左右临格元素 是否也为“1”岛屿 如果是 将它感染。 1234567891011121314151617181920212223242526272829public class Solution &#123; public int numIslands(char[][] grid) &#123; if(grid.length==0)&#123; return 0; &#125; int count=0; for (int i = 0; i &lt; grid.length; i++) &#123; for (int j = 0; j &lt; grid[0].length; j++) &#123; if(grid[i][j]==&#x27;1&#x27;)&#123; count++; dfs(grid,i,j); &#125; &#125; &#125; return count; &#125; private void dfs(char[][] grid, int i, int j) &#123; if(i&lt;0 || i&gt;= grid.length || j&lt;0 || j&gt;=grid[0].length || grid[i][j]==&#x27;0&#x27;)&#123; return; &#125; grid[i][j]=&#x27;0&#x27;; dfs(grid, i - 1, j); dfs(grid, i + 1, j); dfs(grid, i, j + 1); dfs(grid, i, j - 1); &#125;&#125;","categories":[{"name":"Problems","slug":"Problems","permalink":"http://oliverxuan.github.io/categories/Problems/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://oliverxuan.github.io/tags/leetcode/"}]},{"title":"门与墙算法的实现","slug":"门与墙算法的实现","date":"2021-07-29T14:50:18.000Z","updated":"2021-07-30T15:16:58.408Z","comments":true,"path":"2021/07/29/门与墙算法的实现/","link":"","permalink":"http://oliverxuan.github.io/2021/07/29/%E9%97%A8%E4%B8%8E%E5%A2%99%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"问题描述：你被给定一个 m × n 的二维网格 rooms ，网格中有以下三种可能的初始化值：-1 表示墙或是障碍物 0 表示一扇门INF 无限表示一个空的房间。然后，我们用 231 - 1 = 2147483647 代表 INF。你可以认为通往门的距离总是小于 2147483647 的。你要给每个空房间位上填上该房间到 最近门的距离 ，如果无法到达门，则填 INF 即可。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/walls-and-gates著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 建立基本数据以及辅助坐标 先寻找门坐标，将其入队 取出队头元素 A 进行解析 分析 A 上下左右 block 是否可用 合法 A 是否未赋值 将合法的 block 进行赋值（步数） 将新的 block 入队 结束条件当取出的区域 上下左右都已经赋值 ｜｜ 为墙，为门 则无需处理，退出处理队列 本题的突破点: 理解队列先进先出的性质 广度优先搜索的性质 先找门，后赋值的思路 ps：block 我的定义是 INF 即可用的房间","text":"问题描述：你被给定一个 m × n 的二维网格 rooms ，网格中有以下三种可能的初始化值：-1 表示墙或是障碍物 0 表示一扇门INF 无限表示一个空的房间。然后，我们用 231 - 1 = 2147483647 代表 INF。你可以认为通往门的距离总是小于 2147483647 的。你要给每个空房间位上填上该房间到 最近门的距离 ，如果无法到达门，则填 INF 即可。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/walls-and-gates著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 建立基本数据以及辅助坐标 先寻找门坐标，将其入队 取出队头元素 A 进行解析 分析 A 上下左右 block 是否可用 合法 A 是否未赋值 将合法的 block 进行赋值（步数） 将新的 block 入队 结束条件当取出的区域 上下左右都已经赋值 ｜｜ 为墙，为门 则无需处理，退出处理队列 本题的突破点: 理解队列先进先出的性质 广度优先搜索的性质 先找门，后赋值的思路 ps：block 我的定义是 INF 即可用的房间 实现难点 如何寻找 block 的上下左右房间 该房间的周围空间是否有用 能否联想到新的 block 就当作是一个新门，再从新门找他的上下左右 block 如何进行数据处理 细节处理 象形理解把每一个门当作一个大的问题小孩（类似孩子王），队列就是记录未解决问题小孩的清单。我们把每一个 INF 区域当作一个医生，安排医生用最小的距离去解决这些问题小孩。我们先在房间里寻找大问题小孩，将他们全部记录在清单上。我们开始分析他周围是否也有问题小孩（孩子王的小跟班）（上下左右检查）如果有（该区域为空）且该问题其他医生没有解决（未赋值）我们就指派该区域的医生去解决这个问题小孩，并且记录该问题小孩离孩子王有多远。（为 block 赋值）如果周围的问题小孩已经有医生解决了，我们就不管。将新的问题小孩记录在队列上，原先的孩子王的下线已经全盘供出，所以他从问题清单上划除。继续解决清单上的新的问题小孩….（可能有点不怎么容易理解。。。。我真的尽力了 源码 yyds ） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Solution &#123; //定义空房间的特征值 private static final int INF = 2147483647; //定义门的特殊值 private static final int DOOR = 0; //定义辅助坐标 以此来表示房间的上下左右 private static final List&lt;int[]&gt; DIRECTIONS = Arrays.asList( new int[]&#123;1, 0&#125;, new int[]&#123;-1, 0&#125;, new int[]&#123;0, -1&#125;, new int[]&#123;0, 1&#125; ); public void wallsAndGates(int[][] rooms) &#123; //记录房间的长宽 int m= rooms.length; int n=rooms[0].length; if(m==0)&#123; return; &#125; //创建队列 Queue&lt;int []&gt; queue=new LinkedList&lt;&gt;(); //遍历rooms 寻找所有的门 for (int row = 0; row &lt; m; row++) &#123; for (int col = 0; col &lt; n; col++) &#123; //当检测到该地区为门的时候 将门的坐标元素入队 if(rooms[row][col]==DOOR)&#123; queue.add(new int[]&#123;row,col&#125;); &#125; &#125; &#125; //核心区域 （当队列不为空的时候，继续执行） while(!queue.isEmpty())&#123; //取出队头的元素 也是最先入队的元素 （ d,c,b,a =&gt; a) int[] block = queue.poll(); //记录原生的行，列数据 int row=block[0]; int col=block[1]; //制造当前block的上下左右block 利用辅助坐标快速制作出新的坐标数据 for (int [] direction: DIRECTIONS) &#123; int r=row+direction[0]; int c=col+direction[1]; //判断新的坐标是否合法 是否存在障碍物 ！！（重点！）是否之前已经被被赋值过！！ //如果已经被赋值 说明当前值就是该区域的最短路径，再次改变就是不准确值 // 因为是广度优先 所以当前值一定是最优值 if(r&lt;0 || c&lt;0 || r&gt;=rooms.length || c&gt;=rooms[0].length || rooms[r][c]!=INF)&#123; continue; &#125; //细节点 需要在前一个block的值上进行+1 否则步数全为1 rooms[r][c]=rooms[row][col]+1; //如果都不是 则为全新的为赋值block 将其加入队列（列尾） queue.add(new int[]&#123;r,c&#125;); &#125; &#125; &#125;&#125;","categories":[{"name":"Problems","slug":"Problems","permalink":"http://oliverxuan.github.io/categories/Problems/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://oliverxuan.github.io/tags/leetcode/"}]},{"title":"循环队列的实现","slug":"循环队列的实现","date":"2021-07-27T17:21:50.000Z","updated":"2021-07-30T15:17:02.169Z","comments":true,"path":"2021/07/28/循环队列的实现/","link":"","permalink":"http://oliverxuan.github.io/2021/07/28/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"问题描述：设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。 循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。 你的实现应该支持如下操作： MyCircularQueue(k): 构造器，设置队列长度为 k 。Front: 从队首获取元素。如果队列为空，返回 -1 。Rear: 获取队尾元素。如果队列为空，返回 -1 。enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。isEmpty(): 检查循环队列是否为空。isFull(): 检查循环队列是否已满。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/design-circular-queue 示例：MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3circularQueue.enQueue(1); // 返回 truecircularQueue.enQueue(2); // 返回 truecircularQueue.enQueue(3); // 返回 truecircularQueue.enQueue(4); // 返回 false，队列已满circularQueue.Rear(); // 返回 3circularQueue.isFull(); // 返回 truecircularQueue.deQueue(); // 返回 truecircularQueue.enQueue(4); // 返回 truecircularQueue.Rear(); // 返回 4 解题思路： 首先要明白循环队列的原理 如何设计循环队列中的两个指针 细节处理","text":"问题描述：设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。 循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。 你的实现应该支持如下操作： MyCircularQueue(k): 构造器，设置队列长度为 k 。Front: 从队首获取元素。如果队列为空，返回 -1 。Rear: 获取队尾元素。如果队列为空，返回 -1 。enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。isEmpty(): 检查循环队列是否为空。isFull(): 检查循环队列是否已满。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/design-circular-queue 示例：MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3circularQueue.enQueue(1); // 返回 truecircularQueue.enQueue(2); // 返回 truecircularQueue.enQueue(3); // 返回 truecircularQueue.enQueue(4); // 返回 false，队列已满circularQueue.Rear(); // 返回 3circularQueue.isFull(); // 返回 truecircularQueue.deQueue(); // 返回 truecircularQueue.enQueue(4); // 返回 truecircularQueue.Rear(); // 返回 4 解题思路： 首先要明白循环队列的原理 如何设计循环队列中的两个指针 细节处理 循环队列原理https://www.bilibili.com/video/BV1yx411e7nb?from=search&amp;seid=13632348157331521482/ 实现难点： 为什么要在 eg：head（head+1）% size 取模？ 为什么 get tail 的时候不能直接返回？ 细节处理 实现代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class MyCircularQueue &#123; //构造原始数组 int[] arr; //数组长度 int size; //头指针，记录循环列表的头部 int head; //尾指针，记录循环列表的尾部 int tail; //计数器，记录总共有多少个元素 int count; //构造器，将原始的数组arr转化为实体，以及一些变量的初始化 public MyCircularQueue(int k) &#123; arr = new int[k]; size = k; head = 0; tail = 0; count = 0; &#125; //入队操作 public boolean enQueue(int value) &#123; //先判断队列是否已满。 if (isFull()) &#123; return false; &#125; arr[tail] = value; //关键点！此处的指针也应该跟着循环，不能说到了数组的size（最大长度）就一直无限延续 //所以这里需要取模运算&quot;%&quot; 例：k=size=7 tail=7 tail=（7+1%7=1 所以下次tail //的位置就在下角标为 1 的位置 从而达到循环指针的目的 后面的head指针同理 tail = (tail + 1) % size; count++; return true; &#125; //出队操作 public boolean deQueue() &#123; //判断是否为空 if (isEmpty()) &#123; return false; &#125; head = (head + 1) % size; count--; return true; &#125; //取头元素 public int Front() &#123; if (isEmpty()) &#123; return -1; &#125; return arr[head]; &#125; public int Rear() &#123; if(isEmpty())&#123; return -1; &#125; //此处需要注意tail的真实位置到底指向的是哪里。 //注意数据的处理不能取负。 return arr[(tail - 1 + size) % size]; &#125; //判断空 public boolean isEmpty() &#123; return count==0; &#125; //判断满 public boolean isFull() &#123; return size==count; &#125;&#125; 总结：在对循环队列实现的时候，注意的细节点有很多，需要做到指针循环才能达到整体的循环目的。总的来说还是难度中等。","categories":[{"name":"Problems","slug":"Problems","permalink":"http://oliverxuan.github.io/categories/Problems/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://oliverxuan.github.io/tags/leetcode/"}]},{"title":"hexo s 时4000端口被占用问题","slug":"hexo-s-时4000端口被占用问题","date":"2021-07-25T14:47:18.000Z","updated":"2021-07-29T17:24:31.003Z","comments":true,"path":"2021/07/25/hexo-s-时4000端口被占用问题/","link":"","permalink":"http://oliverxuan.github.io/2021/07/25/hexo-s-%E6%97%B64000%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98/","excerpt":"问题描述：hexo s 启动的时候遇到了 4000 端口无法创建使用的问题。具体打开 localhost：4000 发现 4000 端口下 hexo 依然在运行！ 解决方案：(mac 环境): sudo lsof -i tcp:4000查询当前端口的进程 报错： 12COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEnode 19087 root 23u IPv6 0xe0d367ae3505eeb3 0t0 TCP *:terabase (LISTEN) 发现进程 19087 sudo kill 19087 再次打开就没有 hexo 的页面了 最后成功在 4000 默认端口下启动 hexo","text":"问题描述：hexo s 启动的时候遇到了 4000 端口无法创建使用的问题。具体打开 localhost：4000 发现 4000 端口下 hexo 依然在运行！ 解决方案：(mac 环境): sudo lsof -i tcp:4000查询当前端口的进程 报错： 12COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEnode 19087 root 23u IPv6 0xe0d367ae3505eeb3 0t0 TCP *:terabase (LISTEN) 发现进程 19087 sudo kill 19087 再次打开就没有 hexo 的页面了 最后成功在 4000 默认端口下启动 hexo","categories":[{"name":"Obstacle","slug":"Obstacle","permalink":"http://oliverxuan.github.io/categories/Obstacle/"}],"tags":[{"name":"技术踩坑","slug":"技术踩坑","permalink":"http://oliverxuan.github.io/tags/%E6%8A%80%E6%9C%AF%E8%B8%A9%E5%9D%91/"}]},{"title":"关于大三一年的计划","slug":"关于大三一年的计划","date":"2021-07-25T14:39:56.000Z","updated":"2021-07-30T15:18:55.613Z","comments":true,"path":"2021/07/25/关于大三一年的计划/","link":"","permalink":"http://oliverxuan.github.io/2021/07/25/%E5%85%B3%E4%BA%8E%E5%A4%A7%E4%B8%89%E4%B8%80%E5%B9%B4%E7%9A%84%E8%AE%A1%E5%88%92/","excerpt":"大三这一年真的是无比关键.想着明年的今天就是我实习的日子.心里多少还是有些焦虑。 回顾自身：大一光顾着玩耍，等到大一暑假的时候突然感觉”玩的索然无味“玩的甚至有点空虚。觉得这不是自己想要的生活。于是放下了我喜欢的游戏。打开了哔哩哔哩，搜起了关于 Java 的教学视频，我还记着我第一次装 Jdk 第一次配置环境变量的时候的一脸懵逼。（这和我学的 C 不一样呀）好奇心促使我继续坚持学习了下去。就这样，我听着尚硅谷的宋红康老师的 Java 课程度过了第一个充实的暑假，也是在那个暑假，我渐渐地明白了，计算机的路，我才刚刚开始。等到了大二，我渐渐尝试着做一些简单的静态页面，跟着做一些简单的 JavaWeb 项目。当我第一次在我自己的数据库接收到前端页面发来的数据的时候，我真的无比激动！这真的是一件很有成就感的事情！到了大二的下学期，在好朋友的指引下，我渐渐接触一些更深层次的东西，我学习了 CoderWhy 老师的 Vue，学完了 Vue 我也深刻体会到组件化开发的便利性。真的佩服我们的尤大佬！能开发出这么好的框架！我什么时候才能到达他这种能力呀！大二这一年，是我学习进步最快的一年，我渐渐明白到了真正的差距到底有多大。所以我想在我大三这一年，有计划有目标地进行学习！争取在一年后的今天能取得互联网大厂的 offer！ 大三规划：大方向：扎实内功，基础。深入底层逻辑，原理。追求技术深度。多总结，多学习。具体目标，步骤: 复习巩固计算机原理，数据结构等计算机基础。（巩固基础） leetcode 坚持每天刷题。（巩固基础） 学习 Node.js 以达到能够做出前后端分离的全栈完整项目。（完善自己的技术面） 学习 uniapp 或 flutter 以达到跨平台，多处运用的目的。（完善自己的技术面） 深入研究 Javascript，Vue 的底层逻辑，以及源码。以达到一定的技术深度。（提高自己技术深度） 多做项目，多参加比赛。提高自己的眼界，技术的多样性，学习别人的优点，改善自己的不足。（提高自己技术深度）","text":"大三这一年真的是无比关键.想着明年的今天就是我实习的日子.心里多少还是有些焦虑。 回顾自身：大一光顾着玩耍，等到大一暑假的时候突然感觉”玩的索然无味“玩的甚至有点空虚。觉得这不是自己想要的生活。于是放下了我喜欢的游戏。打开了哔哩哔哩，搜起了关于 Java 的教学视频，我还记着我第一次装 Jdk 第一次配置环境变量的时候的一脸懵逼。（这和我学的 C 不一样呀）好奇心促使我继续坚持学习了下去。就这样，我听着尚硅谷的宋红康老师的 Java 课程度过了第一个充实的暑假，也是在那个暑假，我渐渐地明白了，计算机的路，我才刚刚开始。等到了大二，我渐渐尝试着做一些简单的静态页面，跟着做一些简单的 JavaWeb 项目。当我第一次在我自己的数据库接收到前端页面发来的数据的时候，我真的无比激动！这真的是一件很有成就感的事情！到了大二的下学期，在好朋友的指引下，我渐渐接触一些更深层次的东西，我学习了 CoderWhy 老师的 Vue，学完了 Vue 我也深刻体会到组件化开发的便利性。真的佩服我们的尤大佬！能开发出这么好的框架！我什么时候才能到达他这种能力呀！大二这一年，是我学习进步最快的一年，我渐渐明白到了真正的差距到底有多大。所以我想在我大三这一年，有计划有目标地进行学习！争取在一年后的今天能取得互联网大厂的 offer！ 大三规划：大方向：扎实内功，基础。深入底层逻辑，原理。追求技术深度。多总结，多学习。具体目标，步骤: 复习巩固计算机原理，数据结构等计算机基础。（巩固基础） leetcode 坚持每天刷题。（巩固基础） 学习 Node.js 以达到能够做出前后端分离的全栈完整项目。（完善自己的技术面） 学习 uniapp 或 flutter 以达到跨平台，多处运用的目的。（完善自己的技术面） 深入研究 Javascript，Vue 的底层逻辑，以及源码。以达到一定的技术深度。（提高自己技术深度） 多做项目，多参加比赛。提高自己的眼界，技术的多样性，学习别人的优点，改善自己的不足。（提高自己技术深度）","categories":[{"name":"CodeLife","slug":"CodeLife","permalink":"http://oliverxuan.github.io/categories/CodeLife/"}],"tags":[{"name":"规划","slug":"规划","permalink":"http://oliverxuan.github.io/tags/%E8%A7%84%E5%88%92/"}]}],"categories":[{"name":"底层逻辑","slug":"底层逻辑","permalink":"http://oliverxuan.github.io/categories/%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/"},{"name":"练习题","slug":"练习题","permalink":"http://oliverxuan.github.io/categories/%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"name":"technology","slug":"technology","permalink":"http://oliverxuan.github.io/categories/technology/"},{"name":"Obstacle","slug":"Obstacle","permalink":"http://oliverxuan.github.io/categories/Obstacle/"},{"name":"CodeLife","slug":"CodeLife","permalink":"http://oliverxuan.github.io/categories/CodeLife/"},{"name":"Problems","slug":"Problems","permalink":"http://oliverxuan.github.io/categories/Problems/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://oliverxuan.github.io/tags/JavaScript/"},{"name":"vue","slug":"vue","permalink":"http://oliverxuan.github.io/tags/vue/"},{"name":"node.js","slug":"node-js","permalink":"http://oliverxuan.github.io/tags/node-js/"},{"name":"axios","slug":"axios","permalink":"http://oliverxuan.github.io/tags/axios/"},{"name":"项目","slug":"项目","permalink":"http://oliverxuan.github.io/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"规划","slug":"规划","permalink":"http://oliverxuan.github.io/tags/%E8%A7%84%E5%88%92/"},{"name":"leetcode","slug":"leetcode","permalink":"http://oliverxuan.github.io/tags/leetcode/"},{"name":"技术踩坑","slug":"技术踩坑","permalink":"http://oliverxuan.github.io/tags/%E6%8A%80%E6%9C%AF%E8%B8%A9%E5%9D%91/"}]}