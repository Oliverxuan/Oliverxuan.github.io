{"meta":{"title":"Oliver-xuan","subtitle":"记录我的程序员生涯","description":"","author":"Oliverxuan","url":"http://oliverxuan.github.io","root":"/"},"pages":[{"title":"标签","date":"2021-07-29T16:57:59.520Z","updated":"2021-07-29T16:57:59.520Z","comments":true,"path":"tags/index.html","permalink":"http://oliverxuan.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-07-29T16:58:11.125Z","updated":"2021-07-29T16:58:11.125Z","comments":true,"path":"categories/index.html","permalink":"http://oliverxuan.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-07-29T16:58:19.069Z","updated":"2021-07-29T16:58:19.069Z","comments":true,"path":"about/index.html","permalink":"http://oliverxuan.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"22/1/19 字节（抖音电商）前端实习生","slug":"22-1-19-字节（抖音电商）前端实习生","date":"2022-01-20T08:51:20.000Z","updated":"2022-01-20T09:01:16.024Z","comments":true,"path":"2022/01/20/22-1-19-字节（抖音电商）前端实习生/","link":"","permalink":"http://oliverxuan.github.io/2022/01/20/22-1-19-%E5%AD%97%E8%8A%82%EF%BC%88%E6%8A%96%E9%9F%B3%E7%94%B5%E5%95%86%EF%BC%89%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0%E7%94%9F/","excerpt":"1-19 字节（抖音电商）前端实习生一面（1h）1.盒子模型编程题123456.box &#123; background: red; &#125; .inner &#123; height: 20px; width: 20px; margin: 20px; &#125;body &#123; padding: 0; margin: 0; &#125;&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;&lt;/div&gt; 1.最后呈现什么样子？ 2.在哪里呈现（布局位置） 3.如何解决？（BFC） 2.经典作用域提升（fori var i= 0 结合 setTimeout（i），1000） 进行考察（1）输出是什么。 （2）为什么输出是这样，其中输出的时间间隔问题","text":"1-19 字节（抖音电商）前端实习生一面（1h）1.盒子模型编程题123456.box &#123; background: red; &#125; .inner &#123; height: 20px; width: 20px; margin: 20px; &#125;body &#123; padding: 0; margin: 0; &#125;&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;&lt;/div&gt; 1.最后呈现什么样子？ 2.在哪里呈现（布局位置） 3.如何解决？（BFC） 2.经典作用域提升（fori var i= 0 结合 setTimeout（i），1000） 进行考察（1）输出是什么。 （2）为什么输出是这样，其中输出的时间间隔问题 （3）如何将它变成 0-9 的输出，以及如何让他变成 0-9 中间隔 1000ms 进行输出。 3.uniApp 的原理？4.http，https 详细讲一下（问到 ca 证书内容，ca 证书如何保证唯一性，非对称加密原理，其中的一些细节问题，公钥，私钥如何生成，其中如何比对？优缺点。5.为什么要使用到 Vue Router，React Router ？平时怎么使用？Vue router 中的模式，history，hash 具体区别，优缺点。分别在前后端是怎么具体实现（应用）6.手写二叉树遍历。ps：还有的一些小问题就没写了。总之，这次面试算是一次很好的学习体验，能让我知道原来面试还可以这样。面试官抛出问题=&gt;输出结果=&gt;如何解决=&gt;如何改进=&gt;知识点细问 就比如，http，https 这道题，他先抛出，之间有什么区别，然后我开始巴拉巴拉，从什么超文本传输协议开始，比较两者不同，各自特点，穿插 http 无状态，cookie 这些，然后细讲 https，如何加密，加密过程就牵扯到了，ca 证书内容，非对称加密这些。 总结：问题：由于是我第一次面试，在各方的准备确实也有很多的不充分。很多的简单，细节性的问题真的是不应该犯错的。 很多时候，给自己挖坑，说的太多太细，然后面试官猛问。。。结果就暴露了自己了解的很浅显。 解决方案：停止我对技术广度的奢求，对技术深度开始钻研，特别是一些细节的问题，真的要自己从头到尾手写一遍，理解其中的为什么。","categories":[{"name":"字节","slug":"字节","permalink":"http://oliverxuan.github.io/categories/%E5%AD%97%E8%8A%82/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://oliverxuan.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"React-Music","slug":"React-Music","date":"2021-12-15T00:49:31.000Z","updated":"2021-12-15T01:56:33.280Z","comments":true,"path":"2021/12/15/React-Music/","link":"","permalink":"http://oliverxuan.github.io/2021/12/15/React-Music/","excerpt":"前言很长时间了，我都没有跟更新我的博客，我去做什么了呢？ 在这段时间里，我都在学习 React，完成了我第一个完整的 React 项目。是一个仿照网易云音乐的项目，实现了基本的功能，音乐播放等。 心得体会通过此次开发，我真的体会到了 React 的强大！也理解到为什么很多大厂选择 React。 React 真的给开发者带来了很高的自由度，Hooks，Redux 真的太好用了！我可以在 React 中轻松实现一些 Vue2.0 中不容易实现的逻辑。 React 哲学中有一条：All in js. 我可算深刻体会到了，Html 中可以写 JS Css 中也可以写 JS，真的太棒了。我从未体验过如此的便利。 React 的魅力真的太多，给开发者带来了很多惊喜。 我希望在以后我能深入研究 React 的源码，窥探 Facebook 程序员智慧的结晶。","text":"前言很长时间了，我都没有跟更新我的博客，我去做什么了呢？ 在这段时间里，我都在学习 React，完成了我第一个完整的 React 项目。是一个仿照网易云音乐的项目，实现了基本的功能，音乐播放等。 心得体会通过此次开发，我真的体会到了 React 的强大！也理解到为什么很多大厂选择 React。 React 真的给开发者带来了很高的自由度，Hooks，Redux 真的太好用了！我可以在 React 中轻松实现一些 Vue2.0 中不容易实现的逻辑。 React 哲学中有一条：All in js. 我可算深刻体会到了，Html 中可以写 JS Css 中也可以写 JS，真的太棒了。我从未体验过如此的便利。 React 的魅力真的太多，给开发者带来了很多惊喜。 我希望在以后我能深入研究 React 的源码，窥探 Facebook 程序员智慧的结晶。 React- music技术实现开发技术 本次开发还是比较全面,主要使用到：React Redux Hooks antd axios React-Router ImmutableJs . 数据状态管理项目全局使用 Redux 管理，使项目数据请求，存储，读取更加井井有条。 每个组件都有自己的 store，项目会有个总 store，将所有的组件 store combine 在一起。 网络请求项目使用 axios 来请求数据，配和 redux，redux- thunk 来管理数据。 路由​ 路由使用 react-router 配合 react-router-config 实现。 样式使用模块化的方式配合 styled-components 进行管理。 项目难点Redux state 状态管理src Storestore index（src/store)123456789import &#123; createStore, applyMiddleware, compose &#125; from &#x27;redux&#x27;import thunk from &#x27;redux-thunk&#x27;import reducer from &#x27;./reducer&#x27;const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || composeconst store = createStore(reducer, composeEnhancers(applyMiddleware(thunk)))export default store reducer (src/store/reducer)123456789101112import &#123; combineReducers &#125; from &#x27;redux-immutable&#x27;import &#123; reducer as recommendReducer &#125; from &#x27;../pages/discover/c-pages/recommend/store&#x27;import &#123; reducer as playerReducer &#125; from &#x27;../pages/player/store&#x27;//对组件store进行合并const cReducer = combineReducers(&#123; recommend: recommendReducer, player: playerReducer,&#125;)export default cReducer 组件 Store（recommend）constants1234567export const CHANGE_TOP_BANNNERS = &#x27;recommend/CHANGE_TOP_BANNNERS&#x27;export const CHANGE_HOT_RECOMMEND = &#x27;recommend/CHANGE_HOT_RECOMMEND&#x27;export const CHANGE_NEW_ALBUM = &#x27;recommend/CHANGE_NEW_ALBUM&#x27;export const CHANGE_UP_RANKING = &#x27;recommend/CHANGE_UP_RANKING&#x27;export const CHANGE_NEW_RANKING = &#x27;recommend/CHANGE_New_RANKING&#x27;export const CHANGE_ORIGIN_RANKING = &#x27;recommend/CHANGE_ORIGIN_RANKING&#x27; actionCreators12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485//导入常量import * as actionTypes from &#x27;./constants&#x27;//获取service中的请求方法import &#123; getTopBanners, getHotRecommends &#125; from &#x27;@/services/recommend&#x27;import &#123; getNewAlbums, getTopList &#125; from &#x27;../../../../../services/recommend&#x27;//当数据需要发生改变时的actionconst changeTopBannerAction = (res) =&gt; (&#123; type: actionTypes.CHANGE_TOP_BANNNERS, topBanners: res.banners,&#125;)const changeHotRecommendAction = (res) =&gt; (&#123; type: actionTypes.CHANGE_HOT_RECOMMEND, hotRecommends: res.result,&#125;)const changeNewAlbumAction = (res) =&gt; (&#123; type: actionTypes.CHANGE_NEW_ALBUM, newAlbums: res.albums,&#125;)const changeUpRankingAction = (res) =&gt; (&#123; type: actionTypes.CHANGE_UP_RANKING, upRanking: res.playlist,&#125;)const changeNewRankingAction = (res) =&gt; (&#123; type: actionTypes.CHANGE_NEW_RANKING, newRanking: res.playlist,&#125;)const changeOriginRankingAction = (res) =&gt; (&#123; type: actionTypes.CHANGE_ORIGIN_RANKING, originRanking: res.playlist,&#125;)//获取最新数据的actionexport const getTopBannerAction = () =&gt; &#123; //派发action return (dispatch) =&gt; &#123; //获取最新数据 res getTopBanners().then((res) =&gt; &#123; //派发action dispatch(changeTopBannerAction(res)) &#125;) &#125;&#125;export const getHotRecommendAction = (limit) =&gt; &#123; return (dispatch) =&gt; &#123; getHotRecommends(limit).then((res) =&gt; &#123; dispatch(changeHotRecommendAction(res)) &#125;) &#125;&#125;export const getNewAlbumsAction = (limit) =&gt; &#123; return (dispatch) =&gt; &#123; getNewAlbums(limit).then((res) =&gt; &#123; dispatch(changeNewAlbumAction(res)) &#125;) &#125;&#125;export const getTopListAction = (idx) =&gt; &#123; return (dispatch) =&gt; &#123; getTopList(idx).then((res) =&gt; &#123; switch (idx) &#123; case 0: dispatch(changeUpRankingAction(res)) break case 2: dispatch(changeNewRankingAction(res)) break case 3: dispatch(changeOriginRankingAction(res)) break default: &#125; &#125;) &#125;&#125; reducer12345678910111213141516171819202122232425262728293031323334353637383940414243//导入常量import * as actionTypes from &#x27;./constants&#x27;//immutable性能优化，减少拷贝时的内存浪费import &#123; Map &#125; from &#x27;immutable&#x27;//默认stateconst defaultState = Map(&#123; topBanners: [], hotRecommends: [], newAlbums: [], upRanking: &#123;&#125;, newRanking: &#123;&#125;, originRanking: &#123;&#125;,&#125;)//actionfunction reducer(state = defaultState, action) &#123; switch (action.type) &#123; //当action为CHANGE_TOP_BANNNERS时进行数据的存储 case actionTypes.CHANGE_TOP_BANNNERS: return state.set(&#x27;topBanners&#x27;, action.topBanners) case actionTypes.CHANGE_HOT_RECOMMEND: return state.set(&#x27;hotRecommends&#x27;, action.hotRecommends) case actionTypes.CHANGE_NEW_ALBUM: return state.set(&#x27;newAlbums&#x27;, action.newAlbums) case actionTypes.CHANGE_UP_RANKING: return state.set(&#x27;upRanking&#x27;, action.upRanking) case actionTypes.CHANGE_NEW_RANKING: return state.set(&#x27;newRanking&#x27;, action.newRanking) case actionTypes.CHANGE_ORIGIN_RANKING: return state.set(&#x27;originRanking&#x27;, action.originRanking) default: return state &#125;&#125;export default reducer indexstore 的入口 123import reducer from &#x27;./reducer&#x27;export &#123; reducer &#125; play-bar 的实现实现一个全局播放栏。 index123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143import React, &#123; memo, useCallback, useEffect, useRef, useState &#125; from &#x27;react&#x27;import &#123; PlaybarWrapper, Control, PlayInfo, Operator &#125; from &#x27;./style&#x27;import &#123; Slider &#125; from &#x27;antd&#x27;import &#123; getSongDetalAction &#125; from &#x27;../store/actionCreators&#x27;import &#123; shallowEqual, useDispatch, useSelector &#125; from &#x27;react-redux&#x27;import &#123; getSizeImage, formatDate, getPlaySong &#125; from &#x27;@/utils/format-utils&#x27;export default memo(function OXAppPlayerBar() &#123; //useState Hook 对变量进行管理 const [currentTime, setCurrentTime] = useState(0) const [progress, setProgress] = useState(0) const [isChange, setIsChange] = useState(false) const [isPlaying, setIsPlaying] = useState(false) //从store中拿到数据 const &#123; currentSong &#125; = useSelector( (state) =&gt; (&#123; currentSong: state.getIn([&#x27;player&#x27;, &#x27;currentSong&#x27;]), &#125;), //性能优化，使用浅比较 shallowEqual ) //一些字符拼接或常量处理 const picUrl = (currentSong.al &amp;&amp; currentSong.al.picUrl) || &#x27;&#x27; const singerName = (currentSong.al &amp;&amp; currentSong.ar[0].name) || &#x27;匿名&#x27; const duration = currentSong.dt || 0 const showDuration = formatDate(duration, &#x27;mm:ss&#x27;) const showCurrenttime = formatDate(currentTime, &#x27;mm:ss&#x27;) //useRef Hook 对组件进行绑定 const audioRef = useRef() //Store dispatch Hook 进行action的派发 const dispatch = useDispatch() //useEffect React生命周期管理Hook useEffect(() =&gt; &#123; dispatch(getSongDetalAction(428375722)) &#125;, [dispatch]) useEffect(() =&gt; &#123; audioRef.current.src = getPlaySong(currentSong.id) &#125;, [currentSong]) //useCallback 对回调函数的优化，当isPlaying发生改变的时候才会进行重新赋值，提升性能。 const playMusic = useCallback(() =&gt; &#123; isPlaying ? audioRef.current.pause() : audioRef.current.play() setIsPlaying(!isPlaying) &#125;, [isPlaying]) const timeUpdate = (e) =&gt; &#123; if (!isChange) &#123; setCurrentTime(e.target.currentTime * 1000) setProgress((currentTime / duration) * 100) &#125; &#125; const sliderChange = useCallback( (value) =&gt; &#123; setIsChange(true) const currentTime = (value / 100) * duration setCurrentTime(currentTime) setProgress(value) &#125;, [duration] ) const sliderAfterChange = useCallback( (value) =&gt; &#123; const currentTime = ((value / 100) * duration) / 1000 audioRef.current.currentTime = currentTime setCurrentTime(currentTime * 1000) setIsChange(false) if (!isPlaying) &#123; playMusic() &#125; &#125;, [duration, isPlaying, playMusic] ) return ( //styled-components className绑定样式 &lt;PlaybarWrapper className=&#x27;sprite_player&#x27;&gt; &lt;div className=&#x27;content wrap-v2&#x27;&gt; //对组件的style进行传值，在css中根据isPlaying的状态改变相应的css样式 &lt;Control isPlaying=&#123;isPlaying&#125;&gt; &lt;button className=&#x27;sprite_player prev&#x27;&gt;&lt;/button&gt; &lt;button className=&#x27;sprite_player play&#x27; onClick=&#123;(e) =&gt; playMusic()&#125; &gt;&lt;/button&gt; &lt;button className=&#x27;sprite_player next&#x27;&gt;&lt;/button&gt; &lt;/Control&gt; &lt;PlayInfo&gt; &lt;div className=&#x27;image&#x27;&gt; &lt;a href=&#x27;/#&#x27;&gt; &lt;img src=&#123;getSizeImage(picUrl, 35)&#125; alt=&#x27;&#x27; /&gt; &lt;/a&gt; &lt;/div&gt; &lt;div className=&#x27;info&#x27;&gt; &lt;div className=&#x27;song&#x27;&gt; &lt;span className=&#x27;song-name&#x27;&gt;&#123;currentSong.name&#125;&lt;/span&gt; &lt;a href=&#x27;/#&#x27; className=&#x27;singer-name&#x27;&gt; &#123;singerName&#125; &lt;/a&gt; &lt;/div&gt; &lt;div className=&#x27;progress&#x27;&gt; &lt;Slider defaultValue=&#123;30&#125; value=&#123;progress&#125; onChange=&#123;sliderChange&#125; onAfterChange=&#123;sliderAfterChange&#125; /&gt; &lt;div className=&#x27;time&#x27;&gt; &lt;span className=&#x27;now-time&#x27;&gt;&#123;showCurrenttime&#125;&lt;/span&gt; &lt;span className=&#x27;divider&#x27;&gt;/&lt;/span&gt; &lt;span className=&#x27;duration&#x27;&gt;&#123;showDuration&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/PlayInfo&gt; &lt;Operator&gt; &lt;div className=&#x27;left&#x27;&gt; &lt;button className=&#x27;sprite_player btn favor&#x27;&gt;&lt;/button&gt; &lt;button className=&#x27;sprite_player btn share&#x27;&gt;&lt;/button&gt; &lt;/div&gt; &lt;div className=&#x27;right sprite_player&#x27;&gt; &lt;button className=&#x27;sprite_player btn volume&#x27;&gt;&lt;/button&gt; &lt;button className=&#x27;sprite_player btn loop&#x27;&gt;&lt;/button&gt; &lt;button className=&#x27;sprite_player btn playlist&#x27;&gt;&lt;/button&gt; &lt;/div&gt; &lt;/Operator&gt; &lt;/div&gt; //绑定ref 对audio的属性进行动态管理 &lt;audio ref=&#123;audioRef&#125; onTimeUpdate=&#123;timeUpdate&#125; /&gt; &lt;/PlaybarWrapper&gt; )&#125;)","categories":[{"name":"技术实现","slug":"技术实现","permalink":"http://oliverxuan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/"}],"tags":[{"name":"React","slug":"React","permalink":"http://oliverxuan.github.io/tags/React/"}]},{"title":"Js常用工具实现","slug":"Js常用工具实现","date":"2021-11-29T10:25:55.000Z","updated":"2021-11-29T11:17:49.826Z","comments":true,"path":"2021/11/29/Js常用工具实现/","link":"","permalink":"http://oliverxuan.github.io/2021/11/29/Js%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0/","excerpt":"在 Js 中，我们常常会去手写一些工具来帮助我们的日常开发。这里我将记录：防抖，节流，Promise，深拷贝的实现。 debounce（防抖函数）如果我们遇到一个监听到事件发生响应时，我们需要发送一次网络请求，但是如果此事件在短时间内频繁发生，我们想要规定一个时间内不管发生多少次，我们都只发送一次请求。我们将使用到防抖函数。 简单实现：1234567891011121314151617function debounce(fn, delay) &#123; // 1.定义一个定时器, 保存上一次的定时器 let timer = null // 2.真正执行的函数 const _debounce = function (...args) &#123; // 取消上一次的定时器 if (timer) clearTimeout(timer) // 延迟执行 timer = setTimeout(() =&gt; &#123; // 外部传入的真正要执行的函数 fn.apply(this, args) &#125;, delay) &#125; return _debounce&#125; 基本实现：实现 立即执行，取消执行。 1234567891011121314151617181920212223242526272829function debounce(fn, delay, immediate = false) &#123; let timer = null let isInvoke = false function _debounce(...args) &#123; if (timmer) &#123; clearTimeout(timer) &#125; if (immediate &amp;&amp; !isInvoke) &#123; fn.apply(this, ...args) isInvoke = true &#125; else &#123; timer = setTimeout(() =&gt; &#123; fn.apply(this, ...args) isInvoke = false &#125;, delay) &#125; &#125; _debounce.cancel = function () &#123; if (timer) &#123; clearTimeout(timer) &#125; timer = null isInvoke = false &#125; return _debounce&#125; throttle （节流函数）同上，但是我们只需要在一段时间内，只回答一次，如果没到时间就不回答。","text":"在 Js 中，我们常常会去手写一些工具来帮助我们的日常开发。这里我将记录：防抖，节流，Promise，深拷贝的实现。 debounce（防抖函数）如果我们遇到一个监听到事件发生响应时，我们需要发送一次网络请求，但是如果此事件在短时间内频繁发生，我们想要规定一个时间内不管发生多少次，我们都只发送一次请求。我们将使用到防抖函数。 简单实现：1234567891011121314151617function debounce(fn, delay) &#123; // 1.定义一个定时器, 保存上一次的定时器 let timer = null // 2.真正执行的函数 const _debounce = function (...args) &#123; // 取消上一次的定时器 if (timer) clearTimeout(timer) // 延迟执行 timer = setTimeout(() =&gt; &#123; // 外部传入的真正要执行的函数 fn.apply(this, args) &#125;, delay) &#125; return _debounce&#125; 基本实现：实现 立即执行，取消执行。 1234567891011121314151617181920212223242526272829function debounce(fn, delay, immediate = false) &#123; let timer = null let isInvoke = false function _debounce(...args) &#123; if (timmer) &#123; clearTimeout(timer) &#125; if (immediate &amp;&amp; !isInvoke) &#123; fn.apply(this, ...args) isInvoke = true &#125; else &#123; timer = setTimeout(() =&gt; &#123; fn.apply(this, ...args) isInvoke = false &#125;, delay) &#125; &#125; _debounce.cancel = function () &#123; if (timer) &#123; clearTimeout(timer) &#125; timer = null isInvoke = false &#125; return _debounce&#125; throttle （节流函数）同上，但是我们只需要在一段时间内，只回答一次，如果没到时间就不回答。 12345678910111213function throttle(fn, interval) &#123; let lastTime = 0 const _throttle = function () &#123; const nowTime = new Date().getTime() const reaminTime = interval - (nowTime - lastTime) if (reaminTime &lt;= 0) &#123; fn() lastTime = nowTime &#125; &#125; return _throttle&#125; PromisePromise 可以说是解决了很多的问题，能帮助我们清晰化代码，避开回调地狱。更好地去处理异步操作。 简单实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const PENDING = &#x27;pending&#x27;const FULFILLED = &#x27;fulfilled&#x27;const REJECTED = &#x27;rejected&#x27;class myPromise &#123; constructor(executor) &#123; this.status = PENDING this.value = undefined this.reason = undefined const resolve = (value) =&gt; &#123; if (this.status === PENDING) &#123; this.status = FULFILLED queueMicrotask(() =&gt; &#123; this.value = value this.onfulfilled(this.value) &#125;) &#125; &#125; const reject = (reason) =&gt; &#123; if (this.status === PENDING) &#123; this.status = REJECTED queueMicrotask(() =&gt; &#123; this.reason = reason this.onrejected(this.reason) &#125;) &#125; &#125; executor(resolve, reject) &#125; then(onfulfilled, onrejected) &#123; this.onfulfilled = onfulfilled this.onrejected = onrejected &#125;&#125;const promise = new myPromise((resolve, reject) =&gt; &#123; reject(321) resolve(123)&#125;)promise.then( (res) =&gt; &#123; console.log(res) &#125;, (err) =&gt; &#123; console.log(err) &#125;) 基本实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211const PROMISE_STATUS_PENDING = &#x27;pending&#x27;const PROMISE_STATUS_FULFILLED = &#x27;fulfilled&#x27;const PROMISE_STATUS_REJECTED = &#x27;rejected&#x27;// 工具函数function execFunctionWithCatchError(execFn, value, resolve, reject) &#123; try &#123; const result = execFn(value) resolve(result) &#125; catch (err) &#123; reject(err) &#125;&#125;class HYPromise &#123; constructor(executor) &#123; this.status = PROMISE_STATUS_PENDING this.value = undefined this.reason = undefined this.onFulfilledFns = [] this.onRejectedFns = [] const resolve = (value) =&gt; &#123; if (this.status === PROMISE_STATUS_PENDING) &#123; // 添加微任务 queueMicrotask(() =&gt; &#123; if (this.status !== PROMISE_STATUS_PENDING) return this.status = PROMISE_STATUS_FULFILLED this.value = value this.onFulfilledFns.forEach((fn) =&gt; &#123; fn(this.value) &#125;) &#125;) &#125; &#125; const reject = (reason) =&gt; &#123; if (this.status === PROMISE_STATUS_PENDING) &#123; // 添加微任务 queueMicrotask(() =&gt; &#123; if (this.status !== PROMISE_STATUS_PENDING) return this.status = PROMISE_STATUS_REJECTED this.reason = reason this.onRejectedFns.forEach((fn) =&gt; &#123; fn(this.reason) &#125;) &#125;) &#125; &#125; try &#123; executor(resolve, reject) &#125; catch (err) &#123; reject(err) &#125; &#125; then(onFulfilled, onRejected) &#123; const defaultOnRejected = (err) =&gt; &#123; throw err &#125; onRejected = onRejected || defaultOnRejected const defaultOnFulfilled = (value) =&gt; &#123; return value &#125; onFulfilled = onFulfilled || defaultOnFulfilled return new HYPromise((resolve, reject) =&gt; &#123; // 1.如果在then调用的时候, 状态已经确定下来 if (this.status === PROMISE_STATUS_FULFILLED &amp;&amp; onFulfilled) &#123; execFunctionWithCatchError(onFulfilled, this.value, resolve, reject) &#125; if (this.status === PROMISE_STATUS_REJECTED &amp;&amp; onRejected) &#123; execFunctionWithCatchError(onRejected, this.reason, resolve, reject) &#125; // 2.将成功回调和失败的回调放到数组中 if (this.status === PROMISE_STATUS_PENDING) &#123; if (onFulfilled) this.onFulfilledFns.push(() =&gt; &#123; execFunctionWithCatchError(onFulfilled, this.value, resolve, reject) &#125;) if (onRejected) this.onRejectedFns.push(() =&gt; &#123; execFunctionWithCatchError(onRejected, this.reason, resolve, reject) &#125;) &#125; &#125;) &#125; catch(onRejected) &#123; return this.then(undefined, onRejected) &#125; finally(onFinally) &#123; this.then( () =&gt; &#123; onFinally() &#125;, () =&gt; &#123; onFinally() &#125; ) &#125; static resolve(value) &#123; return new HYPromise((resolve) =&gt; resolve(value)) &#125; static reject(reason) &#123; return new HYPromise((resolve, reject) =&gt; reject(reason)) &#125; static all(promises) &#123; // 问题关键: 什么时候要执行resolve, 什么时候要执行reject return new HYPromise((resolve, reject) =&gt; &#123; const values = [] promises.forEach((promise) =&gt; &#123; promise.then( (res) =&gt; &#123; values.push(res) if (values.length === promises.length) &#123; resolve(values) &#125; &#125;, (err) =&gt; &#123; reject(err) &#125; ) &#125;) &#125;) &#125; static allSettled(promises) &#123; return new HYPromise((resolve) =&gt; &#123; const results = [] promises.forEach((promise) =&gt; &#123; promise.then( (res) =&gt; &#123; results.push(&#123; status: PROMISE_STATUS_FULFILLED, value: res &#125;) if (results.length === promises.length) &#123; resolve(results) &#125; &#125;, (err) =&gt; &#123; results.push(&#123; status: PROMISE_STATUS_REJECTED, value: err &#125;) if (results.length === promises.length) &#123; resolve(results) &#125; &#125; ) &#125;) &#125;) &#125; static race(promises) &#123; return new HYPromise((resolve, reject) =&gt; &#123; promises.forEach((promise) =&gt; &#123; // promise.then(res =&gt; &#123; // resolve(res) // &#125;, err =&gt; &#123; // reject(err) // &#125;) promise.then(resolve, reject) &#125;) &#125;) &#125; static any(promises) &#123; // resolve必须等到有一个成功的结果 // reject所有的都失败才执行reject const reasons = [] return new HYPromise((resolve, reject) =&gt; &#123; promises.forEach((promise) =&gt; &#123; promise.then(resolve, (err) =&gt; &#123; reasons.push(err) if (reasons.length === promises.length) &#123; reject(new AggregateError(reasons)) &#125; &#125;) &#125;) &#125;) &#125;&#125;const p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(1111) &#125;, 3000)&#125;)const p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(2222) &#125;, 2000)&#125;)const p3 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(3333) &#125;, 3000)&#125;)HYPromise.any([p1, p2, p3]) .then((res) =&gt; &#123; console.log(&#x27;res:&#x27;, res) &#125;) .catch((err) =&gt; &#123; console.log(&#x27;err:&#x27;, err.errors) &#125;)// code by -coderwhy 深拷贝不仅仅是把对象中的值拷贝，其中的引用类型也要重新开一个地址来保存，不与旧对象之间发生冲突。 JSON 实现JSON 可以快速实现深拷贝，但是会有很多弊端，如：Symbol，循环引用… 123456789101112131415161718192021222324252627282930313233343536373839const obj = &#123; name: &#x27;oliver&#x27;, age: 12, [s2]: &#x27;123&#x27;, friends: &#123; name: &#x27;kobe&#x27;, city: &#x27;chengdu&#x27;, mo: [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;], like: &#123; type: &#x27;egg&#x27;, mo: [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;], &#125;, eat: function (num1, num2) &#123; console.log(num1 + num2) &#125;, &#125;,&#125;//JSON实现深拷贝const newObj = JSON.parse(JSON.stringify(obj))console.log(obj === newObj)obj.friends.name = &#x27;Kobe&#x27;console.log(obj)console.log(newObj)//false// &#123;// name: &#x27;oliver&#x27;,// age: 12,// friends: &#123;// name: &#x27;kobe&#x27;,// city: &#x27;chengdu&#x27;,// mo: [ &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27; ],// like: &#123; type: &#x27;egg&#x27;, mo: [Array] &#125;// &#125;// &#125;// +++++++++ 手写实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//判断是否为对象 工具function isObject(value) &#123; const valueType = typeof value return value !== null &amp;&amp; (valueType === &#x27;object&#x27; || valueType == &#x27;function&#x27;)&#125;//传值的时候为其新建一个WeakMap 实现循环引用function deepClone(originValue, map = new WeakMap()) &#123; //判断是否为Set类型 if (originValue instanceof Set) &#123; return new Set([...originValue]) &#125; //判断是否为Map类型 if (originValue instanceof Map) &#123; return new Map([...originValue]) &#125; //判断是否为Symbol类型 if (typeof originValue === &#x27;symbol&#x27;) &#123; return Symbol(originValue.description) &#125; //判断是否为函数 if (typeof originValue === &#x27;function&#x27;) &#123; return originValue &#125; //判断是否为对象类型 if (!isObject(originValue)) &#123; return originValue &#125; //判断map中是否已存在已有originValue对象，防止循环对象实现时栈溢出。 if (map.has(originValue)) &#123; //如果有直接返回 不用再新建 return map.get(originValue) &#125; //判断是否为数组 const newObj = Array.isArray(originValue) ? [] : &#123;&#125; map.set(originValue, newObject) //对其进行深拷贝，递归调用。 for (const key in originValue) &#123; newObj[key] = deepClone(originValue[key], map) &#125; //由于Symbol无法通过上方法调用，则使用Object.getOwnPropertySymbols const symbolKeys = Object.getOwnPropertySymbols(originValue) for (const Skey of symbolKeys) &#123; newObj[Skey] = deepClone(originValue[Skey], map) &#125; return newObj&#125;const OliverObj = deepClone(obj)console.log(OliverObj === obj)obj.friends.name = &#x27;Kobessss&#x27;console.log(OliverObj)","categories":[{"name":"底层逻辑","slug":"底层逻辑","permalink":"http://oliverxuan.github.io/categories/%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://oliverxuan.github.io/tags/JavaScript/"}]},{"title":"响应式原理实现","slug":"响应式原理实现","date":"2021-11-11T10:34:06.000Z","updated":"2021-11-11T10:48:18.554Z","comments":true,"path":"2021/11/11/响应式原理实现/","link":"","permalink":"http://oliverxuan.github.io/2021/11/11/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0/","excerpt":"我们刚学习了 ES6 中的许多新特性，还有 Proxy，Reflect 的用法。刚好，我们可以通过手写响应式原理的方法，来复习巩固一下所学的真知识。 Proxy - Reflect 响应式的实现Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//全局中的收集依赖变量let activeReactFn = null//封装depend依赖类class Depend &#123; constructor() &#123; //创建自己的函数执行Set //此处用Set是为了重复添加 this.reactiveFns = new Set() &#125; //依赖函数的添加 depend() &#123; if (activeReactFn) &#123; this.reactiveFns.add(activeReactFn) &#125; &#125; //执行函数 notify() &#123; this.reactiveFns.forEach((fn) =&gt; &#123; fn() &#125;) &#125;&#125;//封装响应式函数function watchFn(fn) &#123; activeReactFn = fn fn() activeReactFn = null&#125;watchFn(() =&gt; &#123; console.log(&#x27;执行操作AAAAAA&#x27;)&#125;)watchFn(() =&gt; &#123; console.log(&#x27;执行操作BBBBBB&#x27;)&#125;)//创建WeakMap来建立顶层依赖const targetMap = new WeakMap()//具体对象属性之间的依赖用Map创建function getDepend(target, key) &#123; //将目前的WeakMap节点提出，查看有没有以对象为节点的Map。若没有则创建. let map = targetMap.get(target) if (!map) &#123; map = new Map() //新建对象下的依赖结构 targetMap.set(target, map) &#125; //建立属性的map依赖结构 let depend = map.get(key) if (!depend) &#123; depend = new Depend() map.set(key, depend) &#125; return depend&#125;//基础对象const obj = &#123; name: &#x27;Oliver&#x27;, age: 18,&#125;const objProxy = new Proxy(obj, &#123; get: function (target, key, receiver) &#123; //创建自己的依赖对象 const depend = getDepend(target, key) //添加依赖 depend.depend() return Reflect.get(target, key, receiver) &#125;, set: function (target, key, newValue, recriver) &#123; Reflect.set(target, key, newValue, recriver) const depend = getDepend(target, key) //执行依赖 depend.notify() &#125;,&#125;)//try 1objProxy.name = &#x27;Xuan&#x27;//try 2//// watchFn(() =&gt; &#123;// console.log(`执行操作AAAAAA$&#123;objProxy.name&#125;`)// &#125;)// watchFn(() =&gt; &#123;// console.log(`执行操作BBBBBB$&#123;objProxy.name&#125;`)// &#125;) console:​ 12345678910//try 1执行操作AAAAAA执行操作BBBBBB//try 2//由于此处我们调用了objProxy.name depend中会再执行一次 所以为double执行操作AAAAAAOliver执行操作BBBBBBOliver执行操作AAAAAAXuan执行操作BBBBBBXuan 由于代码量比较大，我直接在代码中进行注释讲解。","text":"我们刚学习了 ES6 中的许多新特性，还有 Proxy，Reflect 的用法。刚好，我们可以通过手写响应式原理的方法，来复习巩固一下所学的真知识。 Proxy - Reflect 响应式的实现Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//全局中的收集依赖变量let activeReactFn = null//封装depend依赖类class Depend &#123; constructor() &#123; //创建自己的函数执行Set //此处用Set是为了重复添加 this.reactiveFns = new Set() &#125; //依赖函数的添加 depend() &#123; if (activeReactFn) &#123; this.reactiveFns.add(activeReactFn) &#125; &#125; //执行函数 notify() &#123; this.reactiveFns.forEach((fn) =&gt; &#123; fn() &#125;) &#125;&#125;//封装响应式函数function watchFn(fn) &#123; activeReactFn = fn fn() activeReactFn = null&#125;watchFn(() =&gt; &#123; console.log(&#x27;执行操作AAAAAA&#x27;)&#125;)watchFn(() =&gt; &#123; console.log(&#x27;执行操作BBBBBB&#x27;)&#125;)//创建WeakMap来建立顶层依赖const targetMap = new WeakMap()//具体对象属性之间的依赖用Map创建function getDepend(target, key) &#123; //将目前的WeakMap节点提出，查看有没有以对象为节点的Map。若没有则创建. let map = targetMap.get(target) if (!map) &#123; map = new Map() //新建对象下的依赖结构 targetMap.set(target, map) &#125; //建立属性的map依赖结构 let depend = map.get(key) if (!depend) &#123; depend = new Depend() map.set(key, depend) &#125; return depend&#125;//基础对象const obj = &#123; name: &#x27;Oliver&#x27;, age: 18,&#125;const objProxy = new Proxy(obj, &#123; get: function (target, key, receiver) &#123; //创建自己的依赖对象 const depend = getDepend(target, key) //添加依赖 depend.depend() return Reflect.get(target, key, receiver) &#125;, set: function (target, key, newValue, recriver) &#123; Reflect.set(target, key, newValue, recriver) const depend = getDepend(target, key) //执行依赖 depend.notify() &#125;,&#125;)//try 1objProxy.name = &#x27;Xuan&#x27;//try 2//// watchFn(() =&gt; &#123;// console.log(`执行操作AAAAAA$&#123;objProxy.name&#125;`)// &#125;)// watchFn(() =&gt; &#123;// console.log(`执行操作BBBBBB$&#123;objProxy.name&#125;`)// &#125;) console:​ 12345678910//try 1执行操作AAAAAA执行操作BBBBBB//try 2//由于此处我们调用了objProxy.name depend中会再执行一次 所以为double执行操作AAAAAAOliver执行操作BBBBBBOliver执行操作AAAAAAXuan执行操作BBBBBBXuan 由于代码量比较大，我直接在代码中进行注释讲解。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://oliverxuan.github.io/categories/ES6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://oliverxuan.github.io/tags/JavaScript/"}]},{"title":"Proxy-Reflect","slug":"Proxy-Reflect","date":"2021-11-11T10:32:47.000Z","updated":"2021-11-11T10:33:11.614Z","comments":true,"path":"2021/11/11/Proxy-Reflect/","link":"","permalink":"http://oliverxuan.github.io/2021/11/11/Proxy-Reflect/","excerpt":"Proxy - Reflect我们先来看一个案例，在以前，我们想要监听对象中属性的改变的时候，我们会想到使用以下方法。 12345678910Object.defineProperty(obj, key, &#123; get: function () &#123; console.log(`监听到obj对象的$&#123;key&#125;属性被访问了`) return value &#125;, set: function (newValue) &#123; console.log(`监听到obj对象的$&#123;key&#125;属性被设置值`) value = newValue &#125;,&#125;) 我们可以使用 Object.defineProperty，通过定义 get，set 达到目的。 但是这并不是一种好的方式，Object.defineProperty 的设计初衷也不是如此。Object 的方法累积的越来越多…. 现在我们可以使用 Proxy - Reflect（代理，反射）来优雅地实现相关需求。 ProxyProxy 直译：代理。我们可以把它看作是一个镜像。该函数的使用理念就是：通过镜像一个对象，成为该对象的代理。Proxy 就可以代替原对象进行一些“捕捉活动”。例如，监听用户的 get/set 操作，并作出**响应式**的反应。 示例123456789101112131415161718const obj = &#123; name: &#x27;Oliver&#x27;, age: 18,&#125;const objProxy = new Proxy(obj, &#123; get: function (target, key) &#123; console.log(`$&#123;key&#125;属性的取值操作`) return target[key] &#125;, set: function (target, key, newValue) &#123; console.log(`$&#123;key&#125;属性赋值操作`) target[key] = newValue &#125;,&#125;)objProxy.name = &#x27;Xuan&#x27;console.log(&#x27;objProxy： &#x27; + objProxy.name)","text":"Proxy - Reflect我们先来看一个案例，在以前，我们想要监听对象中属性的改变的时候，我们会想到使用以下方法。 12345678910Object.defineProperty(obj, key, &#123; get: function () &#123; console.log(`监听到obj对象的$&#123;key&#125;属性被访问了`) return value &#125;, set: function (newValue) &#123; console.log(`监听到obj对象的$&#123;key&#125;属性被设置值`) value = newValue &#125;,&#125;) 我们可以使用 Object.defineProperty，通过定义 get，set 达到目的。 但是这并不是一种好的方式，Object.defineProperty 的设计初衷也不是如此。Object 的方法累积的越来越多…. 现在我们可以使用 Proxy - Reflect（代理，反射）来优雅地实现相关需求。 ProxyProxy 直译：代理。我们可以把它看作是一个镜像。该函数的使用理念就是：通过镜像一个对象，成为该对象的代理。Proxy 就可以代替原对象进行一些“捕捉活动”。例如，监听用户的 get/set 操作，并作出**响应式**的反应。 示例123456789101112131415161718const obj = &#123; name: &#x27;Oliver&#x27;, age: 18,&#125;const objProxy = new Proxy(obj, &#123; get: function (target, key) &#123; console.log(`$&#123;key&#125;属性的取值操作`) return target[key] &#125;, set: function (target, key, newValue) &#123; console.log(`$&#123;key&#125;属性赋值操作`) target[key] = newValue &#125;,&#125;)objProxy.name = &#x27;Xuan&#x27;console.log(&#x27;objProxy： &#x27; + objProxy.name) 用法 首先，我们需要通过 Proxy 创建一个代理对象 objProxy。 1const objProxy = new Proxy(obj, &#123;&#125;) 在 Proxy 的第一个参数中传入需要代理的对象（也可以是函数） 在第二个参数中写入一个对象，其中包含需要的捕获器。 1234const objProxy = new Proxy(obj, &#123; get: function (target, key) &#123;&#125;, set: function (target, key, newValue) &#123;&#125;,&#125;) 捕获器参数： target：传入的对象 key：传入对象的属性 newValue：传入的新值 receiver：新建的代理对象。 值当我们对代理对象进行操作的时候，原对象属性的值也会发生改变。通过该方法，我们可以间接地去实现一些开发需求。 常用的捕获器 Reflect当我们单独使用 Proxy 的时候，还是没有完美解决问题，就像这段代码中，我们还是拿到原对象进行返回，或者直接赋值。 12345678910get: function (target, key) &#123; console.log(`$&#123;key&#125;属性的取值操作`) //！ return target[key] &#125;, set: function (target, key, newValue) &#123; console.log(`$&#123;key&#125;属性赋值操作`) //！ target[key] = newValue &#125;, 此处，我们是使用语法逻辑的方式，将代码逻辑进行了实现。这并不是我们的初衷。 此时我们就需要 Reflect。 示例123456789101112131415const obj = &#123; name: &#x27;Oliver&#x27;, age: 18,&#125;const objProxy = new Proxy(obj, &#123; get: function (target, key, receiver) &#123; console.log(`$&#123;key&#125;属性的取值操作`) return Reflect.get(target, key, receiver) &#125;, set: function (target, key, newValue, receiver) &#123; console.log(`$&#123;key&#125;属性赋值操作`) Reflect.set(target, key, newValue, receiver) &#125;,&#125;) 此处，还是上面的逻辑，但是我们可以看见，此处我们使用了 Reflect: 1Reflect.get(target, key, receiver) 用法其中，Reflect 是一个对象，我们在进行调用的时候，也需要像 obj.的方式去调用 Reflect 中的构造器。 值值与 Proxy 中的相似。只是一些 Reflect 会有返回值。如 get，Reflect.get 后就会返回该属性值 常用的捕获器","categories":[{"name":"底层逻辑","slug":"底层逻辑","permalink":"http://oliverxuan.github.io/categories/%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://oliverxuan.github.io/tags/JavaScript/"}]},{"title":"ES6新特性合集(一)","slug":"ES6新特性合集-一","date":"2021-11-07T08:02:59.000Z","updated":"2021-11-07T08:05:51.265Z","comments":true,"path":"2021/11/07/ES6新特性合集-一/","link":"","permalink":"http://oliverxuan.github.io/2021/11/07/ES6%E6%96%B0%E7%89%B9%E6%80%A7%E5%90%88%E9%9B%86-%E4%B8%80/","excerpt":"模版字符串在 ES6 之前，我们常使用以下的方式拼接字符串，这显得效率十分低，且代码可读性不高。 1console.log(&#x27;my name is &#x27; + name + &#x27;, age is &#x27; + age + &#x27;, height is &#x27; + height) 在 ES6 中，我们可以使用模版字符串来更好的拼接字符串。 ES6 提供模板字符串 ```` 是键盘 tab 键上方的那个按键，和以往的“ “，’‘，是不一样的！ 基础拼接我们尝试拼接上面的案例，使用模版字符串十分便利。 123456const name = &#x27;Oliver&#x27;const age = 18const height = 1.88//注意使用的是``，且数据的引用所使用的是$&#123;&#125;const message = `my name is $&#123;name&#125;, age is $&#123;age&#125;, height is $&#123;height&#125;`console.log(message) 在此处，我们注意到，想要引用某个数据，我们需要使用到``与${}这两个定义符号。","text":"模版字符串在 ES6 之前，我们常使用以下的方式拼接字符串，这显得效率十分低，且代码可读性不高。 1console.log(&#x27;my name is &#x27; + name + &#x27;, age is &#x27; + age + &#x27;, height is &#x27; + height) 在 ES6 中，我们可以使用模版字符串来更好的拼接字符串。 ES6 提供模板字符串 ```` 是键盘 tab 键上方的那个按键，和以往的“ “，’‘，是不一样的！ 基础拼接我们尝试拼接上面的案例，使用模版字符串十分便利。 123456const name = &#x27;Oliver&#x27;const age = 18const height = 1.88//注意使用的是``，且数据的引用所使用的是$&#123;&#125;const message = `my name is $&#123;name&#125;, age is $&#123;age&#125;, height is $&#123;height&#125;`console.log(message) 在此处，我们注意到，想要引用某个数据，我们需要使用到``与${}这两个定义符号。 使用``说明了我们使用的是模版字符串，${}说明了我们这里需要拼接一些量，或者应用其他东西。 高级拼接我们不仅仅可以将值拼接，我们也可以加以修饰，加工。 1234567891011121314const age = 18//对数据进行加工，简单的运算操作const info = `age double is $&#123;age * 2&#125;`console.log(info)//定义double函数function doubleAge() &#123; return age * 2&#125;//在模版字符串中同样可以调用const info2 = `double age is $&#123;doubleAge()&#125;`console.log(info2) 在这里我们看到，也同样可以在模版字符串中执行函数，并拼接函数返回值。 标签模版字符串该特性，在实际开发的应用不是很多，但是在一些框架如 React 又很多的应用。我们在这里简单介绍。 123456function foo(x, y, z, w) &#123; console.log(x, y, z, w, &#x27;------&#x27;)&#125;foo`first$&#123;1&#125;second$&#123;2&#125;third$&#123;3&#125;4th`//[ &#x27;first&#x27;, &#x27;second&#x27;, &#x27;third&#x27;, &#x27;4th&#x27; ] 1 2 3 ------ 当我们使用``的方式同样也可以调用函数，并传值给函数。${}会分割模版字符串中的字符串。 函数的默认参数ES5 之前的实现方法当我们想给函数一个默认参数的时候，我们之前的做法是： 123456function foo(m, n) &#123; m = m || &#x27;aaa&#x27; n = n || &#x27;bbb&#x27; console.log(m, n)&#125; 缺点也很明显：代码的阅读性是比较差，容易产生 bug。 ES6 中的默认参数函数默认参数123456//直接在传参的时候赋予一个默认的值。function foo(x = 100, y = 300) &#123; console.log(`$&#123;x&#125;is x,$&#123;y&#125; is y`)&#125;foo(999)// 999is x,300 is y 对象参数1234567891011121314151617function foo(obj = &#123; name: &#x27;Oliver&#x27;, age: 18 &#125;) &#123; console.log(obj)&#125;const NoObj = fooNoObj()const obj = &#123; name: &#x27;Xuan&#x27;, age: 22,&#125;foo(obj)//&#123; name: &#x27;Oliver&#x27;, age: 18 &#125;//&#123; name: &#x27;Xuan&#x27;, age: 22 &#125; note 有默认参数的最好放在最后一位。 有默认参数的 foo.length 属性，默认参数不包含在其中。 函数的剩余参数我们可以定义一个函数，接收为止个数的参数。其中剩余的参数会被…接收，并创建一个新的数组。 123456function foo(x, y, z, ...newArr) &#123; console.log(x, y, z) console.log(newArr)&#125;foo(1, 2, 3, 4, 5, 56, 6, 6, 6) arguments获取所有的参数。 arguments 是 ES6 之前解决该问题的解决方案。但是并不是很推荐使用。 arguments 并不是一个真正意义上的数组。很多数组的方法他并不能使用，我们这还是建议使用 rest args （…args）的方式。 1234567891011function foo(x, y, z, ...newArr) &#123; console.log(x, y, z) console.log(newArr) console.log(arguments)&#125;foo(1, 2, 3, 4, 5, 6, 7)//1 2 3//[ 4, 5, 6, 7 ]//[Arguments] &#123; &#x27;0&#x27;: 1, &#x27;1&#x27;: 2, &#x27;2&#x27;: 3, &#x27;3&#x27;: 4, &#x27;4&#x27;: 5, &#x27;5&#x27;: 6, &#x27;6&#x27;: 7 &#125; 展开语法我们常常在开发中需要将数组中的一些值，或者对象里的属性提取出来。此时我们可以使用展开语法，将其中的元素提出来。 1234567891011121314151617181920const names = [&#x27;abc&#x27;, &#x27;cba&#x27;, &#x27;nba&#x27;]const name = &#x27;Oliver&#x27;const info = &#123; name: &#x27;Oliver&#x27;, age: 18 &#125;function foo(x, y, z) &#123; console.log(x, y, z)&#125;foo(...names)const obj = &#123; ...info, name: &#x27;Xuan&#x27;, ...names,&#125;console.log(obj)//abc cba nba//&#123; &#x27;0&#x27;: &#x27;abc&#x27;, &#x27;1&#x27;: &#x27;cba&#x27;, &#x27;2&#x27;: &#x27;nba&#x27;, name: &#x27;Xuan&#x27;, age: 18 &#125; 展开语法-浅拷贝浅拷贝：创建一个新对象，这个对象对原始对象的属性值有着一份精确的拷贝。如果属性是基本类型数据，拷贝的就是基本类型的值，改变原始数据属性，新对象属性不会发生改变；如果属性是引用类型，那么就是拷贝的这个属性的内存地址，如果属性值发生改变，就会影响到原始对象。 –csdn 我的理解：创建一个新的对象，将目标对象中的数据（内存地址）进行拷贝，当新对象中的属性值发生改变的时候，目标对象（被拷贝的对象）中相对应的值也会发生改变。因为浅拷贝实际上只是将内存地址给拷贝过来了，并没有在内存中新开辟一块区域来放置新的对象，所有的操作都是在目标对象的基础上进行操作的。所以当新的对象中的属性发生改变的时候，目标对象（原对象）中的属性也会发生改变。 在展开语法中就是使用的浅拷贝。 12345678910111213141516171819202122const obj = &#123; name: &#x27;obj&#x27;, age: 18, friends: &#123; name: &#x27;Oliver&#x27;, &#125;,&#125;const newObj = &#123; ...obj, name: &#x27;newObj&#x27;,&#125;//对新对象中的 friends属性进行修改newObj.friends.name = &#x27;New!&#x27;//可以在打印中发现，obj中的friends属性也发生了改变，从而验证了是浅拷贝。console.log(newObj)console.log(obj)//&#123; name: &#x27;newObj&#x27;, age: 18, friends: &#123; name: &#x27;New!&#x27; &#125; &#125;//&#123; name: &#x27;obj&#x27;, age: 18, friends: &#123; name: &#x27;New!&#x27; &#125; &#125; 进制数值表达方式十进制1const num1 = 100 二进制（ b -&gt; binary）1const num2 = 0b100 八进制（o -&gt; octonary）1const num1 = 100 十六进制（x -&gt; hexadecimal）1const num1 = 100 大的数值的连接符(ES2021 ES12)1const num = 10_000_000_000_000_000 Symbol 基本使用Symbol 是 ES6 中引入的一种新的基本数据类型，用于表示一个独一无二的值。它是 JavaScript 中的第七种数据类型，与 undefined、null、Number（数值）、String（字符串）、Boolean（布尔值）、Object（对象）并列。 –csdn 我的理解：Symbol 有哈希表的那个味道，唯一 key 对应唯一 value。 Symbol 的唯一性12345const s1 = Symbol()const s2 = Symbol()console.log(s1 === s2)//false 可以看出，每次调用 Symbol 函数的时候，都会返回一个独一无二的标识。 Symbol 描述值(description)123const s3 = Symbol(&#x27;A&#x27;)console.log(s3.description)//A Symbol 值可作为 key1234567891011const s3 = Symbol(&#x27;A&#x27;)const obj = &#123; [s3]: &#x27;OLiver&#x27;,&#125;// obj[s3] = &quot;nba&quot;console.log(obj)//&#123; [Symbol(A)]: &#x27;OLiver&#x27; &#125; note 注意: 不能通过.语法获取 1console.log(obj.s1) 使用 Symbol 作为 key 的属性名,在遍历/Object.keys 等中是获取不到这些 Symbol 值。需要 Object.getOwnPropertySymbols 来获取所有 Symbol 的 key Symbol key 的指定1234const sa = Symbol.for(&#x27;aaa&#x27;)const sb = Symbol.for(&#x27;aaa&#x27;)console.log(sa === sb)//true SetSet 是一种新增的数据结构，可用于数组去重。 构建 Set 结构1234567const set = new Set()set.add(10)set.add(20)set.add(40)set.add(333)console.log(set)//Set(4) &#123; 10, 20, 40, 333 &#125; 不可重复添加，重复添加部分无效。 123456789const set = new Set()set.add(10)set.add(20)set.add(40)set.add(333)set.add(40)set.add(333)console.log(set)//Set(4) &#123; 10, 20, 40, 333 &#125; 数组去重12345678const arr = [33, 10, 26, 30, 33, 26]const set = new Set()arr.map((value, index, arr) =&gt; &#123; return set.add(value)&#125;)console.log(set)//Set(4) &#123; 33, 10, 26, 30 &#125; size 属性获取 set 中的元素个数 1console.log(arrSet.size) Set 的方法add添加新元素 1arrSet.add(100) delete删除元素 1arrSet.delete(33) has检查是否存在该值 1console.log(arrSet.has(100)) clear清除 Set 1arrSet.clear() 对 Set 进行遍历1234567arrSet.forEach((item) =&gt; &#123; console.log(item)&#125;)for (const item of arrSet) &#123; console.log(item)&#125; WeakSetSet 的弱引用类型,只能存放对象类型。 与 Set 的区别 只能存放对象类型 对对象是一个弱引用，如果没有其他引用对某个对象进行引用，那么 GC 可以对该对象进行回收。 什么是弱引用？图解 图中的浅黄色箭头代表弱连接 –IMG by CoderWhy 理解我的理解：由于 GC 的垃圾回收机制，当一个对象，向上查找的时候，找不到根，其中与根断开了联系。那么这个对象就会被 GC 扫描的时候当作垃圾清理掉。 当该对象与根之间建立强引用的时候，可以读取对象中的数据，且该对象不会被 GC 垃圾回收掉。 当该对象与根之间建立弱引用的时候，可以读取对象中的数据，但当该对象与根之间没有建立强引用的时候，GC 此时会无视弱引用，将该对象回收。 WeakSet 无法遍历 WeakSet 只是对对象的弱引用，如果我们遍历获取到其中的元素，可能造成对象不能被销毁。 WeakSet 中的储存的对象我们是无法获取的。 WeakSet 的应用场景WakeSet 常用于：避免类似 call 的方式，赋予对象一个指定的 this，调用对象方法的方式。 12345678910111213141516171819const personSet = new WeakSet()class Person &#123; constructor() &#123; personSet.add(this) &#125; running() &#123; if (!personSet.has(this)) &#123; throw new Error(&#x27;不能通过非构造方法创建出来的对象调用running方法&#x27;) &#125; console.log(&#x27;running~&#x27;, this) &#125;&#125;let p = new Person()p.running()p = nullp.running.call(&#123; name: &#x27;why&#x27; &#125;) MapJavaScript 中对象中是不能使用对象来作为 key 的，此时我们就需要 Map，Map 允许我们对象类型来作为 key。 基本使用set 添加元素12345678910111213const map = new Map()const o1 = &#123; name: &#x27;Oliver&#x27; &#125;const o2 = &#123; name: &#x27;Xuan&#x27; &#125;map.set(o1, &#x27;Object1&#x27;)map.set(o2, &#x27;Object2&#x27;)console.log(map)// Map(2) &#123;// &#123; name: &#x27;Oliver&#x27; &#125; =&gt; &#x27;Object1&#x27;,// &#123; name: &#x27;Xuan&#x27; &#125; =&gt; &#x27;Object2&#x27;// &#125; get（key）根据 key 取值1234567891011const map = new Map()const o1 = &#123; name: &#x27;Oliver&#x27; &#125;const o2 = &#123; name: &#x27;Xuan&#x27; &#125;map.set(o1, &#x27;Object1&#x27;)map.set(o2, &#x27;Object2&#x27;)console.log(map.get(o1))//Object1 has（key） 检查是否有该 key123456789101112const map = new Map()const o1 = &#123; name: &#x27;Oliver&#x27; &#125;const o2 = &#123; name: &#x27;Xuan&#x27; &#125;map.set(o1, &#x27;Object1&#x27;)map.set(o2, &#x27;Object2&#x27;)console.log(map.has(&#x27;Object&#x27;))console.log(map.has(o1))//false//true delete(key) 根据 key 删除12345678910const map = new Map()const o1 = &#123; name: &#x27;Oliver&#x27; &#125;const o2 = &#123; name: &#x27;Xuan&#x27; &#125;map.set(o1, &#x27;Object1&#x27;)map.set(o2, &#x27;Object2&#x27;)map.delete(o2)console.log(map)//Map(1) &#123; &#123; name: &#x27;Oliver&#x27; &#125; =&gt; &#x27;Object1&#x27; &#125; clear 清除1234567891011const map = new Map()const o1 = &#123; name: &#x27;Oliver&#x27; &#125;const o2 = &#123; name: &#x27;Xuan&#x27; &#125;map.set(o1, &#x27;Object1&#x27;)map.set(o2, &#x27;Object2&#x27;)map.clear(o2)console.log(map)//Map(0) &#123;&#125; 遍历 map1234567891011map.forEach((item, key) =&gt; &#123; console.log(item, key)&#125;)for (const item of map) &#123; console.log(item[0], item[1])&#125;for (const [key, value] of map) &#123; console.log(key, value)&#125; WeakMapWeakMap 和 WakeSet 有些许相同，都是弱引用。 与 Map 的区别 只能接受对象类型作为 key。 对对象是一个弱引用，如果没有其他引用对某个对象进行引用，那么 GC 可以对该对象进行回收。 应用场景（响应式）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 应用场景(vue3响应式原理)const obj1 = &#123; name: &#x27;why&#x27;, age: 18,&#125;function obj1NameFn1() &#123; console.log(&#x27;obj1NameFn1被执行&#x27;)&#125;function obj1NameFn2() &#123; console.log(&#x27;obj1NameFn2被执行&#x27;)&#125;function obj1AgeFn1() &#123; console.log(&#x27;obj1AgeFn1&#x27;)&#125;function obj1AgeFn2() &#123; console.log(&#x27;obj1AgeFn2&#x27;)&#125;const obj2 = &#123; name: &#x27;kobe&#x27;, height: 1.88, address: &#x27;广州市&#x27;,&#125;function obj2NameFn1() &#123; console.log(&#x27;obj1NameFn1被执行&#x27;)&#125;function obj2NameFn2() &#123; console.log(&#x27;obj1NameFn2被执行&#x27;)&#125;// 1.创建WeakMapconst weakMap = new WeakMap()// 2.收集依赖结构// 2.1.对obj1收集的数据结构const obj1Map = new Map()obj1Map.set(&#x27;name&#x27;, [obj1NameFn1, obj1NameFn2])obj1Map.set(&#x27;age&#x27;, [obj1AgeFn1, obj1AgeFn2])weakMap.set(obj1, obj1Map)// 2.2.对obj2收集的数据结构const obj2Map = new Map()obj2Map.set(&#x27;name&#x27;, [obj2NameFn1, obj2NameFn2])weakMap.set(obj2, obj2Map)// 3.如果obj1.name发生了改变// Proxy/Object.definePropertyobj1.name = &#x27;james&#x27;const targetMap = weakMap.get(obj1)const fns = targetMap.get(&#x27;name&#x27;)fns.forEach((item) =&gt; item()) –code by coderwhy","categories":[{"name":"ES6","slug":"ES6","permalink":"http://oliverxuan.github.io/categories/ES6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://oliverxuan.github.io/tags/JavaScript/"}]},{"title":"Js-ES6新特性之let/const","slug":"Js-ES6新特性之let-const","date":"2021-11-06T08:59:25.000Z","updated":"2021-11-06T09:00:31.675Z","comments":true,"path":"2021/11/06/Js-ES6新特性之let-const/","link":"","permalink":"http://oliverxuan.github.io/2021/11/06/Js-ES6%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8Blet-const/","excerpt":"var，let，const，都是 JavaScript 中定义变量/衡量的关键字。总的来说，都是定义，为什么还分这三种呢？ 下面，我将从基础定义，作用域，应用场景来逐一解析。 let/const 基本使用基础数据类型var 与 let 常用于定义变量，而 const 用于定义衡量（常量）。 也就是说一旦给 const foo 赋值后，foo 无法再进行值的改变。不仅对基础数据类型是如此，对象也是如此。 123456const foo = 123console.log(foo) //123//TypeError: Assignment to constant variable.foo = 999console.log(foo) 可以看出，我们尝试给 const 衡量进行第二次赋值操作的时候，报错：TypeError: Assignment to constant variable. 对象（引用类型）如果我们使用 const 来接收一个对象，我们还能对对象里的内容进行修改吗？","text":"var，let，const，都是 JavaScript 中定义变量/衡量的关键字。总的来说，都是定义，为什么还分这三种呢？ 下面，我将从基础定义，作用域，应用场景来逐一解析。 let/const 基本使用基础数据类型var 与 let 常用于定义变量，而 const 用于定义衡量（常量）。 也就是说一旦给 const foo 赋值后，foo 无法再进行值的改变。不仅对基础数据类型是如此，对象也是如此。 123456const foo = 123console.log(foo) //123//TypeError: Assignment to constant variable.foo = 999console.log(foo) 可以看出，我们尝试给 const 衡量进行第二次赋值操作的时候，报错：TypeError: Assignment to constant variable. 对象（引用类型）如果我们使用 const 来接收一个对象，我们还能对对象里的内容进行修改吗？ 12345678910111213const obj = &#123; name: &#x27;Oliver&#x27;, age: 18,&#125;console.log(obj.name)//Oliver//对obj对象中的属性，进行修改。obj.name = &#x27;Yin&#x27;console.log(obj.name)//Yin 事实证明是可以的。 我们再来看下一个案例： 12345678910111213const obj = &#123; name: &#x27;Oliver&#x27;, age: 18,&#125;console.log(obj.name)//将新对象重新赋值给objobj = &#123; name: &#x27;newObj&#x27;, age: 99,&#125;//TypeError: Assignment to constant variable. 此处报错：TypeError: Assignment to constant variable. 事实证明，我们不可以定义已经定义，赋值过的 const 常量进行修改。 思考为什么我们可以修改对象里的属性，而不能为 obj 新赋值一个对象呢？ 修改对象属性其实这里的 cosnt obj 它接收的是一个对象的内存地址。 对象在内存中创建，const obj 保存了这个地址，该内存地址指向内存中这个对象。 当我们修改内存中的属性的时候，我们是修改的该内存地址指向的对象的值。改变的是内存中对象的属性，而这个内存地址并没有发生改变。 尝试重新给 obj 赋值此时，我们尝试给 obj 赋值一个新的对象。由于 const obj，obj 已经赋值过内存地址了。所以当第二次接受赋值的时候，会报错。TypeError: Assignment to constant variable. 不可重复定义通过 let/const 定义的变量名是不可以重复定义 12345678var foo = &#x27;abc&#x27;var foo = &#x27;cba&#x27;let foo = &#x27;abc&#x27;// SyntaxError: Identifier &#x27;foo&#x27; has already been declaredlet foo = &#x27;cba&#x27;console.log(foo) 作用域作用域，可以把他看作是一个房间。是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。 ES5 中的作用域在 ES5 中只有两个对象会有作用域： 全局作用域 函数作用域 在 ES5 中也没有块级作用域概念。 ES6 中的作用域 全局作用域 函数作用域 class 类作用域 let/const 作用域 块级作用域 if-switch-for 块级作用域 作用域提升我们可以先看一个简单的例子： 123console.log(foo) //undefinedvar foo = &#x27;var&#x27; 我们先进行打印 foo 变量的值，再创建。 此时我们的 foo 已经被创建出来了，在全局中。但是还没有进行赋值操作，所以此处为 undefined。 简单地来说： 作用域提升: 在声明变量的作用域中，如果这个变量可以在声明之前被访问，那么我们可以称之为作用域提升 let/const 作用域let/const 没有作用域提升123console.log(foo)let foo = &#x27;let&#x27;// (引用报错）ReferenceError: Cannot access &#x27;foo&#x27; before initialization 当我们尝试上面的操作的时候，并未出现我们预期的 undefined。而是直接报出 ReferenceError: Cannot access ‘foo’ before initialization 引用错误。 这是因为 let/const 并没有作用域提升。 我们可以肯定的是，此处的 let 虽然被创建出来了，但是我们是不可以访问的。所以不满足作用域提升的条件。 ECMA262:这些变量会被创建在包含他们的词法环境被实例化时，但是是不可以访问他们的，直到词法绑定被求值。 Code12345678&#123; var bar = &#x27;bar&#x27; let foo = &#x27;Oliver&#x27;&#125;console.log(bar) //barconsole.log(foo) //ReferenceError: foo is not defined 由此我们可以看出，let 在块级作用域里被定义后，外界想访问时，会直接报错。 而 var 没有作用域，所以块级作用域中也无效。外部可以访问到。 if-switch-for 块级代码在 if，switch，for 中存在块级作用域。 12345678910111213141516171819202122232425262728293031323334&#123;&#125;//if语句的代码就是块级作用域if (true) &#123; var foo = &#x27;foo&#x27; let bar = &#x27;bar&#x27;&#125;console.log(foo)console.log(bar)//switch语句的代码也是块级作用域var color = &#x27;red&#x27;switch (color) &#123; case &#x27;red&#x27;: var foo = &#x27;foo&#x27; let bar = &#x27;bar&#x27;&#125;console.log(foo)console.log(bar)//for语句的代码也是块级作用域for (var i = 0; i &lt; 10; i++) &#123; // console.log(&quot;Hello World&quot; + i)&#125;console.log(i)for (let i = 0; i &lt; 10; i++) &#123;&#125;console.log(i) 作用域的应用场景当我们想实现一个监听点击事件的时候。我们会出现以下场景。 123456789const btns = document.getElementsByTagName(&#x27;button&#x27;) for (var i = 0; i &lt; btns.length; i++) &#123; btns[i].onclick = function() &#123; console.log(&quot;第&quot; + i + &quot;个按钮被点击&quot;) &#125;console.log(i) 但是这里就会出现一个致命 bug，不管我们怎么点击，都是 log 最后一个按钮，这是为什么呢？ 分析1234567891011121314151617181920//此时的i一直在++，btns的i已完成赋值，但是function中的i还未被定义，因为此时function还未执行。&#123; // i=0 btns[0].onclick = function () &#123; //function中的i未赋值 console.log(&#x27;第&#x27; + i + &#x27;个按钮被点击&#x27;) &#125;&#125;&#123; //i=1 btns[1].onclick = function () &#123; console.log(&#x27;第&#x27; + i + &#x27;个按钮被点击&#x27;) &#125;&#125;&#123; //i=2 btns[2].onclick = function () &#123; console.log(&#x27;第&#x27; + i + &#x27;个按钮被点击&#x27;) &#125;&#125; 当我们结束循环后，就会创建如上程序，但是每个程序中的 function 还未被定义。当最终监听到执行的时候，function 寻找这个 i。由于 var i 有作用域提升的属性，且没有作用域的属性。此时的 i 存在于全局中，而 i 已经是最终的 length。所以就会导致此情况的产生。 解决方法按照 ES6 之前的解决方法，我们此时需要一个立即执行函数。将此时的 i 立即传入到 function 中 1234567891011const btns = document.getElementsByTagName(&#x27;button&#x27;)for (var i = 0; i &lt; btns.length; i++) &#123; ;(function (n) &#123; btns[i].onclick = function () &#123; console.log(&#x27;第&#x27; + n + &#x27;个按钮被点击&#x27;) &#125; &#125;)(i)&#125;console.log(i) 由于 function 有自己的作用域，此时 i 传入后传化为 n，n 再进行相关操作。等后续时，每个 function 的作用域中都有自己的 n 值。所以不会出现错误。 ES6-let 解决方案1234567for (let i = 0; i &lt; btns.length; i++) &#123; btns[i].onclick = function () &#123; console.log(&#x27;第&#x27; + i + &#x27;个按钮被点击&#x27;) &#125;&#125;console.log(i) 由于在 let 有作用域的性质，所以在 for 块级作用域中，每一个块中都有自己的 i。每个里面的 i 都不相同。 123456789101112131415161718&#123; i = 0 btns[0].onclick = function () &#123; console.log(&#x27;第&#x27; + n + &#x27;个按钮被点击&#x27;) &#125;&#125;&#123; i = 1 btns[0].onclick = function () &#123; console.log(&#x27;第&#x27; + n + &#x27;个按钮被点击&#x27;) &#125;&#125;&#123; i = 2 btns[0].onclick = function () &#123; console.log(&#x27;第&#x27; + n + &#x27;个按钮被点击&#x27;) &#125;&#125; const？那如果我们将此处的 let 换成 const 的可以吗？ 答案是不可以的，因为每次都需要一次++的自加操作，由于 const 的值无法自加，所以只能用 let 不能用 const。 let/const 暂时性死区暂时性死区：在一个代码中，使用 let，const 声明的变量，在声明之前，变量都是不可以访问的。 123456789var foo = &#x27;foo&#x27;if (true) &#123; console.log(foo) let foo = &#x27;abc&#x27;&#125;//ReferenceError: Cannot access &#x27;foo&#x27; before initialization var，let，const 使用考虑到程序的安全性，我们在开发中，尽可能地去使用·const，以保证，别人不可以随意更改我们的变量。如果发现一个值，需要更改，我们这时候再考虑使用 let。 var 属于是历史的遗留问题，也会造成很多 bug 温床，所以在后续开发的过程中我们还是尽量使用 let，const。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://oliverxuan.github.io/categories/ES6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://oliverxuan.github.io/tags/JavaScript/"}]},{"title":"Js-ES6新特性之增强/解构","slug":"Js-ES6新特性之增强-解构","date":"2021-11-06T07:08:30.000Z","updated":"2021-11-06T07:08:46.081Z","comments":true,"path":"2021/11/06/Js-ES6新特性之增强-解构/","link":"","permalink":"http://oliverxuan.github.io/2021/11/06/Js-ES6%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E5%A2%9E%E5%BC%BA-%E8%A7%A3%E6%9E%84/","excerpt":"在 ES6 中，提供了许多的新特性，为我们的编写代码提供了许多的便利。这里我将简单记录一下 ES6 中，字面量增强写法，数组解构，对象解构。 字面量的增强写法12345678910111213141516171819202122232425//字面量的增强写法var name = &#x27;Oliver&#x27;var age = 19var obj = &#123; //字面量的增强写法，属性的简写 //不需要 name：name这种形式。当两个名称重复的时候，直接就写一个名称即可。 name, age, //方法的简写 // ES6之前 key：value的方式创建 foo: function () &#123; console.log(&quot;ES6之前&quot;); &#125; //ES6之后 直接方法名 bar() &#123; console.log(&#x27;ES6方法的简写&#x27;) &#125;, //计算属性名 [name + 123]: &#x27;计算属性名&#x27;,&#125; 解构数组的解构12345678910111213141516171819202122232425262728var names = [1, 2, 3]//未解构,十分麻烦，需要一个一个地去赋值，提取出来。var item1 = names[0]var item2 = names[1]var item3 = names[2]console.log(item1, item2, item3)//ES6解构后：//直接统一提取。var [item1, item2, item3] = namesconsole.log(item1, item2, item3)//解构后面的元素，注意逗号！var [, itemb, itemc] = namesconsole.log(itemb, itemc)//解构部分元素，剩余元素放到一个新数组中，此处使用到了省略，缺省。var [itemq, ...newArry] = namesconsole.log(newArry)console.log(itemq)//解构的默认值var [itemx, itemy, itemz, iteml = &#x27;value&#x27;] = namesconsole.log(itemx, itemy, itemz, iteml) 对象的解构1234567891011121314151617181920212223//对象的解构var obj = &#123; name: &#x27;Oliver&#x27;, age: 18, height: 1.76,&#125;//注意括号类型。var &#123; name, age, height &#125; = objconsole.log(name, age, height)//内容顺序无限制var &#123; height, age &#125; = objconsole.log(age, height)//可以对名称进行修改var &#123; age: newAge &#125; = objconsole.log(newAge)//可以使用默认值var &#123; index: newIndex = 99 &#125; = objconsole.log(newIndex) 总结虽然内容很少，但是这些特性在开发中使用频率还是很高的，也可以大大提高开发中的编码效率！","text":"在 ES6 中，提供了许多的新特性，为我们的编写代码提供了许多的便利。这里我将简单记录一下 ES6 中，字面量增强写法，数组解构，对象解构。 字面量的增强写法12345678910111213141516171819202122232425//字面量的增强写法var name = &#x27;Oliver&#x27;var age = 19var obj = &#123; //字面量的增强写法，属性的简写 //不需要 name：name这种形式。当两个名称重复的时候，直接就写一个名称即可。 name, age, //方法的简写 // ES6之前 key：value的方式创建 foo: function () &#123; console.log(&quot;ES6之前&quot;); &#125; //ES6之后 直接方法名 bar() &#123; console.log(&#x27;ES6方法的简写&#x27;) &#125;, //计算属性名 [name + 123]: &#x27;计算属性名&#x27;,&#125; 解构数组的解构12345678910111213141516171819202122232425262728var names = [1, 2, 3]//未解构,十分麻烦，需要一个一个地去赋值，提取出来。var item1 = names[0]var item2 = names[1]var item3 = names[2]console.log(item1, item2, item3)//ES6解构后：//直接统一提取。var [item1, item2, item3] = namesconsole.log(item1, item2, item3)//解构后面的元素，注意逗号！var [, itemb, itemc] = namesconsole.log(itemb, itemc)//解构部分元素，剩余元素放到一个新数组中，此处使用到了省略，缺省。var [itemq, ...newArry] = namesconsole.log(newArry)console.log(itemq)//解构的默认值var [itemx, itemy, itemz, iteml = &#x27;value&#x27;] = namesconsole.log(itemx, itemy, itemz, iteml) 对象的解构1234567891011121314151617181920212223//对象的解构var obj = &#123; name: &#x27;Oliver&#x27;, age: 18, height: 1.76,&#125;//注意括号类型。var &#123; name, age, height &#125; = objconsole.log(name, age, height)//内容顺序无限制var &#123; height, age &#125; = objconsole.log(age, height)//可以对名称进行修改var &#123; age: newAge &#125; = objconsole.log(newAge)//可以使用默认值var &#123; index: newIndex = 99 &#125; = objconsole.log(newIndex) 总结虽然内容很少，但是这些特性在开发中使用频率还是很高的，也可以大大提高开发中的编码效率！","categories":[{"name":"ES6","slug":"ES6","permalink":"http://oliverxuan.github.io/categories/ES6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://oliverxuan.github.io/tags/JavaScript/"}]},{"title":"Js-ES6新特性之class","slug":"Js-ES6新特性之class","date":"2021-11-05T05:54:02.000Z","updated":"2021-11-06T06:41:03.744Z","comments":true,"path":"2021/11/05/Js-ES6新特性之class/","link":"","permalink":"http://oliverxuan.github.io/2021/11/05/Js-ES6%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8Bclass/","excerpt":"在大一的时候，我曾学习过一段时间的 Java。在 Java 中，类是一个非常重要的部分。通过类，我们可以减少代码的冗余，提高代码的复用性，封装性。让代码看起来简洁，明了。 通过之前的学习，我们理解了 JavaScript 中原型，原型链相关概念。也尝试着实现了类，构造器，以及继承。但整体上看来，在 ES6-class 这个新特性出现之前，我们用 JavaScript 想去实现类，是一件不太容易的事情。那么今天我们就来尝试着使用 ES6 中的 class，看看有哪些不同。 类在 ES6 中，如果我们想去定义一个类，我们使用 class 关键字（这和 java 中的思想就很接近）。 1class Person &#123;&#125; 这样我们就新建了个 Person 类。我们不必再去使用函数去拟一个类出来，ES6 简单明了，就是 class。 类相关的原型之前我们学习了原型，至此，我们也产生好奇，通过 class 的方式创建出来的类，他的 prototype 是什么？ 12345678910111213class Person &#123;&#125;//Person的原型console.log(Person.prototype) //&#123;&#125;//Person的上层protoconsole.log(Person.prototype.__proto__) // [Object: null prototype] &#123;&#125;//此时Person原型上的构造器定义的是classconsole.log(Person.prototype.constructor) // [class Person]//js中由于typeof返还的类型是固定的，这里只能返回为function，而不是class。console.log(typeof Person) // function typeof 只能返还： “number,” “string,” “boolean,” “object,” “function,” 和 “undefined.”","text":"在大一的时候，我曾学习过一段时间的 Java。在 Java 中，类是一个非常重要的部分。通过类，我们可以减少代码的冗余，提高代码的复用性，封装性。让代码看起来简洁，明了。 通过之前的学习，我们理解了 JavaScript 中原型，原型链相关概念。也尝试着实现了类，构造器，以及继承。但整体上看来，在 ES6-class 这个新特性出现之前，我们用 JavaScript 想去实现类，是一件不太容易的事情。那么今天我们就来尝试着使用 ES6 中的 class，看看有哪些不同。 类在 ES6 中，如果我们想去定义一个类，我们使用 class 关键字（这和 java 中的思想就很接近）。 1class Person &#123;&#125; 这样我们就新建了个 Person 类。我们不必再去使用函数去拟一个类出来，ES6 简单明了，就是 class。 类相关的原型之前我们学习了原型，至此，我们也产生好奇，通过 class 的方式创建出来的类，他的 prototype 是什么？ 12345678910111213class Person &#123;&#125;//Person的原型console.log(Person.prototype) //&#123;&#125;//Person的上层protoconsole.log(Person.prototype.__proto__) // [Object: null prototype] &#123;&#125;//此时Person原型上的构造器定义的是classconsole.log(Person.prototype.constructor) // [class Person]//js中由于typeof返还的类型是固定的，这里只能返回为function，而不是class。console.log(typeof Person) // function typeof 只能返还： “number,” “string,” “boolean,” “object,” “function,” 和 “undefined.” 类的定义 内存中创建一个对象 将类的原型中的 prototype 赋值给新建出来的对象 moni.** proto ** = Person.prototype 将对象赋值给函数的 this：new 绑定 this = moni 执行函数体中的代码 自动返回创建出来的对象 属性，构造器定义一个类只能有一个构造函数 123456789101112class Person &#123; //一个类只能有一个构造函数，通过constructor来定义构造器。 constructor(name, age) &#123; this.name = name this.age = age &#125;&#125;var p1 = new Person(&#x27;Oliver&#x27;, 18)console.log(p1.name) //Oliverconsole.log(p1.age) //18 方法定义123456789101112131415161718class Person &#123; constructor(name, age) &#123; this.name = name this.age = age &#125; //直接在类中定义 eat() &#123; console.log(this.name + &#x27;在吃饭！&#x27;) &#125;&#125;var p1 = new Person(&#x27;Oliver&#x27;, 18)console.log(p1.name)console.log(p1.age)//直接调用p1.eat() 私有属性/属性拦截操作当我们想在类中定义一个私有属性，当外界进行调用或者赋值的时候，我们进行相关拦截。我们可以如下操作。 12345678910111213141516171819202122232425262728293031323334353637383940class Person &#123; //同样在构造器中传值，约定俗成，私有属性前用 _ 来标记。 constructor(name, age, _index) &#123; this.name = name this.age = age this._index = _index &#125; eat() &#123; console.log(this.name + &#x27;在吃饭！&#x27;) &#125; //赋值操作，使用set关键字 set index(index) &#123; console.log(&#x27;赋值拦截&#x27;) this._index = index &#125; //取值操作，使用get关键字 get index() &#123; console.log(&#x27;调用拦截&#x27;) return this._index &#125;&#125;var p1 = new Person(&#x27;Oliver&#x27;, 18, 999)console.log(p1.name)console.log(p1.age)p1.eat()//调用属性console.log(p1.index) //调用拦截//999//设置属性p1.index = 000 //赋值拦截//再次调用console.log(p1.index) //调用拦截//000 至此，我们就可以通过 set，get 方法，来私有化属性，在每次访问私有属性前，进行拦截操作。 static 静态方法（类方法）我们可以在类中定义 static 方法。定义后的该方法，可以直接以类名+静态方法名的方式调用。所以我们也称为类方法。 1234567891011121314151617class Person &#123; constructor(name, age, _index) &#123; this.name = name this.age = age this._index = _index &#125; //使用static来定义静态方法。 static classMethod() &#123; console.log(&#x27;我是static静态方法！&#x27;) &#125;&#125;var p1 = new Person(&#x27;Oliver&#x27;, 18, 999)//直接通过类名+静态方法名的方式调用Person.classMethod() //我是static静态方法！ 类的继承我们实现了基础的类定义，我们也可以尝试去实现一些类的继承。通过继承，我们将大大提高编码效率。 extends 继承关键字例如，我们现在有个 Person 父类，Student 子类，我们想要继承 Person，我们只需要在 Student 类名后加上 extends Person 就可以完成继承操作。这与 java 中继承的实现是一样的。 12345678910class Person &#123; constructor(name, age) &#123; this.name = name this.age = age &#125;&#125;class Student extends Person &#123;&#125;console.log(Student.prototype) //Person &#123;&#125; 通过打印 Student.prototype 的方式，我们可以看见为 Person。至此，我们就在 Person 与 Student 之间建立起了继承关系。 继承父类属性 super（）这时，我们就会迫不及待地去尝试用子类去调用父类中的属性。直接调用是行不通的，此时我们就需要 super 关键字，将父类中的属性，构造器方法引用过来。 1234567891011121314151617181920class Person &#123; //父类构造器中，包含了姓名，年龄信息。 constructor(name, age) &#123; this.name = name this.age = age &#125;&#125;class Student extends Person &#123; //在子类构造器中，同样要将name，age属性写入 constructor(name, age, sno) &#123; //super关键字，常出现于构造器的第一行，将想要继承的父类构造器属性引用。 super(name, age) //完成剩余属性的构造器操作 this.sno = sno &#125;&#125;var s1 = new Student(&#x27;Oliver&#x27;, 18, 01)console.log(s1.name + s1.age + s1.sno) //Oliver1801 super 关键字，常出现于构造器的第一行，需要养成良好习惯。 继承父类方法无需多言，直接调用。 123456789101112131415161718192021class Person &#123; constructor(name, age) &#123; this.name = name this.age = age &#125; myName() &#123; console.log(&#x27;My name is&#x27; + this.name) &#125;&#125;class Student extends Person &#123; constructor(name, age, sno) &#123; super(name, age) this.sno = sno &#125;&#125;var s1 = new Student(&#x27;Oliver&#x27;, 18, 01)s1.myName() //My name is Oliver 同样，static 静态方法也可以直接继承，无需多言。 12345678910111213141516171819202122232425class Person &#123; constructor(name, age) &#123; this.name = name this.age = age &#125; myName() &#123; console.log(&#x27;My name is&#x27; + this.name) &#125; static personMehod() &#123; console.log(&#x27;static method&#x27;) &#125;&#125;class Student extends Person &#123; constructor(name, age, sno) &#123; super(name, age) this.sno = sno &#125;&#125;var s1 = new Student(&#x27;Oliver&#x27;, 18, 01)Student.personMehod() //static method 方法的重写/复用当我们想重新定义父类中的方法。或者父类中只写了上半部分逻辑，我们又想在子类中完成后半段逻辑，我们就可以使用重写/复用的方法来进行相关加工。 重写当父类中有名为 do 方法时，我们子类想使用自己的 do 方法，此时直接在子类中定义该方法。 123456789101112131415161718192021222324252627class Person &#123; constructor(name, age) &#123; this.name = name this.age = age &#125; //父类do方法 do() &#123; console.log(&#x27;Person do!&#x27;) &#125;&#125;class Student extends Person &#123; constructor(name, age, sno) &#123; super(name, age) this.sno = sno &#125; //子类重写的do方法 do() &#123; console.log(&#x27;Student do!&#x27;) &#125;&#125;var s1 = new Student(&#x27;Oliver&#x27;, 18, 01)s1.do() //Student do！ 如果子类重写了该方法，那么就会优先使用子类的方法. 复用一个任务为 A+B 两个逻辑完成。当父类完成 A 逻辑，子类想接着完成 B 逻辑的时候，我们可以使用复用的方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243class Person &#123; constructor(name, age) &#123; this.name = name this.age = age &#125; //父类操作逻辑AAAA do() &#123; console.log(&#x27;Person do!&#x27;) console.log(&#x27;父类逻辑AAAAA&#x27;) console.log(&#x27;父类逻辑AAAAA&#x27;) console.log(&#x27;父类逻辑AAAAA&#x27;) &#125;&#125;class Student extends Person &#123; constructor(name, age, sno) &#123; super(name, age) this.sno = sno &#125; //子类操作逻辑BBBB do() &#123; //类似于属性中的super，引用父类中的方法。 super.do() console.log(&#x27;Student do!&#x27;) console.log(&#x27;子类逻辑BBBBB&#x27;) console.log(&#x27;子类逻辑BBBBB&#x27;) console.log(&#x27;子类逻辑BBBBB&#x27;) &#125;&#125;var s1 = new Student(&#x27;Oliver&#x27;, 18, 01)s1.do()//Person do!//父类逻辑AAAAA//父类逻辑AAAAA//父类逻辑AAAAA//Student do!//子类逻辑BBBBB//子类逻辑BBBBB//子类逻辑BBBBB 类的混入由于 Js 的类只能有一个父类：单继承，这和 C++，Java 多继承不同。但是通过一些代码，我们同样可以实现 Js 的多继承。 1234567891011121314151617181920212223242526272829303132333435//父类class Person &#123;&#125;//将要混入的Run方法，首先传入我们想加工的类function mixinRunner(BaseClass) &#123; //新建一个类（NewClass 继承 我们想要加工类的属性，方法） class NewClass extends BaseClass &#123; //对新的类进行加工。 running() &#123; console.log(&#x27;running~&#x27;) &#125; &#125; //记得要返回这个新类 return NewClass&#125;//我们这里可以省略 newClass这一步 直接return classfunction mixinEater(BaseClass) &#123; return class extends BaseClass &#123; eating() &#123; console.log(&#x27;eating~&#x27;) &#125; &#125;&#125;// 在JS中类只能有一个父类: 单继承class Student extends Person &#123;&#125;// 加工类，并接收新类。var NewStudent = mixinEater(mixinRunner(Student))//创建新对象var ns = new NewStudent()//调用方法ns.running()ns.eating() Js 多态传统的面向对象多态是有三个前提: 必须有继承(是多态的前提) 必须有重写(子类重写父类的方法) 必须有父类引用指向子类对象 TS 多态由于 Js 对类型的要求很松散，我们这里使用 TypeScript 来演示。 12345678910111213141516171819202122232425262728293031323334// Shape形状class Shape &#123; getArea() &#123;&#125;&#125;//矩形继承于 形状class Rectangle extends Shape &#123; getArea() &#123; return 100 &#125;&#125;//同上class Circle extends Shape &#123; getArea() &#123; return 200 &#125;&#125;var r = new Rectangle()var c = new Circle()// 多态: 当对不同的数据类型执行同一个操作时, 如果表现出来的行为(形态)不一样, 那么就是多态的体现.//接收一个shape类型的参数，这里的shape可以是 Rectangle，circlefunction calcArea(shape: Shape) &#123; //根据不同的形状，调用不同的获取面积的方法，此处就展现了多态 console.log(shape.getArea())&#125;calcArea(r)calcArea(c)export &#123;&#125; Js 多态有人会问，JavaScript 中有多态吗，我的答案是肯定的：有。但是 JavaScript 的多态和传统的多态又有着些许不同。 123456789101112131415161718192021222324252627282930// 多态: 当对不同的数据类型执行同一个操作时, 如果表现出来的行为(形态)不一样, 那么就是多态的体现.function calcArea(foo) &#123; console.log(foo.getArea())&#125;var obj1 = &#123; name: &#x27;why&#x27;, getArea: function () &#123; return 1000 &#125;,&#125;class Person &#123; getArea() &#123; return 100 &#125;&#125;var p = new Person()calcArea(obj1)calcArea(p)// 也是多态的体现function sum(m, n) &#123; return m + n&#125;sum(20, 30)sum(&#x27;abc&#x27;, &#x27;cba&#x27;) 在这里，我们没有看见继承，更没有父类方法的重写。但是这里确实是，对不同的数据类型执行同一个操作时, 如果表现出来的行为(形态)不一样。 这也是 JavaScript 多态的不同之处。 ES6 适配由于 ES6 中有许多比较新的特性，例如 class。我们在开发的时候就会考虑适配 ie 之类的远古浏览器。他们并不能识别这一类的新特性。此时我们就需要 Babel 这个工具来将我们的代码从 ES6 编译为 ES5 或者是该浏览器能够识别的 js 代码。 体验我们可以通过babeljs.io在线体验这个转化过程。 我们尝试，将下段代码转化。 属性，方法定义ES6123456789101112131415161718class Person &#123; constructor(name, age) &#123; this.name = name this.age = age &#125; //直接在类中定义 eat() &#123; console.log(this.name + &#x27;在吃饭！&#x27;) &#125;&#125;var p1 = new Person(&#x27;Oliver&#x27;, 18)console.log(p1.name)console.log(p1.age)//直接调用p1.eat() Babel12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&#x27;use strict&#x27;function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError(&#x27;Cannot call a class as a function&#x27;) &#125;&#125;function _defineProperties(target, props) &#123; for (var i = 0; i &lt; props.length; i++) &#123; var descriptor = props[i] descriptor.enumerable = descriptor.enumerable || false descriptor.configurable = true if (&#x27;value&#x27; in descriptor) descriptor.writable = true Object.defineProperty(target, descriptor.key, descriptor) &#125;&#125;function _createClass(Constructor, protoProps, staticProps) &#123; if (protoProps) _defineProperties(Constructor.prototype, protoProps) if (staticProps) _defineProperties(Constructor, staticProps) return Constructor&#125;var Person = /*#__PURE__*/ (function () &#123; function Person(name, age) &#123; _classCallCheck(this, Person) this.name = name this.age = age &#125; //直接在类中定义 _createClass(Person, [ &#123; key: &#x27;eat&#x27;, value: function eat() &#123; console.log(this.name + &#x27;在吃饭！&#x27;) &#125;, &#125;, ]) return Person&#125;)()var p1 = new Person(&#x27;Oliver&#x27;, 18)console.log(p1.name)console.log(p1.age) //直接调用p1.eat() 继承实现ES612345678910111213141516171819202122232425262728class Person &#123; constructor(name, age) &#123; this.name = name this.age = age &#125; do() &#123; console.log(&#x27;Person do!&#x27;) console.log(&#x27;父类逻辑AAAAA&#x27;) console.log(&#x27;父类逻辑AAAAA&#x27;) console.log(&#x27;父类逻辑AAAAA&#x27;) &#125;&#125;class Student extends Person &#123; constructor(name, age, sno) &#123; super(name, age) this.sno = sno &#125; do() &#123; super.do() console.log(&#x27;Student do!&#x27;) console.log(&#x27;子类逻辑BBBBB&#x27;) console.log(&#x27;子类逻辑BBBBB&#x27;) console.log(&#x27;子类逻辑BBBBB&#x27;) &#125;&#125; Babel123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200&#x27;use strict&#x27;function _typeof(obj) &#123; &#x27;@babel/helpers - typeof&#x27; if (typeof Symbol === &#x27;function&#x27; &amp;&amp; typeof Symbol.iterator === &#x27;symbol&#x27;) &#123; _typeof = function _typeof(obj) &#123; return typeof obj &#125; &#125; else &#123; _typeof = function _typeof(obj) &#123; return obj &amp;&amp; typeof Symbol === &#x27;function&#x27; &amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? &#x27;symbol&#x27; : typeof obj &#125; &#125; return _typeof(obj)&#125;function _get(target, property, receiver) &#123; if (typeof Reflect !== &#x27;undefined&#x27; &amp;&amp; Reflect.get) &#123; _get = Reflect.get &#125; else &#123; _get = function _get(target, property, receiver) &#123; var base = _superPropBase(target, property) if (!base) return var desc = Object.getOwnPropertyDescriptor(base, property) if (desc.get) &#123; return desc.get.call(receiver) &#125; return desc.value &#125; &#125; return _get(target, property, receiver || target)&#125;function _superPropBase(object, property) &#123; while (!Object.prototype.hasOwnProperty.call(object, property)) &#123; object = _getPrototypeOf(object) if (object === null) break &#125; return object&#125;function _inherits(subClass, superClass) &#123; if (typeof superClass !== &#x27;function&#x27; &amp;&amp; superClass !== null) &#123; throw new TypeError(&#x27;Super expression must either be null or a function&#x27;) &#125; subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, &#123; constructor: &#123; value: subClass, writable: true, configurable: true &#125;, &#125;) if (superClass) _setPrototypeOf(subClass, superClass)&#125;function _setPrototypeOf(o, p) &#123; _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) &#123; o.__proto__ = p return o &#125; return _setPrototypeOf(o, p)&#125;function _createSuper(Derived) &#123; var hasNativeReflectConstruct = _isNativeReflectConstruct() return function _createSuperInternal() &#123; var Super = _getPrototypeOf(Derived), result if (hasNativeReflectConstruct) &#123; var NewTarget = _getPrototypeOf(this).constructor result = Reflect.construct(Super, arguments, NewTarget) &#125; else &#123; result = Super.apply(this, arguments) &#125; return _possibleConstructorReturn(this, result) &#125;&#125;function _possibleConstructorReturn(self, call) &#123; if (call &amp;&amp; (_typeof(call) === &#x27;object&#x27; || typeof call === &#x27;function&#x27;)) &#123; return call &#125; else if (call !== void 0) &#123; throw new TypeError( &#x27;Derived constructors may only return object or undefined&#x27; ) &#125; return _assertThisInitialized(self)&#125;function _assertThisInitialized(self) &#123; if (self === void 0) &#123; throw new ReferenceError( &quot;this hasn&#x27;t been initialised - super() hasn&#x27;t been called&quot; ) &#125; return self&#125;function _isNativeReflectConstruct() &#123; if (typeof Reflect === &#x27;undefined&#x27; || !Reflect.construct) return false if (Reflect.construct.sham) return false if (typeof Proxy === &#x27;function&#x27;) return true try &#123; Boolean.prototype.valueOf.call( Reflect.construct(Boolean, [], function () &#123;&#125;) ) return true &#125; catch (e) &#123; return false &#125;&#125;function _getPrototypeOf(o) &#123; _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) &#123; return o.__proto__ || Object.getPrototypeOf(o) &#125; return _getPrototypeOf(o)&#125;function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError(&#x27;Cannot call a class as a function&#x27;) &#125;&#125;function _defineProperties(target, props) &#123; for (var i = 0; i &lt; props.length; i++) &#123; var descriptor = props[i] descriptor.enumerable = descriptor.enumerable || false descriptor.configurable = true if (&#x27;value&#x27; in descriptor) descriptor.writable = true Object.defineProperty(target, descriptor.key, descriptor) &#125;&#125;function _createClass(Constructor, protoProps, staticProps) &#123; if (protoProps) _defineProperties(Constructor.prototype, protoProps) if (staticProps) _defineProperties(Constructor, staticProps) return Constructor&#125;var Person = /*#__PURE__*/ (function () &#123; function Person(name, age) &#123; _classCallCheck(this, Person) this.name = name this.age = age &#125; _createClass(Person, [ &#123; key: &#x27;do&#x27;, value: function _do() &#123; console.log(&#x27;Person do!&#x27;) console.log(&#x27;父类逻辑AAAAA&#x27;) console.log(&#x27;父类逻辑AAAAA&#x27;) console.log(&#x27;父类逻辑AAAAA&#x27;) &#125;, &#125;, ]) return Person&#125;)()var Student = /*#__PURE__*/ (function (_Person) &#123; _inherits(Student, _Person) var _super = _createSuper(Student) function Student(name, age, sno) &#123; var _this _classCallCheck(this, Student) _this = _super.call(this, name, age) _this.sno = sno return _this &#125; _createClass(Student, [ &#123; key: &#x27;do&#x27;, value: function _do() &#123; _get(_getPrototypeOf(Student.prototype), &#x27;do&#x27;, this).call(this) console.log(&#x27;Student do!&#x27;) console.log(&#x27;子类逻辑BBBBB&#x27;) console.log(&#x27;子类逻辑BBBBB&#x27;) console.log(&#x27;子类逻辑BBBBB&#x27;) &#125;, &#125;, ]) return Student&#125;)(Person) 总结可以说 ES6 中的 class 给我们带来了很大的便利，Babel 同样也是。如果有能力，有时间，可以钻研一下 Babel 的逻辑代码，真的写的很好，有很多的细节需要去考究。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://oliverxuan.github.io/categories/ES6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://oliverxuan.github.io/tags/JavaScript/"}]},{"title":"Js中原型链-继承的实现","slug":"Js中原型链-继承的实现","date":"2021-10-28T11:17:55.000Z","updated":"2021-11-02T14:13:29.693Z","comments":true,"path":"2021/10/28/Js中原型链-继承的实现/","link":"","permalink":"http://oliverxuan.github.io/2021/10/28/Js%E4%B8%AD%E5%8E%9F%E5%9E%8B%E9%93%BE-%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"继承是面向对象中非常重要的，不仅仅可以减少代码的数量，提高复用性，也是多态的前提。 多态：不同的对象在执行时表现出不同的形态。 原型我们来举个例子： 123456789101112131415161718var obj = &#123; name: &#x27;Oliver&#x27;, age: 18,&#125;//OLiverconsole.log(obj.name)//undefindconsole.log(obj.height)//obj的原型 obj.__proto__obj.__proto__ = &#123; height: 180,&#125;//180console.log(obj.height) 我们有个 obj 对象，在最开始的时候他并没有 height 属性，我们在第一次打印时，就只能打印出 name 属性，height 为 undefined。 当我们为他的原型添加上新的对象，其中有属性 height 为 18，当我们第二打印的时候，obj 就可以向上查找自己的原型（直到找到/Object 顶层对象），其中就得到了 height 属性 顶层对象：Object : null prototype原型判断方法判断属性是否在对象中","text":"继承是面向对象中非常重要的，不仅仅可以减少代码的数量，提高复用性，也是多态的前提。 多态：不同的对象在执行时表现出不同的形态。 原型我们来举个例子： 123456789101112131415161718var obj = &#123; name: &#x27;Oliver&#x27;, age: 18,&#125;//OLiverconsole.log(obj.name)//undefindconsole.log(obj.height)//obj的原型 obj.__proto__obj.__proto__ = &#123; height: 180,&#125;//180console.log(obj.height) 我们有个 obj 对象，在最开始的时候他并没有 height 属性，我们在第一次打印时，就只能打印出 name 属性，height 为 undefined。 当我们为他的原型添加上新的对象，其中有属性 height 为 18，当我们第二打印的时候，obj 就可以向上查找自己的原型（直到找到/Object 顶层对象），其中就得到了 height 属性 顶层对象：Object : null prototype原型判断方法判断属性是否在对象中12345678910111213141516171819var obj = &#123; name: &#x27;Oliver&#x27;, age: 18,&#125;var info = Object.create(obj, &#123; address: &#123; value: &#x27;北京市&#x27;, enumerable: true, &#125;,&#125;)// hasOwnProperty方法判断当前对象是否存在该属性console.log(info.hasOwnProperty(&#x27;address&#x27;)) //trueconsole.log(info.hasOwnProperty(&#x27;name&#x27;)) //false// in 操作符: 不管在当前对象还是原型中返回的都是trueconsole.log(&#x27;address&#x27; in info)console.log(&#x27;name&#x27; in info) instanceof检测某一个构造函数原型链上是否存在该实例对象 12345678910111213141516171819202122232425262728function createObject(o) &#123; function Fn() &#123;&#125; Fn.prototype = o return new Fn()&#125;function inheritPrototype(SubType, SuperType) &#123; SubType.prototype = createObject(SuperType.prototype) Object.defineProperty(SubType.prototype, &#x27;constructor&#x27;, &#123; enumerable: false, configurable: true, writable: true, value: SubType, &#125;)&#125;function Person() &#123;&#125;function Student() &#123;&#125;inheritPrototype(Student, Person)console.log(Person.prototype.__proto__)var stu = new Student()console.log(stu instanceof Student) // trueconsole.log(stu instanceof Person) // trueconsole.log(stu instanceof Object) // true isPrototypeOf检测某一个函数原型链上是否存在该实例对象 1234567891011121314151617function Person() &#123;&#125;var p = new Person()console.log(p instanceof Person)console.log(Person.prototype.isPrototypeOf(p))//var obj = &#123; name: &#x27;why&#x27;, age: 18,&#125;var info = Object.create(obj)// console.log(info instanceof obj) instanceof不能检测函数，只能检测构造函数，否则会报错！console.log(obj.isPrototypeOf(info)) 对象-函数-原型之间的关系对象里面是有一个 _ _ proto_ _对象: 隐式原型对象 Foo 是一个函数, 那么它会有一个显示原型对象: Foo.prototyp Foo.prototype 来自哪里? 答案: 创建了一个函数, Foo.prototype = { constructor: Foo } Foo 是一个对象, 那么它会有一个隐式原型对象: Foo._ _ proto _ _ Foo._ _ proto _ _来自哪里? 答案: new Function() Foo._ _ proto _ _ = Function.prototype Function.prototype = { constructor: Function } var Foo = new Function() 原型链 在当前的对象中查找属性 如果没有找到，这个时候会去原型链（_ _ proto_ _）对象上寻找 1234obj.__proto__ = &#123;&#125;// 原型链obj.__proto__.__proto__ = &#123;&#125; new 对象的过程当我们在 new 新对象的时候： 1var p = new Person() 我们并不清楚在这个 new 的过程里，都发生了什么。 其实 new 的过程可以分为四步： 创建一个模拟空对象 1var obj = new Object() 让 Person 中的 this 指向 obj，并执行 Person 这个构造函数 1var result = Person.call(obj) 设置原型链。将 obj 的 _ _ proto_ _指向 Person 函数对象的 prototype 1obj.__proto__ = Person.prototype 判断 result 的返回值类型，如果是值类型，返回 obj。如果是引用类型，就返回这个引用类型的对象。 12if (typeof result == &#x27;object&#x27;) person = resultelse person = obj 手写实现1234567891011121314151617function Person() &#123; this.name = &#x27;Oliver&#x27; this.age = 18&#125;//step1:新建一个空对象let obj = new Object()//step2:绑定thislet result = Person.call(obj)//step3:将原型绑定obj.__proto__ = Person.prototype//step4:判断类型if (typeof result === &#x27;object&#x27;) &#123; person = result&#125; else &#123; person = obj&#125; 继承原型链1234567891011121314151617181920212223242526272829303132333435363738394041424344// 父类: 公共属性和方法function Person() &#123; this.name = &#x27;Oliver&#x27; this.friends = []&#125;Person.prototype.eating = function () &#123; console.log(this.name + &#x27; eating~&#x27;)&#125;// 子类: 特有属性和方法function Student() &#123; this.sno = 111&#125;var p = new Person()Student.prototype = pStudent.prototype.studying = function () &#123; console.log(this.name + &#x27; studying~&#x27;)&#125;var stu = new Student()// 原型链实现继承的弊端:// 1.第一个弊端: 打印stu对象, 继承的属性是看不到的// console.log(stu.name)// 2.第二个弊端: 创建出来两个stu的对象var stu1 = new Student()var stu2 = new Student()// 直接修改对象上的属性, 是给本对象添加了一个新属性stu1.name = &#x27;kobe&#x27;console.log(stu2.name)// 获取引用, 修改引用中的值, 会相互影响stu1.friends.push(&#x27;kobe&#x27;)console.log(stu1.friends)console.log(stu2.friends)// 3.第三个弊端: 在前面实现类的过程中都没有传递参数var stu3 = new Student(&#x27;lilei&#x27;, 112) 弊端 打印子对象的时候，继承的属性是看不到的 创建的子对象，之间的值会相互影响（因为指向同一个 p 对象） 在实现类的时候，并没有传递参数 借用构造函数123456789101112131415161718192021222324252627282930313233343536373839// 父类: 公共属性和方法function Person(name, age, friends) &#123; // this = stu this.name = name this.age = age this.friends = friends&#125;Person.prototype.eating = function () &#123; console.log(this.name + &#x27; eating~&#x27;)&#125;// 子类: 特有属性和方法function Student(name, age, friends, sno) &#123; Person.call(this, name, age, friends) // this.name = name // this.age = age // this.friends = friends this.sno = 111&#125;var p = new Person()Student.prototype = pStudent.prototype.studying = function () &#123; console.log(this.name + &#x27; studying~&#x27;)&#125;var stu = new Student(&#x27;foo&#x27;, 18, [&#x27;kobe&#x27;], 111)console.log(stu)var stu1 = new Student(&#x27;bar&#x27;, 18, [&#x27;lilei&#x27;], 111)var stu2 = new Student(&#x27;kobe&#x27;, 30, [&#x27;james&#x27;], 112)stu1.friends.push(&#x27;lucy&#x27;)console.log(stu1.friends)console.log(stu2.friends) 弊端 第一个弊端: Person 函数至少被调用了两次 第二个弊端: stu 的原型对象上会多出一些属性, 但是这些属性是没有存在的必要 父类原型赋值给子类1234567891011121314151617181920212223242526272829303132// 父类: 公共属性和方法function Person(name, age, friends) &#123; // this = stu this.name = name this.age = age this.friends = friends&#125;Person.prototype.eating = function () &#123; console.log(this.name + &#x27; eating~&#x27;)&#125;// 子类: 特有属性和方法function Student(name, age, friends, sno) &#123; Person.call(this, name, age, friends) // this.name = name // this.age = age // this.friends = friends this.sno = 111&#125;// 直接将父类的原型赋值给子类, 作为子类的原型Student.prototype = Person.prototypeStudent.prototype.studying = function () &#123; console.log(this.name + &#x27; studying~&#x27;)&#125;// name/snovar stu = new Student(&#x27;foo&#x27;, 18, [&#x27;kobe&#x27;], 111)console.log(stu)stu.eating() 弊端由于子类的原型对象是来自于父类赋值的，那么子类的原型对象就是指向父类的原型。 当自类的进行类似 Student.prototype.studding=function（ ）{ }操作的时候，父类的原型也会有此属性。 那么父类的所有自类都会有该属性。 原型式继承目的：将子类对象的原型指向父类对象的原型的新的空的中间层。 如果不设置该空的中间层，那么就会像父类原型赋值给子类一样。所以需要设置一个中间层，来放置子类的属性，从而不改变父类里面的属性。 1234567891011121314151617181920212223242526272829var obj = &#123; name: &#x27;foo&#x27;, age: 18,&#125;//等同于下面的原型式继承函数var info = Object.create(obj)// 原型式继承函数function createObject1(o) &#123; //创建空对象 var newObj = &#123;&#125; //将空对象的函数原型设置为参数的函数原型 Object.setPrototypeOf(newObj, o) //将新对象返回 return newObj&#125;function createObject2(o) &#123; function Fn() &#123;&#125; Fn.prototype = o var newObj = new Fn() return newObj&#125;// var info = createObject2(obj)var info = Object.create(obj)console.log(info)console.log(info.__proto__) 寄生式类似于工厂模式，直接将该对象创建好，直接引用就可以。 12345678910111213141516171819var personObj = &#123; running: function () &#123; console.log(&#x27;running&#x27;) &#125;,&#125;function createStudent(name) &#123; var stu = Object.create(personObj) stu.name = name stu.studying = function () &#123; console.log(this.name + &#x27;studying~&#x27;) &#125; return stu&#125;var stuObj = createStudent(&#x27;Oliver&#x27;)var stuObj1 = createStudent(&#x27;kobe&#x27;)var stuObj2 = createStudent(&#x27;james&#x27;)stuObj.studying() 寄生组合式将借用构造函数式与寄生是相结合，实现相对于齐全的继承方案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function createObject(o) &#123; function Fn() &#123;&#125; Fn.prototype = o return new Fn()&#125;function inheritPrototype(SubType, SuperType) &#123; SubType.prototype = Objec.create(SuperType.prototype) Object.defineProperty(SubType.prototype, &#x27;constructor&#x27;, &#123; enumerable: false, configurable: true, writable: true, value: SubType, &#125;)&#125;function Person(name, age, friends) &#123; this.name = name this.age = age this.friends = friends&#125;Person.prototype.running = function () &#123; console.log(&#x27;running~&#x27;)&#125;Person.prototype.eating = function () &#123; console.log(&#x27;eating~&#x27;)&#125;function Student(name, age, friends, sno, score) &#123; //将Person构造函数放在我们子类中，实现也可以传递相关参数 Person.call(this, name, age, friends) this.sno = sno this.score = score&#125;//继承函数，建立继承关系inheritPrototype(Student, Person)Student.prototype.studying = function () &#123; console.log(&#x27;studying~&#x27;)&#125;var stu = new Student(&#x27;Oliver&#x27;, 18, [&#x27;kobe&#x27;], 111, 100)console.log(stu)stu.studying()stu.running()stu.eating()console.log(stu.constructor.name) 总结Js 中的原型与原型链是很重要的部分，需要反复揣摩其中的思路，实现方法。","categories":[{"name":"底层逻辑","slug":"底层逻辑","permalink":"http://oliverxuan.github.io/categories/%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://oliverxuan.github.io/tags/JavaScript/"}]},{"title":"HTML/CSS常见问题","slug":"HTML-CSS常见问题","date":"2021-10-18T12:29:09.000Z","updated":"2021-11-01T12:30:25.941Z","comments":true,"path":"2021/10/18/HTML-CSS常见问题/","link":"","permalink":"http://oliverxuan.github.io/2021/10/18/HTML-CSS%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","excerpt":"HTML常识1.如何理解 HTML 语义化？HTML 语义化就是将文字，将内容的消息进行了划分。 比如 h1，人们一看就明白这个是最大的标题。那么我们如果用 div 标签来做，我们结合 CSS 样式也可以做出最大标题的样子 1234567&lt;div&gt; &lt;div&gt;你好！&lt;/div&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;你好！&lt;/p&gt;&lt;/div&gt; 优点： 让人更容易读懂（增强代码的可读性） 让搜索引擎更容易读懂（SEO） 2.在默认情况下，哪些 HTML 标签是块状元素，哪些是内联元素？块状元素：在一般情况下，块状元素在行内都会独占一行。","text":"HTML常识1.如何理解 HTML 语义化？HTML 语义化就是将文字，将内容的消息进行了划分。 比如 h1，人们一看就明白这个是最大的标题。那么我们如果用 div 标签来做，我们结合 CSS 样式也可以做出最大标题的样子 1234567&lt;div&gt; &lt;div&gt;你好！&lt;/div&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;你好！&lt;/p&gt;&lt;/div&gt; 优点： 让人更容易读懂（增强代码的可读性） 让搜索引擎更容易读懂（SEO） 2.在默认情况下，哪些 HTML 标签是块状元素，哪些是内联元素？块状元素：在一般情况下，块状元素在行内都会独占一行。 eg：display:block/table;有 div h1 h2 table ul ol p 等 内联元素：在一般情况下，内联元素在行内不独占一行，会挨着排列。 eg: inline/inline-block；有 span img input button 等 块状元素 内联元素 address - 地址blockquote - 块引用center - 举中对齐块dir - 目录列表div - 常用块级容易，也是 CSS layout 的主要标签dl - 定义列表fieldset - form 控制组form - 交互表单h1 - 大标题h2 - 副标题h3 - 3 级标题h4 - 4 级标题h5 - 5 级标题h6 - 6 级标题hr - 水平分隔线isindex - input promptmenu - 菜单列表noframes - frames 可选内容，noscript - 可选脚本内容ol - 排序表单p - 段落pre - 格式化文本table - 表格ul - 非排序列表 a - 锚点abbr - 缩写acronym - 首字b - 粗体(不推荐)bdo - bidi overridebig - 大字体br - 换行cite - 引用code - 计算机代码(在引用源码的时候需要)dfn - 定义字段em - 强调font - 字体设定(不推荐)i - 斜体img - 图片input - 输入框kbd - 定义键盘文本label - 表格标签q - 短引用s - 中划线(不推荐)samp - 定义范例计算机代码select - 项目选择small - 小字体文本span - 常用内联容器，定义文本内区块strike - 中划线strong - 粗体强调sub - 下标sup - 上标textarea - 多行文本输入框tt - 电传文本u - 下划线var - 定义变量 CSS布局1.盒子模型的宽度如何计算？offsetWidth = （内容宽度+内边距+边距），无外边距。 2.如何将盒子的大小与 offsetWidth 设置相同？1box-sizing: border-box; 3.margin 纵向重叠问题1234567891011121314&lt;style&gt; p &#123; font-size: 16px; line-height: 1; margin-top: 10px; margin-bottom: 15px; &#125;&lt;/style&gt;&lt;p&gt;AAA&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;BBB&lt;/p&gt; 该 AAA 和 BBB 之间的距离是多少？ 15px 相邻元素的 margin-top 和 margin- bottom 会发生重叠。 空白内容的 p 标签也会发生重叠。 4.margin 的负值问题margin 的负值，会相反地进行对应的上下左右移动。 eg：margin-top：-20px 则为向上平移 20px 5.BFC 理解和应用BFC（块级格式化上下文）：一块独立渲染区域，内部元素的渲染不会影响到边界以外的元素。 常见形成 BFC 的条件： float 不是 none position 是 absolute 或 fixed overflow 不是 visible display 是 flex inline- block 等 6.圣杯布局和双飞翼布局特征： 三栏布局，中间一栏最先加载和渲染（内容最重要） 两侧内容固定，中间内容随着宽度自适应 一般用于 PC 页面 技术点： 使用 float 布局 两侧使用 margin 负值，以便和中间内容横向重叠 防止中间内容被两侧覆盖，一个用 padding 一个用 margin 圣杯布局： 使用 padding 将两边的边距拉出来 123456789101112131415161718192021222324252627282930313233343536373839 &lt;style&gt; .container &#123; min-width: 400px; /*设置左右边距，为左右栏留出空隙*/ padding-left: 200px; padding-right: 150px; &#125; /*整体向左浮动*/ .c &#123; float: left; &#125; .main &#123; width: 100%; background-color: red; &#125; .left &#123; position: relative; width: 200px; background-color: skyblue; right: 200px; margin-left: -100%; &#125; .right &#123; width: 150px; background-color: skyblue; margin-right: -150px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;main c&quot;&gt;中间&lt;/div&gt; &lt;div class=&quot;left c&quot;&gt;左边&lt;/div&gt; &lt;div class=&quot;right c&quot;&gt;右边&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 双飞翼布局： 使用 margin 将边距拉出来 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 &lt;style&gt; body &#123; max-width: 550px; &#125; .col &#123; float: left; &#125; #main &#123; width: 100%; height: 200px; background-color: #ccc; &#125; #main-wrap &#123; margin-left: 190px; margin-right: 190px; &#125; #left &#123; width: 190px; height: 200px; margin-left: -100%; background-color: #0000FF; &#125; #right &#123; width: 190px; height: 200px; margin-right: -190px; background-color: #FF0000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;main&quot; class=&quot;col&quot;&gt; &lt;div id=&quot;main-wrap&quot;&gt; this is main &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;left&quot; class=&quot;col&quot;&gt; this is left &lt;/div&gt; &lt;div id=&quot;right&quot; class=&quot;col&quot;&gt; this is right &lt;/div&gt;&lt;/body&gt; 7.手写 clearfix12345.clearfix:after&#123;content:&#x27;&#x27;;dispaly:table;clear:both;&#125; 8.flex1.flex 基本使用 启用 flex：display：flex flex-directionflex items 默认都是沿着 main axis（主轴）从 main start 开始往 main end 方向排布flex-direction 决定了 main axis 的方向，有四个取值 row（默认值）、row-reverse、column、column-reverserow（默认值）：主轴为水平方向，起点在左端。row-reverse：主轴为水平方向，起点在右端。column：主轴为垂直方向，起点在上沿。column-reverse：主轴为垂直方向，起点在下沿。 justify-content 决定了 flex item 在 main axis（主轴）上的对齐方式 flex-start(默认值):与 main start 对齐flex-end：与 main end 对齐center：居中space-between：flex items 之间的距离相等，与 main start、main end 两端对齐space-evenly: flex items 之间的距离相等,flex items 与 main start 、main end 之间的距离等于 flex items 之间的距离space-around :flex items 之间的距离相等,flex items 与 main start 、main end 之间的距离等于 flex items 之间的距离的一半 align-items align-items 属性定义项目在交叉轴上如何对齐。 align-items: flex-start | flex-end | center | baseline | stretch; 2.flex 水平垂直居中123display: flex; /*父元素设置flex属性*/justify-content: center; /*水平主轴居中*/align-items: center; /*垂直交叉轴居中*/ 3.flex 实现三点骰子12345678910111213141516171819202122232425262728293031323334353637&lt;style&gt; .box &#123; width: 200px; height: 200px; border: 2px solid #ccc; border-radius: 10px; padding: 20px; display: flex; justify-content: space-between; &#125; .item:nth-child(2) &#123; align-self: center; &#125; .item:nth-child(3) &#123; align-self: flex-end; &#125; .item &#123; display: block; width: 40px; height: 40px; border-radius: 50%; background-color: #666; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;/div&gt;&lt;/body&gt; 定位1.absolute 和 relative 分别依据什么定位？relative：依据自身定位，不会对外层元素造成影响。 absolute：依据最近一层的定位元素定位。向上查找直到 body。 2.居中对齐都有哪些实现方式？水平居中： inline 元素：text- align：center block 元素：margin：auto absolute 元素：left：50%+margin-left 负值 垂直居中： inline 元素：line- height 的值等于 height 值 absolute 元素：top：50%+margin-top 负值 absolute 元素：transform（-50%，-50%） absolute 元素：top，left，bottom，right=0+margin：auto 图文样式1.line-height 如何继承 写具体数值，如 30px，则继承该值 写比例，如 2，2.5 此类，则继承该比例 写百分比，如 200%，则继承计算出来的值（重点） 响应式1.rem 是什么？rem 是一个长度单位。 px，绝对长度单位，最常用。 em，相对长度单位，相对父元素，不常用。 rem，相对长度单位，相对于跟元素，常用于响应式布局。 2.响应式的常见方案 media- query，根据不同的屏幕宽度设置根元素 font-size rem，基于根元素的相对单位 3.rem 的弊端：“阶梯”性其实 rem 的实用性并不好，阶梯形产生了一些不适配 4.网页视口尺寸 window.screen.height 屏幕高度 window.innerHeight 网页视口高度 document.body.clienHeight body 高度 5.vw vh vh 网页视口高度的百分之一 vw 网页视口宽度的百分之一 vmax vh vw 中取最大值 vmin vh vw 中取最小值","categories":[{"name":"练习题","slug":"练习题","permalink":"http://oliverxuan.github.io/categories/%E7%BB%83%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"http://oliverxuan.github.io/tags/HTML-CSS/"}]},{"title":"node后端项目初始化","slug":"node后端项目初始化","date":"2021-10-07T05:23:57.000Z","updated":"2021-10-25T06:54:33.967Z","comments":true,"path":"2021/10/07/node后端项目初始化/","link":"","permalink":"http://oliverxuan.github.io/2021/10/07/node%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96/","excerpt":"前言： 在一些简单的前后端分离的项目中，我们可以选择使用 node 来快速搭建我们的后端系统。在之前，我做的项目《面面俱到》就是使用的 node+Koa 作为后端框架来快速搭建的。基本完成了所需要的功能。最近开始了新的 app 制作，程序这东西真的长时间不写就会手生。所以借此机会。我将我初始化 node 项目的过程记录下来 具体实现初始化 node 文件夹1npm init -y 我们将最基础的项目目录搭建出来 在此时，我们会得到一个简单的 package.json 文件。此文件包含了我们项目所需的基础信息，运行脚本，运行环境。 npm Koa 框架1npm install koa","text":"前言： 在一些简单的前后端分离的项目中，我们可以选择使用 node 来快速搭建我们的后端系统。在之前，我做的项目《面面俱到》就是使用的 node+Koa 作为后端框架来快速搭建的。基本完成了所需要的功能。最近开始了新的 app 制作，程序这东西真的长时间不写就会手生。所以借此机会。我将我初始化 node 项目的过程记录下来 具体实现初始化 node 文件夹1npm init -y 我们将最基础的项目目录搭建出来 在此时，我们会得到一个简单的 package.json 文件。此文件包含了我们项目所需的基础信息，运行脚本，运行环境。 npm Koa 框架1npm install koa 我们此时将最基本的项目依赖已经部署好了，但此时我们的项目如同一盘散沙，没有结构。 划分目录结构 main.js其中 main.js 为我们启动程序的入口。 12345678910111213//koa 导入const app = require(&#x27;./app&#x27;)//数据库js文件导入require(&#x27;./app/database&#x27;)//配置文件导入const config = require(&#x27;./app/config&#x27;)//服务器启动app.listen(config.APP_PORT, () =&gt; &#123; console.log(`服务器在：$&#123;config.APP_PORT&#125; 端口启动成功～`)&#125;) app 文件夹app 文件夹，其中包含了很多关于全局操作的文件，例如 key：是我们程序中颁发 Token，解密 Token 时所需要的公钥和私钥。 config.js是我们程序中相关配置信息的处理 js 文件 12345678910111213141516171819202122232425262728//导入dotenv配置管理插件const dotenv = require(&#x27;dotenv&#x27;)//导入fs文件管理插件const fs = require(&#x27;fs&#x27;)//启动dotenv插件相关操作dotenv.config()//读取私钥const PRIVATE_KEY = fs.readFileSync(&#x27;src/app/keys/private.key&#x27;)//读取公钥const PUBLIC_KEY = fs.readFileSync(&#x27;src/app/keys/public.key&#x27;)//读取.env中的配置信息module.exports = &#123; APP_PORT, MYSQL_HOST, MYSQL_PORT, MYSQL_DATABASE, MYSQL_ROOT, MYSQL_PASSWORD,&#125; = process.env//key导出module.exports.PRIVATE_KEY = PRIVATE_KEYmodule.exports.PUBLIC_KEY = PUBLIC_KEY .env.env 文件相对于来说是需要 coder 进行严格保密的文件，其中包含了许多重要的信息，我们不能随意将其暴露出去（key 也是）。在进行 git push 的过程中，也不要忘记在gitignore 文件中加上.env 忽略！ 123456789# 服务器端口号APP_PORT=1234# mysql配置MYSQL_HOST=123.1.123.123MYSQL_PORT=6666MYSQL_DATABASE=demoMYSQL_ROOT=DemoMYSQL_PASSWORD=demo 我们需要做到，每个 coder 在 clone 你的程序后，通过自建.env 文件就能将其相关的配置信息导入，这将大大提升效率和安全性。 database.js该文件夹是用来进行数据库相关操作的 js 文件。我们可以通过 database.js 对我们的数据库操作进行快速的初始化。 1234567891011121314151617181920212223242526272829303132//数据库插件导入const mysql = require(&#x27;mysql2&#x27;)//配置文件信息导入const config = require(&#x27;./config&#x27;)//建立数据库连接池const connections = mysql.createPool(&#123; //配置数据库主机信息 host: config.MYSQL_HOST, //端口号 port: config.MYSQL_PORT, //将要连接的数据库名 database: config.MYSQL_DATABASE, //root用户名 user: config.MYSQL_ROOT, //root密码 password: config.MYSQL_PASSWORD,&#125;)//取得数据库连接并运行判断，常常用于程序最开始。connections.getConnection((err, conn) =&gt; &#123; conn.connect((err) =&gt; &#123; if (err) &#123; console.log(&#x27;数据库连接失败!&#x27;) &#125; else &#123; console.log(&#x27;数据库连接成功！&#x27;) &#125; &#125;)&#125;)//将数据库的连接形式以promise的方式导出。module.exports = connections.promise() error- handle.js常用于当前端用户请求格式，数据测试错误的时候，我们将给他一个具体的错误体现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445//导入错误类型文件const errorTypes = require(&#x27;../constants/error-types&#x27;)//定义error Handler函数const errorHandler = (error, ctx) =&gt; &#123; let status, message //对错误类型进行判断，并根据错误类型返还status code switch (error.message) &#123; case errorTypes.NAME_OR_PASSWORD_IS_REQUIRED: status = 400 //Bad request message = &#x27;用户名或者密码为空&#x27; break case errorTypes.USER_ALREADY_EXISTS: status = 409 //Conflict message = &#x27;用户名已存在&#x27; break case errorTypes.USER_DOES_NOT_EXISTS: status = 400 //参数错误 message = &#x27;用户名不存在&#x27; break case errorTypes.PASSWORD_IS_INCORRENT: status = 400 //参数错误 message = &#x27;用户密码错误!&#x27; break case errorTypes.PASSWORD_IS_INCORRENT: status = 400 //参数错误 message = &#x27;用户密码错误!&#x27; break case errorTypes.UNAUTHORIZATION: status = 401 //参数错误 message = &#x27;TOKEN验证不通过&#x27; break default: status = 404 message = &#x27;NOT FOUND&#x27; &#125; //设置status ctx.status = status //打印错误信息 ctx.body = message&#125;module.exports = errorHandler index.js该文件是可以称作程序的第二大脑，第二入口。他将一些插件，koa 的初始化，跨域等方法集成在 index.js 文件中。 12345678910111213141516171819// app操作//导入koa插件const Koa = require(&#x27;koa&#x27;)const bodyParser = require(&#x27;koa-bodyparser&#x27;)const errorHandler = require(&#x27;./error-handle&#x27;)const useRoutes = require(&#x27;../router&#x27;)//koa跨域插件const cors = require(&#x27;@koa/cors&#x27;)const app = new Koa()//Koa 跨域插件app.use(cors())app.use(bodyParser())useRoutes(app)app.on(&#x27;error&#x27;, errorHandler)//将app导出暴露module.exports = app constants 文件夹该文件定义了一些常能用到的，但不属于其他结构的中立 js 文件。 error-types.js在此文件中，列出了用户操作的过程中，可能出现的一些错误。 123456789101112131415//定义一些错误类型const NAME_OR_PASSWORD_IS_REQUIRED = &#x27;name_or_password_is_required&#x27;const USER_ALREADY_EXISTS = &#x27;user_already_exists&#x27;const USER_DOES_NOT_EXISTS = &#x27;user_does_not_exists&#x27;const PASSWORD_IS_INCORRENT = &#x27;password_is_incorrent&#x27;const UNAUTHORIZATION = &#x27;unauthorization&#x27;//导出相关的错误类型module.exports = &#123; NAME_OR_PASSWORD_IS_REQUIRED, USER_ALREADY_EXISTS, USER_DOES_NOT_EXISTS, PASSWORD_IS_INCORRENT, UNAUTHORIZATION,&#125; controller 文件夹该文件夹常用于接口文件的具体操作管理，就如同它的名字，controller eg:user.controller.js 12345678910111213141516171819202122//导入数据库操作文件const service = require(&#x27;../service/user.service&#x27;)//通常以类的形式打头class UserController &#123; //进行具体的一些操作 //用户注册 async create(ctx, next) &#123; //获取参数 const user = ctx.request.body //创建用户信息 const result = await service.create(user) //返回数据 console.log(user.name + &#x27;创建用户成功&#x27;) ctx.body = &#x27;用户创建成功&#x27; &#125;&#125;//将UserController的new对象导出module.exports = new UserController() middleware 文件夹middleware 中间件，其中包含了很多的程序所需的操作，不同于 service 文件夹，他不涉及数据库操作。 eg: user.middleware.js 12345678910111213141516171819202122232425262728293031323334353637383940const errorType = require(&#x27;../constants/error-types&#x27;)const service = require(&#x27;../service/user.service&#x27;)const md5password = require(&#x27;../utils/password-handle&#x27;)//验证用户输入的正确性const verifyUser = async (ctx, next) =&gt; &#123; //获取用户名，密码 const &#123; name, password &#125; = ctx.request.body console.log(&#x27;用户&#x27; + name + &#x27;正在尝试后端服务&#x27;) //判断不能为空 if (!name || !password) &#123; const error = new Error(errorType.NAME_OR_PASSWORD_IS_REQUIRED) return ctx.app.emit(&#x27;error&#x27;, error, ctx) &#125; //判断本次注册的用户名是否被注册 const result = await service.getUserByName(name) if (result.length) &#123; const error = new Error(errorType.USER_ALREADY_EXISTS) return ctx.app.emit(&#x27;error&#x27;, error, ctx) &#125; await next()&#125;//md5加密密码const handlePassword = async (ctx, next) =&gt; &#123; const &#123; password &#125; = ctx.request.body ctx.request.body.password = md5password(password) await next()&#125;//最后别忘记将写好的方法导出！module.exports = &#123; verifyUser, handlePassword,&#125; router 文件夹该文件夹主要是注册一些程序的接口。并定义该接口在被调用的时候进行什么操作。 eg: user.router.js 123456789101112131415// 路由相关的js 注册接口适用const Router = require(&#x27;koa-router&#x27;)const &#123; create &#125; = require(&#x27;../controller/user.controller&#x27;)const &#123; verifyUser, handlePassword &#125; = require(&#x27;../middleware/user.middleware&#x27;)//入口const userRouter = new Router(&#123; prefix: &#x27;/users&#x27; &#125;)//用户注册接口userRouter.post(&#x27;/register&#x27;, verifyUser, handlePassword, create)module.exports = userRouter index.js123456789101112131415//导入fs相关插件const fs = require(&#x27;fs&#x27;)//自动化注册处理router程序const useRoutes = (app) =&gt; &#123; fs.readdirSync(__dirname).forEach((file) =&gt; &#123; if (file === &#x27;index.js&#x27;) return const router = require(`./$&#123;file&#125;`) app.use(router.routes()) app.use(router.allowedMethods()) &#125;)&#125;//导出useRouter文件module.exports = useRoutes service 文件夹该文件夹主要是对接数据库的操作。 eg: user.service.js 1234567891011121314151617181920212223242526272829303132//导入数据库操作配置文件const connection = require(&#x27;../app/database&#x27;)//新建数据库操作类class UserService &#123; async create(user) &#123; //获取传递的参数 const &#123; name, password &#125; = user //sql语句 const statement = &#x27;INSERT INTO users (name,password) VALUES (?,?);&#x27; //执行数据库操作 const reslut = await connection.execute(statement, [name, password]) //返回数据 return reslut[0] &#125; async getUserByName(name) &#123; const statement = `SELECT * FROM users WHERE name = ?;` const result = await connection.execute(statement, [name]) return result[0] &#125; async getNameById(userId) &#123; const statement = `SELECT u.type,u.isflag,u.fix,u.createAt FROM users u WHERE id=?;` const result = await connection.execute(statement, [userId]) return result[0][0] &#125;&#125;//将数据的操作方法导出module.exports = new UserService() utils 文件夹该文件夹主要是一些工具性质的 js 文件/方法，比如我们这里使用到了密码加密方法，我们也可以新增一些其他的方法，帮助我们编写代码。 版本依赖 总结通过这次对 node-koa 后端项目创建过程的总结，渐渐熟悉掌握了这种开发模式，在以后的开发中也可以更加得心应手！","categories":[{"name":"技术实现","slug":"技术实现","permalink":"http://oliverxuan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://oliverxuan.github.io/tags/node-js/"}]},{"title":"Js中的构造函数及原型","slug":"Js中的构造函数及原型","date":"2021-09-22T09:33:31.000Z","updated":"2021-09-22T10:24:51.258Z","comments":true,"path":"2021/09/22/Js中的构造函数及原型/","link":"","permalink":"http://oliverxuan.github.io/2021/09/22/Js%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%8A%E5%8E%9F%E5%9E%8B/","excerpt":"构造函数Js 中的构造函数与 Java 的构造函数思想区别不大，只是需要注意下细节。 1234567891011121314151617181920212223// 规范: 构造函数的首字母一般是大写function Person(name, age, height, address) &#123; this.name = name this.age = age this.height = height this.address = address this.eating = function () &#123; console.log(this.name + &#x27;在吃东西~&#x27;) &#125; this.running = function () &#123; console.log(this.name + &#x27;在跑步&#x27;) &#125;&#125;var p1 = new Person(&#x27;张三&#x27;, 18, 1.88, &#x27;广州市&#x27;)var p2 = new Person(&#x27;李四&#x27;, 20, 1.98, &#x27;北京市&#x27;)console.log(p1)console.log(p2)p1.eating()p2.eating() 构造函数的缺点：容易产生很多的代码冗余，例如这里的 eating，running。 构造函数中的 new如果一个函数被使用 new 操作符调用了，那么它会执行如下操作： 在内存中创建一个新的对象（空对象）； 这个对象内部的[[prototype]]属性会被赋值为该构造函数的 prototype 属性； 构造函数内部的 this，会指向创建出来的新对象； 执行函数的内部代码（函数体代码）； 如果构造函数没有返回非空对象，则返回创建出来的新对象； 对象原型JavaScript 当中每个对象都有一个特殊的内置属性 [[prototype]]，这个特殊的对象可以指向另外一个对象。 我们可以通过 _ proto _ / Object.getPrototypeOf 来查看对象的对象原型","text":"构造函数Js 中的构造函数与 Java 的构造函数思想区别不大，只是需要注意下细节。 1234567891011121314151617181920212223// 规范: 构造函数的首字母一般是大写function Person(name, age, height, address) &#123; this.name = name this.age = age this.height = height this.address = address this.eating = function () &#123; console.log(this.name + &#x27;在吃东西~&#x27;) &#125; this.running = function () &#123; console.log(this.name + &#x27;在跑步&#x27;) &#125;&#125;var p1 = new Person(&#x27;张三&#x27;, 18, 1.88, &#x27;广州市&#x27;)var p2 = new Person(&#x27;李四&#x27;, 20, 1.98, &#x27;北京市&#x27;)console.log(p1)console.log(p2)p1.eating()p2.eating() 构造函数的缺点：容易产生很多的代码冗余，例如这里的 eating，running。 构造函数中的 new如果一个函数被使用 new 操作符调用了，那么它会执行如下操作： 在内存中创建一个新的对象（空对象）； 这个对象内部的[[prototype]]属性会被赋值为该构造函数的 prototype 属性； 构造函数内部的 this，会指向创建出来的新对象； 执行函数的内部代码（函数体代码）； 如果构造函数没有返回非空对象，则返回创建出来的新对象； 对象原型JavaScript 当中每个对象都有一个特殊的内置属性 [[prototype]]，这个特殊的对象可以指向另外一个对象。 我们可以通过 _ proto _ / Object.getPrototypeOf 来查看对象的对象原型 所有的函数都有一个 prototype 属性 12345678910111213function foo() &#123;&#125;// 函数也是一个对象// console.log(foo.__proto__) // 函数作为对象来说, 它也是有[[prototype]] 隐式原型// 函数它因为是一个函数, 所以它还会多出来一个显示原型属性: prototypeconsole.log(foo.prototype)var f1 = new foo()var f2 = new foo()console.log(f1.__proto__ === foo.prototype)console.log(f2.__proto__ === foo.prototype) new 创建新的对象时 在内存中创建一个新的对象（空对象）； 这个对象内部的[[prototype]]属性会被赋值为该构造函数的 prototype 属性； 对象原型的应用12345678910111213141516171819202122232425262728293031function Person(name, age, height, address) &#123; this.name = name this.age = age this.height = height this.address = address&#125;//在上构造函数的方式创建对象时，有一个弊端：会创建出重复的函数，比如running、eating这些函数//所以我们这里使用prototype来给对象原型添加方法，属性Person.prototype.eating = function () &#123; console.log(this.name + &#x27;在吃东西~&#x27;)&#125;Person.prototype.running = function () &#123; console.log(this.name + &#x27;在跑步~&#x27;)&#125;var p1 = new Person(&#x27;OLiver&#x27;, 18, 1.88, &#x27;北京市&#x27;)var p2 = new Person(&#x27;kobe&#x27;, 20, 1.98, &#x27;洛杉矶市&#x27;)p1.eating()p2.eating()Person.prototype.page = &#x27;xuan&#x27;p1.eating() // Oliver在吃东西~p2.eating() // kobe在吃东西~//当当前的p1对象中没有定义page时则会向上查找，此处为Person中的pageconsole.log(p1.page) // xuanp2.page = &#x27;Oliver-xuan&#x27;console.log(p2.page) // Oliver-xuan 总结Js 中的对象原型给我的感觉就像是 JAVA 中的父类，我们在父类中定义一些方法，子类可以继承该方法，属性。 例如此处我们定义了 eating running 两个方法，我们在子类中并没有对其进行一些定义赋值，但是我们可以用 new 出来的对象直接使用。 正是因为 this 的存在，在构造器中的 this 也会以一种隐式绑定的方式，this 绑定到调用的对象上。如 p1.running 这里 running 的 this 就是 p1.","categories":[{"name":"底层逻辑","slug":"底层逻辑","permalink":"http://oliverxuan.github.io/categories/%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://oliverxuan.github.io/tags/JavaScript/"}]},{"title":"浅谈Js面向对象","slug":"浅谈Js面向对象","date":"2021-09-22T07:56:46.000Z","updated":"2021-09-22T09:36:32.953Z","comments":true,"path":"2021/09/22/浅谈Js面向对象/","link":"","permalink":"http://oliverxuan.github.io/2021/09/22/%E6%B5%85%E8%B0%88Js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"万事万物皆对象。这句话是我以前在学习 JAVA 时的感悟。 现实生活中的万事万物，都可以抽象为程序中的对象。比如人：多高，多重，性别，姓名，能吃饭，唱歌。我们都可以把他抽象为代码中的对象，该对象的属性，方法，对应了人的特征，能做什么。 Js 面向对象 JavaScript 其实支持多种编程范式的，包括函数式编程和面向对象编程： JavaScript 中的对象被设计成一组属性的无序集合，像是一个哈希表，有 key 和 value 组成； key 是一个标识符名称，value 可以是任意类型，也可以是其他对象或者函数类型； eg: name:Oliver 如果值是一个函数，那么我们可以称之为是对象的方法； JS 创建对象的方式 通过 new 的方式来创建： 1234567var obj = new Object()obj.name = &#x27;Oliver&#x27;obj.age = 21obj.height = 1.8obj.running = function () &#123; console.log(this.name + &#x27;在跑步~&#x27;)&#125; 字面量形式 12345678var info = &#123; name: &#x27;Oliver&#x27;, age: 20, height: 1.8, eating: function () &#123; console.log(this.name + &#x27;在吃东西~&#x27;) &#125;,&#125;","text":"万事万物皆对象。这句话是我以前在学习 JAVA 时的感悟。 现实生活中的万事万物，都可以抽象为程序中的对象。比如人：多高，多重，性别，姓名，能吃饭，唱歌。我们都可以把他抽象为代码中的对象，该对象的属性，方法，对应了人的特征，能做什么。 Js 面向对象 JavaScript 其实支持多种编程范式的，包括函数式编程和面向对象编程： JavaScript 中的对象被设计成一组属性的无序集合，像是一个哈希表，有 key 和 value 组成； key 是一个标识符名称，value 可以是任意类型，也可以是其他对象或者函数类型； eg: name:Oliver 如果值是一个函数，那么我们可以称之为是对象的方法； JS 创建对象的方式 通过 new 的方式来创建： 1234567var obj = new Object()obj.name = &#x27;Oliver&#x27;obj.age = 21obj.height = 1.8obj.running = function () &#123; console.log(this.name + &#x27;在跑步~&#x27;)&#125; 字面量形式 12345678var info = &#123; name: &#x27;Oliver&#x27;, age: 20, height: 1.8, eating: function () &#123; console.log(this.name + &#x27;在吃东西~&#x27;) &#125;,&#125; Js 属性操作 常规操作 12345678//赋值obj.name = &#x27;Oliver&#x27;//获取console.log(obj.name)//遍历 打印对象中所存在的属性for (var key in obj) &#123; console.log(key)&#125; defineProperty 方法1234567891011121314var obj = &#123; name: &#x27;Oliver&#x27;, age: 21,&#125;// 属性描述符是一个对象Object.defineProperty(obj, &#x27;height&#x27;, &#123; // 很多的配置 value: 1.88,&#125;)console.log(obj) //&#123; name: &#x27;why&#x27;, age: 18 &#125;console.log(obj.height) //1.88 对属性操作的控制以前在 Java 中，我们常常会用到 Private 对一些对象的属性进行限制。那 Js 中是否也存在这种操作呢？ defineProperty 数据属性描述符 Object.defineProperty(obj,prop,descriptor) 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此 可接收三个参数： obj 要定义属性的对象； prop 要定义或修改的属性的名称或 Symbol； descriptor 要定义或修改的属性描述符； 返回值：被传递给函数的对象。 对象。 value 该属性的值； 默认值 undefined ； configurable ** 该属性是否能修改**，配置； 默认值 false enumerable 该属性是否能枚举； 默认值 false writable 该属性是否能赋值，写入； 默认值 false 直接给对象的属性定义的时候，configurable，enumerable，writable 都为 true 12345678910111213var obj = &#123; name: &quot;Oliver&quot;, age: 21&#125;Object.defineProperty(obj, &quot;address&quot;, &#123; value: &quot;四川省&quot; // 默认值undefined // 是否可以配置 该特殊不可删除/也不可以重新定义属性描述符 configurable: false, // 默认值false // 该特殊是配置对应的属性(address)是否是可以枚举，通过log等等方式 enumerable: true, // 默认值false // 该特性是属性是否是可以赋值(写入值) writable: false // 默认值false&#125;) defineProperties()数据属性描述符（多个） Object.defineProperties() 方法直接在一个对象上定义 多个 新的属性或修改现有属性，并且返回该对象。 存储属性描述符 存取属性描述符 隐藏某一个私有属性被希望直接被外界使用和赋值 如果我们希望截获某一个属性它访问和设置值的过程时, 也会使用存储属性描述符 1234567891011121314151617181920212223242526272829303132333435var obj = &#123; name: &#x27;oliver&#x27;, age: 21, //约定俗成，在变量属性前添加 _ “下划线”表示该属性为私有的，不想别人随意改变其中的内容 _address: &#x27;四川省&#x27;,&#125;Object.defineProperty(obj, &#x27;address&#x27;, &#123; enumerable: true, configurable: true, // get方法获取对象中的私有属性 get: function () &#123; foo() return this._address &#125;, //set方法来设置私有属性的值 set: function (value) &#123; bar() this._address = value &#125;,&#125;)console.log(obj.address)obj.address = &#x27;上海市&#x27;console.log(obj.address)function foo() &#123; console.log(&#x27;获取了一次address的值&#x27;)&#125;function bar() &#123; console.log(&#x27;设置了addres的值&#x27;)&#125; 其他方法补充getOwnPropertyDescriptor 可以获取对象的某一属性的属性描述符 12// 获取某一个特性属性的属性描述符console.log(Object.getOwnPropertyDescriptor(obj, &#x27;name&#x27;)) getOwnPropertyDescriptors 12// 获取对象的所有属性描述符console.log(Object.getOwnPropertyDescriptors(obj)) preventExtensions 禁止对象扩展新属性 给一个对象添加新的属性会失败（在严格模式下会报错）； seal 密封对象，不允许配置和删除属性 实际是调用preventExtensions 并且将现有属性的configurable:false freeze 冻结对象，不允许修改现有属性： 实际上是调用seal 并且将现有属性的writable: false 总结Javascript 中的创建对象的思想，其实和 Java 中也算是大同小异，包括一些构造器，Js 中使用 function 来作为构造器的使用。其中的一些私有的方法在 JavaScript 中也有体现。 总的来说 Js 中的对象使用上更灵活，方法也更多。需要勤加使用练习。","categories":[{"name":"底层逻辑","slug":"底层逻辑","permalink":"http://oliverxuan.github.io/categories/%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://oliverxuan.github.io/tags/JavaScript/"}]},{"title":"Js中的严格模式","slug":"Js中的严格模式","date":"2021-09-16T05:10:04.000Z","updated":"2021-09-16T05:45:56.749Z","comments":true,"path":"2021/09/16/Js中的严格模式/","link":"","permalink":"http://oliverxuan.github.io/2021/09/16/Js%E4%B8%AD%E7%9A%84%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/","excerpt":"在 JavaScript 中，我们常常在非严格模式/松散模式下进行编译。Js 会将一些语法的错误保持静默，像是睁一只眼闭一只眼。在严格模式下，这些错误就会被 Js 揪出来。 JS 语法补充with 语句12345678910111213141516var obj = &#123; age: 1, mes: &#x27;like&#x27;,&#125;function foo() &#123; function bar() &#123; //现在obj里找，没有就一直向上找 with (obj) &#123; console.log(mes) &#125; &#125; bar()&#125;foo() 在 with 语句中，我们可以给其指定一个对象，使其中的语句优先查找对象中的相关内容。 如果该对象中没有改属性，则就一直向上查找，直到全局。 并不建议使用 with，其代码可读性差，容易产生混淆错误兼容性问题。 eval 函数eval 是一个特殊的函数，它可以将传入的字符串当做 JavaScript 代码来运行。 123var evalString = `var message = &quot;Hello&quot;;console.log(message);`eval(evalString)console.log(message)","text":"在 JavaScript 中，我们常常在非严格模式/松散模式下进行编译。Js 会将一些语法的错误保持静默，像是睁一只眼闭一只眼。在严格模式下，这些错误就会被 Js 揪出来。 JS 语法补充with 语句12345678910111213141516var obj = &#123; age: 1, mes: &#x27;like&#x27;,&#125;function foo() &#123; function bar() &#123; //现在obj里找，没有就一直向上找 with (obj) &#123; console.log(mes) &#125; &#125; bar()&#125;foo() 在 with 语句中，我们可以给其指定一个对象，使其中的语句优先查找对象中的相关内容。 如果该对象中没有改属性，则就一直向上查找，直到全局。 并不建议使用 with，其代码可读性差，容易产生混淆错误兼容性问题。 eval 函数eval 是一个特殊的函数，它可以将传入的字符串当做 JavaScript 代码来运行。 123var evalString = `var message = &quot;Hello&quot;;console.log(message);`eval(evalString)console.log(message) 十分不建议在实际开发中使用，其容易被劫持，存在很大的安全隐患！ eval 代码的可读性非常的差（代码的可读性是高质量代码的重要原则） eval 是一个字符串，那么有可能在执行的过程中被刻意篡改，那么可能会造成被攻击的风险； eval 的执行必须经过 JS 解释器，不能被 JS 引擎优化 非严格模式静默非严格模式1234567mes = &#x27;123&#x27;function foo() &#123; console.log(mes)&#125;foo() //123//在非严格模式下 此处能打印mes的值 我们并没有用 var 来声明变量，而是直接赋值。这是一种错误的语法，但是在非严格模式下，js 保持静默。 严格模式123456789//开启严格模式&#x27;use strict&#x27;mes = &#x27;123&#x27;function foo() &#123; console.log(mes)&#125;foo() 在严格模式下，js 会严格查找语法中的错误，此处的 mes 会报错，为： mes is not defined 严格模式严格模式概述 在 ECMAScript5 标准中，JavaScript 提出了严格模式的概念（Strict Mode） 严格模式很好理解，是一种具有限制性的 JavaScript 模式，从而使代码隐式的脱离了 ”懒散（sloppy）模式“ 支持严格模式的浏览器在检测到代码中有严格模式时，会以更加严格的方式对代码进行检测和执行 严格模式对正常的 JavaScript 语义进行了一些限制： 严格模式通过 抛出错误 来消除一些原有的 静默（silent）错误 严格模式让 JS 引擎在执行代码时可以进行更多的优化（不需要对一些特殊的语法进行处理） 严格模式禁用了在 ECMAScript 未来版本中可能会定义的一些语法 ​ Text from why：coderwhy 严格模式的开启方式文件开启123456789// 文件开启的方式// &#x27;use strict&#x27;mes = &#x27;123&#x27;function foo() &#123; console.log(mes)&#125;foo() 函数内开启1234567function use() &#123; // //函数内开启严格模式 // &#x27;use strict&#x27; true.foo = &#x27;abc&#x27;&#125;use() 严格模式的限制 无法意外地创建出全局变量。 所有的静默失效，会以异常的方式抛出。 如果试图删除不可删除的属性，将会报错。 不允许函数中传入两个相同的变量名（非严格模式下，x，y，x。接受的为最后一个 x） 不允许使用 0 的八进制语法 不允许使用 with eval 不能再引用上层变量 this 不会转换为默认对象，（而是变成 undefined） 总结js 中的严格模式，在新手使用中，是一种很好的保护方式。可以在严格的语法纠错中，找的自己的问题出在哪里。不为后续的开发留下安全隐患。","categories":[{"name":"底层逻辑","slug":"底层逻辑","permalink":"http://oliverxuan.github.io/categories/%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://oliverxuan.github.io/tags/JavaScript/"}]},{"title":"React 初体验","slug":"React-初体验","date":"2021-09-15T06:44:16.000Z","updated":"2021-09-15T07:08:18.064Z","comments":true,"path":"2021/09/15/React-初体验/","link":"","permalink":"http://oliverxuan.github.io/2021/09/15/React-%E5%88%9D%E4%BD%93%E9%AA%8C/","excerpt":"ReactReact 基本上是高级前端工程师的必备技能，相较于 Vue 也更加灵活。可以说是 Facebook 工程师们智慧的结晶。 在现阶段，学习 React 可以提高自己对前端的理解，扩大及自己的技术广度。为以后开发中大型项目奠基。 初体验完成点击按钮修改文字的操作 创建一个 html 文件 引入 React 相关 CDN 链接 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot; crossorigin &gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot; crossorigin &gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; React 和 Vue 不一样，React 的理念更像是类纯函数。我们从 CDN 也可以看出分别引入了 React 核心文件，React-dom，Babel 转译。每个都各司其职。而 Vue 则是全部打包在一起直接引入。 成功引入相关依赖后，这样我们就可以开始我们的 React 开发了 实现功能","text":"ReactReact 基本上是高级前端工程师的必备技能，相较于 Vue 也更加灵活。可以说是 Facebook 工程师们智慧的结晶。 在现阶段，学习 React 可以提高自己对前端的理解，扩大及自己的技术广度。为以后开发中大型项目奠基。 初体验完成点击按钮修改文字的操作 创建一个 html 文件 引入 React 相关 CDN 链接 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot; crossorigin &gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot; crossorigin &gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; React 和 Vue 不一样，React 的理念更像是类纯函数。我们从 CDN 也可以看出分别引入了 React 核心文件，React-dom，Babel 转译。每个都各司其职。而 Vue 则是全部打包在一起直接引入。 成功引入相关依赖后，这样我们就可以开始我们的 React 开发了 实现功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 需要渲染的地方，通过id来实现挂载 --&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;!-- 导入相关依赖 --&gt; &lt;script src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot; crossorigin &gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot; crossorigin &gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 开始开发 --&gt; &lt;!-- 注意事项：想在script使用jsx 需要添加标签 type=“text/babel” --&gt; &lt;!-- jsx多个组件在根的层面，只能有一个标签，就如同 Vue：div 来包裹--&gt; &lt;script type=&quot;text/babel&quot;&gt; //封装App组件，该App类继承了React.Component class App extends React.Component &#123; //变量放在constructor()中 constructor() &#123; //由于是继承类，需要调用一下super（） super() //动态数据，统一存放在this.state中 this.state = &#123; mes: &#x27;Hello world&#x27;, &#125; &#125; // render（）渲染 render() &#123; return ( //如同Vue一样，需要用唯一的&lt;div&gt;&lt;/div&gt;来包裹内容 &lt;div&gt; // 调用动态数据注意是this.state.的方式 &lt;h2&gt;&#123;this.state.mes&#125;&lt;/h2&gt; //React是声明式编程，这里绑定方法用的是onClick（）=&#123;&#125; 的方式进行的，切需要.bind来给它指定一个this &lt;button onClick=&#123;this.btnCLick.bind(this)&#125;&gt;改变文字&lt;/button&gt; &lt;/div&gt; ) &#125; // 永远不要手动调用render（） // 相关函数 btnCLick() &#123; console.log(this) console.log(&#x27;按钮发生了点击&#x27;) //通过this.setState的方式来修改state里面的内容 this.setState(&#123; mes: &#x27;Hello React&#x27;, &#125;) &#125; &#125; //渲染组件 渲染内容，挂载对象 ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;app&#x27;)) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 总结React 总体上要比 Vue 难很多，但是也带来了灵活的特性。希望通过自己的坚持，能够掌握 React 的开发技术！","categories":[{"name":"技术实现","slug":"技术实现","permalink":"http://oliverxuan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/"}],"tags":[{"name":"React","slug":"React","permalink":"http://oliverxuan.github.io/tags/React/"}]},{"title":"Js纯函数及函数柯里化","slug":"Js纯函数及函数柯里化","date":"2021-09-14T05:04:05.000Z","updated":"2021-09-14T07:36:29.578Z","comments":true,"path":"2021/09/14/Js纯函数及函数柯里化/","link":"","permalink":"http://oliverxuan.github.io/2021/09/14/Js%E7%BA%AF%E5%87%BD%E6%95%B0%E5%8F%8A%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/","excerpt":"在函数式编程中，有一个非常重要的概念：纯函数。 那究竟什么是纯函数呢？ 纯函数纯函数的定义 维基百科： 此函数在相同的输入值时需产生相同的输出。 函数的输出和输入值以外的其他隐藏信息或状态无关，也和I/O 设备产生的外部输出无关。 该函数不能有语义上可观察的函数副作用，诸如“触发事件”，使输出设备输出，或更改输出值以外物件的内容等。 维基百科的解释很严谨，但是未免有些晦涩。 我的理解： 一个函数，有确定的输入，一定会产生确定的输出。 我们在执行函数的时候，不会对外界产生任何的副作用。 副作用副作用：比如改变了函数外的变量，造成全局变量被篡改。 eg：slice 与 splice 的比较","text":"在函数式编程中，有一个非常重要的概念：纯函数。 那究竟什么是纯函数呢？ 纯函数纯函数的定义 维基百科： 此函数在相同的输入值时需产生相同的输出。 函数的输出和输入值以外的其他隐藏信息或状态无关，也和I/O 设备产生的外部输出无关。 该函数不能有语义上可观察的函数副作用，诸如“触发事件”，使输出设备输出，或更改输出值以外物件的内容等。 维基百科的解释很严谨，但是未免有些晦涩。 我的理解： 一个函数，有确定的输入，一定会产生确定的输出。 我们在执行函数的时候，不会对外界产生任何的副作用。 副作用副作用：比如改变了函数外的变量，造成全局变量被篡改。 eg：slice 与 splice 的比较 12345678910111213141516171819var numbers = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;]// slice函数是一个纯函数：// 1. slice只要给它传入一个start/end, 那么对于同一个数组来说, 它会给我们返回确定的值// 2. slice函数本身它是不会修改原来的数组// slice -&gt; this// slice函数本身就是一个纯函数// var new numbers1 = numbers.slice(0, 3)// console.log(numbers1)// console.log( numbers)// splice函数不是一个纯函数：// splice在执行时, 有修改掉调用的数组对象本身, 修改的这个操作就是产生的副作用var numbers2 = numbers.splice(2)console.log(numbers2)console.log(numbers) 纯函数的理解很简单，只需要关注好重点就可以了。 函数的柯里化函数柯里化用我自己的话简单来说：就是把一件事情进行拆分。 可以把这个过程看成造车： 函数柯里化就是自动化的流水线，流水线的工人各司其职共同造一台车。 普通函数则是一个工人去造一台车。 这样函数柯里化的优点就很明显了：当某个环节的工人出现问题的时候，我们可以快速找到该员工，进行批评教育。 但是如果是普通函数，那么我们则需要从一个人的身上慢慢找问题。整个工作也都停了。 函数演示12345678910111213//原函数function Psum(x, y, z) &#123; return x + y + z&#125;//函数柯里化以后function sum(x) &#123; return function (y) &#123; return function (z) &#123; return x + y + z &#125; &#125;&#125; 这么一看貌似柯里化真的就是自找麻烦一样，但是如果这里不是简单的相加操作呢？ 在真实的开发环境里，可能我们这的一个相加操作就是几十行业务代码。如果把它全部放在一个函数里，维护成本，可阅读性真的就太差了。 单一职责123456789101112131415161718192021222324function add(x, y, z) &#123; x = x + 2 y = y * 2 z = z * z return x + y + z&#125;console.log(add(10, 20, 30))function sum(x) &#123; x = x + 2 return function (y) &#123; y = y * 2 return function (z) &#123; z = z * z return x + y + z &#125; &#125;&#125;console.log(sum(10)(20)(30)) 从这段代码中，我们可以看出 在 sum 函数中，每一个函数都是各司其职，专注干好自己的事情。等所有都处理好了。再统一返回。 逻辑复用假如我们需要设计一个函数，实现传入两个参数，第一个为指定基础数字 X，另一个是与 X 相加的数字。 我们很快可以用传统方法写出： 123456789function sum(m, n) &#123; return m + n&#125;// 假如在程序中,我们经常需要把5和另外一个数字进行相加console.log(sum(5, 10))console.log(sum(5, 14))console.log(sum(5, 1100))console.log(sum(5, 555)) 但是未免有点繁琐 所以我们在此引出，函数柯里化，逻辑复用 123456789101112131415//创建一个makeAdder函数function makeAdder(count) &#123; //在此时如果只传入了一个参数，那么我们目前只确定了 return function中的count 但是 //num的值我们还未确定。 return function (num) &#123; return count + num &#125;&#125;//传入count值，创造makeAdder5的函数var adder5 = makeAdder(5)adder5(10)adder5(14)adder5(1100)adder5(555) 从这里开始，我们就可以慢慢体会函数柯里化的好处了！ 手写柯里化函数首先 我们可以从最外层，最浅显的入手 传入一个函数，返回一个函数 12345function myCurrying(fn) &#123; function curried() &#123;&#125; return curried&#125; 接收参数 123456789function myCurrying(fn) &#123; function curried(...args) &#123; //判断args接收的参数是否已经足够 fn.length是函数fn里接受的参数个数 if (args.length &gt;= fn.length) &#123; &#125; &#125; return curried&#125; 情况一： fn（）直调 12345678910function myCurrying(fn) &#123; function curried(...args) &#123; if (args.length &gt;= fn.length) &#123; //在此处如果直接使用fn（）调用，如果之后是使用call的方式调用新函数，则fn可能并不是之前的fn。而是被call指定了其他的this fn(...args) &#125; &#125; return curried&#125; apply /call 调用 12345678910function myCurrying(fn) &#123; function curried(...args) &#123; if (args.length &gt;= fn.length) &#123; //此处直接显示绑定this，该this为curried对象 return fn.apply(this, args) &#125; &#125; return curried&#125; 没有传入足够参数时，执行 else 123456789101112131415161718function myCurrying(fn) &#123; function curried(...args) &#123; if (args.length &gt;= fn.length) &#123; return fn.apply(this, args) &#125; else &#123; //递归思想 curried2接收剩余参数 function curried2(...args2) &#123; //再次调用curried 传入this=&gt;curried 解构拼接两个参数 return curried.apply(this, [...args, ...args2]) &#125; //返回curried2方法 为下次接收参数做准备 return curried2 &#125; &#125; //返回新函数 return curried&#125; 总结通过这次学习，深刻理解了纯函数，函数的柯里化。也自己尝试着实现了函数的柯里化。希望能在后续的开发学习中能及时运用这些方法。","categories":[{"name":"底层逻辑","slug":"底层逻辑","permalink":"http://oliverxuan.github.io/categories/%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://oliverxuan.github.io/tags/JavaScript/"}]},{"title":"Js中call,apply,bind的实现","slug":"Js中call-apply-bind的实现","date":"2021-09-12T08:42:43.000Z","updated":"2021-09-12T13:59:59.845Z","comments":true,"path":"2021/09/12/Js中call-apply-bind的实现/","link":"","permalink":"http://oliverxuan.github.io/2021/09/12/Js%E4%B8%ADcall-apply-bind%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"在 Js 中，我们常常会用到 call，apply，bind。进行一些 this 操作。我们不禁对其产生了好奇。 Js 中，这些方法是通过 C++实现的，那么我们尝试用 Js 来实现一下。 call 将手写的 mycall 方法，绑定在函数原型上。 实现所有函数都可以通过 foo（）.mycall 的方式调用。 12//Function.prototype :函数原型Function.prototype.mycall = function() 拿到调用 mycall（）的对象。 12//不难发现，此处是一个隐式绑定，函数foo（）.mycall。我们可以通过this拿到目标函数var fn = this 目前，我们完成了最基本的通过 mycall 执行函数体的方法。 12345678910Function.prototype.mycall = function () &#123; var fn = this fn()&#125;function foo() &#123; console.log(&#x27;foo函数被调用&#x27;)&#125;foo.mycall() //foo函数被调用","text":"在 Js 中，我们常常会用到 call，apply，bind。进行一些 this 操作。我们不禁对其产生了好奇。 Js 中，这些方法是通过 C++实现的，那么我们尝试用 Js 来实现一下。 call 将手写的 mycall 方法，绑定在函数原型上。 实现所有函数都可以通过 foo（）.mycall 的方式调用。 12//Function.prototype :函数原型Function.prototype.mycall = function() 拿到调用 mycall（）的对象。 12//不难发现，此处是一个隐式绑定，函数foo（）.mycall。我们可以通过this拿到目标函数var fn = this 目前，我们完成了最基本的通过 mycall 执行函数体的方法。 12345678910Function.prototype.mycall = function () &#123; var fn = this fn()&#125;function foo() &#123; console.log(&#x27;foo函数被调用&#x27;)&#125;foo.mycall() //foo函数被调用 实现函数可传入指定的 this 我们知道在 js 的 call（）中，是可以转入指定的对象，用该对象进行函数的调用。 但是也有一些特殊的情况。 undefined，null。传入该值后，实际上 this 是 window。 传入数字，字符串。实际上是 number/String 对象 我们针对这些特性，进行函数优化。 这里使用到： Object（）：_将传入的值变成对象类型_； 三元运算符：_判断是否为特殊情况_。 1234567891011121314151617181920212223//修改函数体，传入指定的Function.prototype.mycall = function (thisArg) &#123; var fn = this //对传入的thisArg进行判断，是否为null，undefined，如果是：window，不是 Object(thisArg)。 thisArg = thisArg !== null &amp;&amp; thisArg !== undefined ? Object(thisArg) : window //保存原this thisArg.fn = fn //执行原函数体，并保存结果 var result = thisArg.fn() //防止作用域污染，及时删除 delete thisArg.fn //返回执行结果 return result&#125;function foo() &#123; console.log(&#x27;foo函数被调用&#x27;) console.log(this)&#125;foo.mycall(&#x27;abc&#x27;) //String&#123;&#x27;abc&#x27;&#125;foo.mycall() //window 实现函数可传入参数 在这里，我们用到了…args （展开运算符），实现可传入未知个数的参数 1234567891011121314151617181920212223242526272829//...args 用于传入未知个数的参数Function.prototype.mycall = function (thisArg, ...args) &#123; var fn = this thisArg = thisArg !== null &amp;&amp; thisArg !== undefined ? Object(thisArg) : window thisArg.fn = fn //将参数传入执行函数中 var result = thisArg.fn(...args) delete thisArg.fn return result&#125;function foo() &#123; console.log(&#x27;foo函数被调用&#x27;) console.log(this)&#125;function sum(num1, num2) &#123; console.log(&#x27;sum函数被执行&#x27;, this, num1, num2) return num1 + num2&#125;var name = &#x27;window&#x27;// foo.call(&#x27;abc&#x27;)// foo.mycall(&#x27;abc&#x27;)// foo.call()// foo.mycall()console.log(sum.mycall(&#123;&#125;, 1, 2)) //sum函数被执行 &#123;fn: ƒ&#125;[[Prototype]]: Object 1 2 3 目前我们己完成了 mycall（）的手写。 apply 基础部分 此部分和 call 基本一致。 123456789Function.prototype.myapply = function (thisArgs) &#123; var fn = this thisArgs = thisArgs !== null &amp;&amp; thisArs !== undefined ? Object(thisArgs) : window thisArgs.fn = fn var result = thisArgs.fn() delete thisArgs.fn return result&#125; apply 传参处理 12345678910111213141516171819//apple传参是数组类型，所以我们这里只需要传入目标数组就行Function.prototype.myapply = function (thisArgs, array) &#123; var fn = this thisArgs = thisArgs !== null &amp;&amp; thisArgs !== undefined ? Object(thisArgs) : window thisArgs.fn = fn //array = array ? array: [] array = array || [] var result = thisArgs.fn(...array) delete thisArgs.fn return result&#125;function sum(num1, num2) &#123; console.log(&#x27;sum函数被执行&#x27;, this, num1, num2) return num1 + num2&#125;console.log(sum.myapply(&#123;&#125;, [1, 2])) //sum函数被执行 &#123;fn: ƒ&#125; 1 2 3 bind 基础部分 基础部分和前文一致 1234Function.prototype.mybind = function (thisArg) &#123; var fn = this thisArg = thisArg !== null &amp;&amp; thisArg !== undefined ? Object(thisArg) : window&#125; 传参处理 由于 bind 的特殊用法，我们可以在 bind（）里传入参数，也可以在新的函数中传入参数，或者都传入参数，所以我们需要特殊处理。 123456789101112131415161718192021222324252627Function.prototype.mybind = function (thisArg, ...myargs) &#123; var fn = this thisArg = thisArg !== null &amp;&amp; thisArg !== undefined ? Object(thisArg) : window //设立一个代理函数 function pxfn(...arg) &#123; thisArg.fn = fn //合并参数 var finalArray = [...myargs, ...arg] //执行函数体 var result = thisArg.fn(...finalArray) delete thisArg.fn //返回执行结果 return result &#125; //返回pxfn函数 return pxfn&#125;function sum(num1, num2, num3, num4) &#123; console.log(num1, num2, num3, num4)&#125;var bar = foo.mybind(&#x27;123&#x27;)bar() //foo被执行 String &#123;&#x27;123&#x27;, fn: ƒ&#125;var bar2 = sum.mybind(&#x27;1234&#x27;, 1, 2, 3, 4)bar2() //1 2 3 4 总结通过这次手写 Js 中的一些重要方法，我理解到 this 在实际开发的重要性，也学会了，如何处理数据，以及一些边界情况的处理。总的来说，这是一次很好的学习经验。","categories":[{"name":"底层逻辑","slug":"底层逻辑","permalink":"http://oliverxuan.github.io/categories/%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://oliverxuan.github.io/tags/JavaScript/"}]},{"title":"Js中的this练习题","slug":"Js中的this练习题","date":"2021-09-09T07:05:22.000Z","updated":"2021-09-09T08:05:03.446Z","comments":true,"path":"2021/09/09/Js中的this练习题/","link":"","permalink":"http://oliverxuan.github.io/2021/09/09/Js%E4%B8%AD%E7%9A%84this%E7%BB%83%E4%B9%A0%E9%A2%98/","excerpt":"习题：练习题 1:12345678910111213141516var name = &#x27;window&#x27;var person = &#123; name: &#x27;person&#x27;, sayName: function () &#123; console.log(this.name) &#125;,&#125;function sayName() &#123; var sss = person.sayName sss() person.sayName() person.sayName() ;(b = person.sayName)()&#125; 练习题 2:1234567891011121314151617181920212223242526272829303132333435var name = &#x27;window&#x27;var person1 = &#123; name: &#x27;person1&#x27;, foo1: function () &#123; console.log(this.name) &#125;, foo2: () =&gt; console.log(this.name), foo3: function () &#123; return function () &#123; console.log(this.name) &#125; &#125;, foo4: function () &#123; return () =&gt; &#123; console.log(this.name) &#125; &#125;,&#125;var person2 = &#123; name: &#x27;person2&#x27; &#125;person1.foo1()person1.foo1.call(person2)person1.foo2()person1.foo2.call(person2)person1.foo3()()person1.foo3.call(person2)()person1.foo3().call(person2)person1.foo4()()person1.foo4.call(person2)()person1.foo4().call(person2) 练习题 3:123456789101112131415161718192021222324252627282930313233343536var name = &#x27;window&#x27;function Person(name) &#123; this.name = name ;(this.foo1 = function () &#123; console.log(this.name) &#125;), (this.foo2 = () =&gt; console.log(this.name)), (this.foo3 = function () &#123; return function () &#123; console.log(this.name) &#125; &#125;), (this.foo4 = function () &#123; return () =&gt; &#123; console.log(this.name) &#125; &#125;)&#125;var person1 = new Person(&#x27;person1&#x27;)var person2 = new Person(&#x27;person2&#x27;)person1.foo1()person1.foo1.call(person2)person1.foo2()person1.foo2.call(person2)person1.foo3()()person1.foo3.call(person2)()person1.foo3().call(person2)person1.foo4()()person1.foo4.call(person2)()person1.foo4().call(person2) 练习题 4:12345678910111213141516171819202122232425262728293031323334353637var name = &#x27;window&#x27;function Person(name) &#123; this.name = name this.obj = &#123; name: &#x27;obj&#x27;, foo1: function () &#123; return function () &#123; console.log(this.name) &#125; &#125;, foo2: function () &#123; return () =&gt; &#123; console.log(this.name) &#125; &#125;, &#125;&#125;var person1 = new Person(&#x27;person1&#x27;)var person2 = new Person(&#x27;person2&#x27;)person1.obj.foo1()()person1.obj.foo1.call(person2)()person1.obj.foo1().call(person2)person1.obj.foo2()()person1.obj.foo2.call(person2)()person1.obj.foo2().call(person2)//上层作用域的理解var obj = &#123; name: &#x27;obj&#x27;, foo: function () &#123; // 上层作用域是全局 &#125;,&#125; 习题题解：","text":"习题：练习题 1:12345678910111213141516var name = &#x27;window&#x27;var person = &#123; name: &#x27;person&#x27;, sayName: function () &#123; console.log(this.name) &#125;,&#125;function sayName() &#123; var sss = person.sayName sss() person.sayName() person.sayName() ;(b = person.sayName)()&#125; 练习题 2:1234567891011121314151617181920212223242526272829303132333435var name = &#x27;window&#x27;var person1 = &#123; name: &#x27;person1&#x27;, foo1: function () &#123; console.log(this.name) &#125;, foo2: () =&gt; console.log(this.name), foo3: function () &#123; return function () &#123; console.log(this.name) &#125; &#125;, foo4: function () &#123; return () =&gt; &#123; console.log(this.name) &#125; &#125;,&#125;var person2 = &#123; name: &#x27;person2&#x27; &#125;person1.foo1()person1.foo1.call(person2)person1.foo2()person1.foo2.call(person2)person1.foo3()()person1.foo3.call(person2)()person1.foo3().call(person2)person1.foo4()()person1.foo4.call(person2)()person1.foo4().call(person2) 练习题 3:123456789101112131415161718192021222324252627282930313233343536var name = &#x27;window&#x27;function Person(name) &#123; this.name = name ;(this.foo1 = function () &#123; console.log(this.name) &#125;), (this.foo2 = () =&gt; console.log(this.name)), (this.foo3 = function () &#123; return function () &#123; console.log(this.name) &#125; &#125;), (this.foo4 = function () &#123; return () =&gt; &#123; console.log(this.name) &#125; &#125;)&#125;var person1 = new Person(&#x27;person1&#x27;)var person2 = new Person(&#x27;person2&#x27;)person1.foo1()person1.foo1.call(person2)person1.foo2()person1.foo2.call(person2)person1.foo3()()person1.foo3.call(person2)()person1.foo3().call(person2)person1.foo4()()person1.foo4.call(person2)()person1.foo4().call(person2) 练习题 4:12345678910111213141516171819202122232425262728293031323334353637var name = &#x27;window&#x27;function Person(name) &#123; this.name = name this.obj = &#123; name: &#x27;obj&#x27;, foo1: function () &#123; return function () &#123; console.log(this.name) &#125; &#125;, foo2: function () &#123; return () =&gt; &#123; console.log(this.name) &#125; &#125;, &#125;&#125;var person1 = new Person(&#x27;person1&#x27;)var person2 = new Person(&#x27;person2&#x27;)person1.obj.foo1()()person1.obj.foo1.call(person2)()person1.obj.foo1().call(person2)person1.obj.foo2()()person1.obj.foo2.call(person2)()person1.obj.foo2().call(person2)//上层作用域的理解var obj = &#123; name: &#x27;obj&#x27;, foo: function () &#123; // 上层作用域是全局 &#125;,&#125; 习题题解：练习题 1:12345678910111213141516171819var name = &#x27;window&#x27;var person = &#123; name: &#x27;person&#x27;, sayName: function () &#123; console.log(this.name) &#125;,&#125;function sayName() &#123; var sss = person.sayName sss() //window 默认绑定，独立函数调用 person.sayName() //person 隐式绑定，通过person调用sayName（） person.sayName() //person 隐式绑定，通过person调用sayName（）， //实质上（）没有用，本身就是一个整体，只是用来混淆视听。 ;(b = person.sayName)() //window 默认绑定，独立函数调用，b接收了sayName（）后被独立调用&#125; 练习题 2:123456789101112131415161718192021222324252627282930313233343536373839404142434445var name = &#x27;window&#x27;var person1 = &#123; name: &#x27;person1&#x27;, foo1: function () &#123; console.log(this.name) &#125;, foo2: () =&gt; console.log(this.name), foo3: function () &#123; return function () &#123; console.log(this.name) &#125; &#125;, foo4: function () &#123; return () =&gt; &#123; console.log(this.name) &#125; &#125;,&#125;var person2 = &#123; name: &#x27;person2&#x27; &#125;person1.foo1() //person1 隐式绑定，通过person1来调用函数person1.foo1.call(person2) //person2 显式绑定，首先拿到了foo1的函数体，再通过call方法调用， //其中指定绑定了this为person2person1.foo2() //window 默认绑定，由于foo2是箭头函数，箭头函数不接受this对象，向上层寻找，上层是对象。//由于对象没有this指定，则它的this就指向了全局person1.foo2.call(person2) //window 默认绑定，拿到foo2后通过call（）调用，但是箭头函数不接受this对象，故为windowperson1.foo3()() //window 独立函数调用，通过person1拿到foo3函数体后，函数再执行。相当于是函数的独立调用person1.foo3.call(person2)() //person2 首先拿到了foo3函数，通过call我们拿到了return 的函数 再执行，相当于独立调用。person1.foo3().call(person2) //person2 显式绑定，通过foo3（）拿到了return函数，再通过call绑定了this运行。person1.foo4()() //person1 隐式绑定，首先foo4（）拿到了箭头函数，（）再执行，箭头函数中没有this指定//向上查找，由于上层为foo4（）foo4是由person1 调用执行的，故为隐式绑定person1.foo4.call(person2)() //person2 首先拿到了foo4 对其进行call绑定，foo4的作用域中this指向了person2//然后箭头函数向上查找，foo4的this以及变成了person2person1.foo4().call(person2) //person1 首先拿到了箭头函数，由于箭头函数不传值，直接调用，向上查找foo4的作用域//中this的指向，为person1 练习题 3:123456789101112131415161718192021222324252627282930313233343536var name = &#x27;window&#x27;function Person(name) &#123; this.name = name ;(this.foo1 = function () &#123; console.log(this.name) &#125;), (this.foo2 = () =&gt; console.log(this.name)), (this.foo3 = function () &#123; return function () &#123; console.log(this.name) &#125; &#125;), (this.foo4 = function () &#123; return () =&gt; &#123; console.log(this.name) &#125; &#125;)&#125;var person1 = new Person(&#x27;person1&#x27;)var person2 = new Person(&#x27;person2&#x27;)person1.foo1() //perosn1person1.foo1.call(person2) //perosn2 显式绑定person1.foo2() //person1 上级作用域中this指向的是person1person1.foo2.call(person2) //person1 call并不会改变箭头函数的this指向，上级作用域中this指向的是person1person1.foo3()() //window 独立函数调用person1.foo3.call(person2)() //window 独立函数调用person1.foo3().call(person2) //person2 显示绑定person1.foo4()() //perosn1 隐式绑定，拿到了箭头函数，再（），箭头函数向上查找，上级作用域this为perosn1person1.foo4.call(person2)() //perosn2 首先改变了foo4的this为perosn2，当箭头函数找的时候上级作用域已改变person1.foo4().call(person2) //perosn1 call无法改变箭头函数的this绑定值，箭头函数向上查找，为perosn1 练习题 4:123456789101112131415161718192021222324252627282930313233343536373839var name = &#x27;window&#x27;function Person(name) &#123; this.name = name this.obj = &#123; name: &#x27;obj&#x27;, foo1: function () &#123; return function () &#123; console.log(this.name) &#125; &#125;, foo2: function () &#123; return () =&gt; &#123; console.log(this.name) &#125; &#125;, &#125;&#125;var person1 = new Person(&#x27;person1&#x27;)var person2 = new Person(&#x27;person2&#x27;)person1.obj.foo1()() //window 独立函数调用person1.obj.foo1.call(person2)() //window 独立函数调用person1.obj.foo1().call(person2) //perosn2 显示绑定了person2person1.obj.foo2()() //obj，首先，我们foo2（），拿到了箭头函数，箭头函数向上查找，foo2是通过obj进行调用的//所以foo2的作用域中this为objperson1.obj.foo2.call(person2)() //perosn2 foo2的this通过call改变了，所以，箭头函数向上查找this时时person2person1.obj.foo2().call(person2) //obj call无法改变箭头函数的this//上层作用域的理解var obj = &#123; name: &#x27;obj&#x27;, foo: function () &#123; // 上层作用域是全局 &#125;,&#125; 总结首先感谢 coderwhy 老师提供的练习题与讲解，本文中的题解为个人理解，仅供参考。 关于箭头函数，不要忘记向上查找的规则 关于最后的（）要分析好是否为函数的独立调用 箭头函数向上查找的时候需要判断上层作用域到底是哪一个","categories":[{"name":"练习题","slug":"练习题","permalink":"http://oliverxuan.github.io/categories/%E7%BB%83%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://oliverxuan.github.io/tags/JavaScript/"}]},{"title":"Js中的This指向","slug":"Js中的This指向","date":"2021-09-08T03:02:23.000Z","updated":"2021-09-09T07:04:09.709Z","comments":true,"path":"2021/09/08/Js中的This指向/","link":"","permalink":"http://oliverxuan.github.io/2021/09/08/Js%E4%B8%AD%E7%9A%84This%E6%8C%87%E5%90%91/","excerpt":"Js 中什么是 This？为什么需要 this?在 Java 中 this 常用在关于类的操作中，我们常常可以用 this.的方式调用类的属性，方法。 相对于 Java。 Js 中的 this 用法可比 Java 中更灵活。 正也是因为灵活，让 Js 中的 this 常常让人摸不清头脑。 在 Js 中我们可以通过 this 方法，在不同的情况下，拿到不同的对象。有可能是全局对象(window)，也有可能是一个 Obj 对象,或者我们可以直接给我们的 this 指定绑定上一个对象。 this 指向什么呢？ 在全局的情况下，this 指向 window 1234console.log(this) //windowvar name = &#x27;Oliver&#x27;console.log(this.name) //oliverconsole.log(window.name) //oliver 但是，开发中很少直接在全局作用域下去使用 this，通常都是在函数中使用。 所有的函数在被调用时，都会创建一个执行上下文： 这个上下文中记录着函数的调用栈、AO 对象等； this 也是其中的一条记录； 我们先来看一个让人困惑的问题： 定义一个函数，我们采用三种不同的方式对它进行调用，它产生了三种不同的结果","text":"Js 中什么是 This？为什么需要 this?在 Java 中 this 常用在关于类的操作中，我们常常可以用 this.的方式调用类的属性，方法。 相对于 Java。 Js 中的 this 用法可比 Java 中更灵活。 正也是因为灵活，让 Js 中的 this 常常让人摸不清头脑。 在 Js 中我们可以通过 this 方法，在不同的情况下，拿到不同的对象。有可能是全局对象(window)，也有可能是一个 Obj 对象,或者我们可以直接给我们的 this 指定绑定上一个对象。 this 指向什么呢？ 在全局的情况下，this 指向 window 1234console.log(this) //windowvar name = &#x27;Oliver&#x27;console.log(this.name) //oliverconsole.log(window.name) //oliver 但是，开发中很少直接在全局作用域下去使用 this，通常都是在函数中使用。 所有的函数在被调用时，都会创建一个执行上下文： 这个上下文中记录着函数的调用栈、AO 对象等； this 也是其中的一条记录； 我们先来看一个让人困惑的问题： 定义一个函数，我们采用三种不同的方式对它进行调用，它产生了三种不同的结果 12345678910111213function foo() &#123; console.log(this)&#125;foo() //window 默认绑定var obj = &#123; name: &#x27;obj&#x27;, foo: foo,&#125;obj.foo() //obj对象 隐式绑定foo.apply(&#x27;abc&#x27;) //abc 显式绑定 这个的案例可以给我们什么样的启示呢？ 函数在调用时，JavaScript 会默认给 this 绑定一个值； this 的绑定和定义的位置（编写的位置）没有关系； this 的绑定和调用方式以及调用的位置有关系； this 是在运行时被绑定的； 重要结论： this 的指向，和它所处的位置无关和调用位置有关！ this 在被调用运行的时候，才会给他 this 绑定一个值！ this 绑定规则：绑定一：默认绑定绑定二：隐式绑定绑定三：显示绑定绑定四：new 绑定规则一：默认绑定什么情况下使用默认绑定呢？独立的函数调用 我们可以理解成函数没有被绑定到某个对象上进行调用 下面是一些默认绑定演示： 12345678910111213141516171819202122232425262728293031323334353637383940//1. windowfunction foo() &#123; console.log(this)&#125;foo()//2. windowfunction foo1() &#123; console.log(this)&#125;function foo2() &#123; console.log(this) foo1()&#125;function foo3() &#123; console.log(this) foo2()&#125;foo3()//3. windowvar obj = &#123; name: &#x27;obj&#x27;, foo: function () &#123; console.log(this) &#125;,&#125;var bar = obj.foo //将该对象中的方法传递给了bar 那么其实bar就是一个单独调用bar()//5. windowfunction foo() &#123; function bar() &#123; console.log(this) &#125; return bar&#125;var fn = foo() //实质上就是在调用bar 然后将bar传递给了fnfn() 默认绑定，独立函数调用 规则二：隐式绑定另外一种比较常见的调用方式是通过某个对象进行调用的： 也就是它的调用位置中，是通过某个对象发起的函数调用。 123456789101112function foo() &#123; console.log(this)&#125;var obj = &#123; name: &#x27;obj&#x27;, age: 19, fn: foo,&#125;//使用对象调用的方式来执行函数。obj.fn() //在对象里，将foo函数传递给了fn 实质上就是通过obj在调用 隐式绑定有前提条件： 必须在调用的对象内部有一个对函数的引用（比如一个属性）； 如果没有这样的引用，在进行调用时，会报找不到该函数的错误； 正是通过这个引用，间接的将this 绑定到了这个对象上； 规则三：显示绑定如果我们不希望在 对象内部 包含这个函数的引用，同时又希望在这个对象上进行强制调用，该怎么做呢？ JavaScript 所有的函数都可以使用call 和 apply 方法（这个和 Prototype 有关）。 其实非常简单，第一个参数是相同的，后面的参数，apply 为数组，call 为参数列表； 这两个函数的第一个参数都要求是一个对象，这个对象的作用是什么呢？就是给 this 准备的。 在调用这个函数时，会将 this 绑定到这个传入的对象上。 因为上面的过程，我们明确的绑定了 this 指向的对象，所以称之为 显示绑定。 通过 call 或者 apply 绑定 this 对象 call（ ）绑定，其第一参数为指定的 this 绑定对象，第二，三，N，参数为将要传入的参数 1234567function foo(num1, num2, num3) &#123; console.log(this) console.log(num1, num2, num3)&#125;foo.call(&#x27;call&#x27;, 1, 2, 3) //[String: &#x27;call&#x27;] 1 2 3foo.call(&#123; name: &#x27;yzx&#x27; &#125;) //&#123; name: &#x27;yzx&#x27; &#125; apply（ ）绑定，其第一参数为指定 this 绑定对象，第二参数为一个数组，其中包含了将要传入的参数 1234567function foo(num1, num2, num3) &#123; console.log(this) console.log(num1, num2, num3)&#125;foo.apply(&#x27;apply&#x27;, [1, 2, 3]) //[String: &#x27;apply&#x27;] 1 2 3foo.apply(&#123; name: &#x27;yzx&#x27;, age: 18 &#125;) //&#123; name: &#x27;yzx&#x27;, age: 18 &#125; 通过 bind 方法实现显示绑定 我们可以通过.bind 方法实现显示绑定 12345678910111213function foo() &#123; name: &#x27;foo&#x27;, console.log(this)&#125;var obj = &#123; name: &#x27;obj&#x27;, fn: foo,&#125;foo() //windowobj.fn() //objvar fn = obj.fn.bind(&#123; name: &#x27;Bind&#x27; &#125;)fn() //Bind 规则四：new 绑定JavaScript 中的函数可以当做一个类的构造函数来使用，也就是使用 new 关键字。 使用 new 关键字来调用函数是，会执行如下的操作： 创建一个全新的对象； 这个新对象会被执行 prototype 连接； 这个新对象会绑定到函数调用的 this 上（this 的绑定在这个步骤完成）； 如果函数没有返回其他对象，表达式会返回这个新对象； 1234567function Person(name) &#123; console.log(this) //Person&#123;&#125; this.name = name //Person&#123;name:Oliverxuan&#125;&#125;var p = new Person(&#x27;Oliverxuan&#x27;)console.log(p) 内置函数 this 绑定setTimeout（）1234//1. setTimeoutsetTimeout(function () &#123; console.log(this) //window&#125;, 2000) 监听点击1234const boxDiv = document.querySelector(&#x27;box&#x27;)boxDiv.onclick = function () &#123; console.log(this) //boxDiv&#123;&#125;&#125; 数组：filter/map/forEach 等高阶函数12345678910var names = [&#x27;abc&#x27;, &#x27;cba&#x27;]names.forEach(function (item) &#123; console.log(item, this) //abc&#123;&#125;&#125;, &#x27;abc&#x27;) //此处进行了this绑定var names = [&#x27;abc&#x27;, &#x27;cba&#x27;]names.forEach(function (item) &#123; console.log(item, this) // window&#125;) //此处没有进行this的绑定 规则优先级基本规则学习了四条规则，接下来开发中我们只需要去查找函数的调用应用了哪条规则即可，但是如果一个函数调用位置应用了多条规则，优先级谁更高呢？ 1. 默认规则的优先级最低 毫无疑问，默认规则的优先级是最低的，因为存在其他规则时，就会通过其他规则的方式来绑定 this 2. 显示绑定优先级高于默认绑定 代码测试： 12345678var obj = &#123; name: &#x27;obj&#x27;, foo: function () &#123; console.log(this) &#125;,&#125;obj.foo() // name:&#123; name: &#x27;obj&#x27;, foo: [Function: foo] &#125; 3 .显示绑定优先级高于隐式绑定 代码测试： 12345678910111213var obj = &#123; name: &#x27;obj&#x27;, foo: function () &#123; console.log(this) &#125;,&#125;obj.foo.call(&#x27;abc&#x27;) //[String: &#x27;abc&#x27;]obj.foo.apply(&#x27;abc&#x27;) //[String: &#x27;abc&#x27;]function foo() &#123; console.log(this)&#125; 4. bind 的优先级，高于隐式绑定 代码测试： 123456var obj = &#123; name: &#x27;obj&#x27;, foo: foo.bind(&#x27;aaa&#x27;),&#125;obj.foo() //[String: &#x27;aaa&#x27;] 6. new 绑定优先级高于显示绑定 new 绑定和call、apply 是不允许同时使用的，所以不存在谁的优先级更高 new 绑定可以和 bind 一起使用，new 绑定优先级更高 代码测试： 12345678var obj = &#123; name: &#x27;obj&#x27;, foo: function () &#123; console.log(this) &#125;,&#125;var f = new obj.foo() //foo&#123;&#125; 7. 小小总结 bind 优先级比较高 new &gt; 显示 &gt; 隐式 &gt; 默认绑定（独立函数调用） 规则之外常规情况 忽略显示绑定 12345678910111213function foo() &#123; console.log(this)&#125;foo.apply(&#x27;abc&#x27;)foo.apply(&#123;&#125;)foo.apply(null) //window 全局对象foo.apply(undefined) //window 全局对象foo.bind(null) //window 全局对象foo.bind(undefined) //window 全局对象var bar = foo.bind(null)bar() 间接函数引用 1234567891011121314151617181920212223242526272829var obj = &#123; name: &#x27;obj&#x27;, foo: function () &#123; console.log(this) &#125;,&#125;var obj2 = &#123; name: &#x27;obj2&#x27;,&#125;obj2.bar = obj.fooobj2.bar() //&#123; name: &#x27;obj2&#x27;, bar: [Function: foo] &#125;var obj = &#123; name: &#x27;obj&#x27;, foo: function () &#123; console.log(this) &#125;,&#125;var obj2 = &#123; name: &#x27;obj2&#x27;,&#125;obj2.bar = obj.fooobj2.bar()( //&#123; name: &#x27;obj2&#x27;, bar: [Function: foo] &#125; (obj2.bar = obj.foo))() // 没有 分号（；）无法运行 与上面的代码看成整体;(obj2.bar = obj.foo)() // 有 分号（；）window 独立调用 箭头函数特性： 箭头函数中 是不会绑定 this/arguments 属性 箭头函数不能作为函数构造器使用 四大规则 对箭头函数不适用 简写： 如果参数只有一个 小括号可以省略 123nums.forEach((item) =&gt; &#123; console.log(item)&#125;) 如果函数的函数执行体只有一行代码，大括号也可以省略 1234nums.forEach((item) =&gt; console.log(item))// 并且会默认地将代码的执行结果作为返回值var num = nums.filter((item) =&gt; item % 2 == 0)console.log(num) 如果一个箭头函数它的返回值，只有一行代码，且只返回一个对象 如果想简写 返回对象 需要在外层套一个（）以示整体 1var bar = () =&gt; (&#123; name: &#x27;oliver&#x27;, age: 12 &#125;) 总结JS 中的 this 十分灵活，需要结合各种情况进行分析。但是万变不离其宗。掌握特性，方可以一眼看穿真相！ JS 的优点是灵活，缺点也是灵活。想要真正掌握 JS 中的晦涩语法。还需要继续修炼内功 感谢 coderwhy 老师的课程以及公众号，能够让我细节地，全面地学习 JS","categories":[{"name":"底层逻辑","slug":"底层逻辑","permalink":"http://oliverxuan.github.io/categories/%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://oliverxuan.github.io/tags/JavaScript/"}]},{"title":"Js常用数组高阶函数","slug":"Js中的高阶函数","date":"2021-09-06T04:54:54.000Z","updated":"2021-09-15T06:46:56.758Z","comments":true,"path":"2021/09/06/Js中的高阶函数/","link":"","permalink":"http://oliverxuan.github.io/2021/09/06/Js%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/","excerpt":"js 中有很多高阶函数，能在日常的代码编写工作中提高效率。下面列举一些常用 js 的数组高阶函数 FOO 数组1var nums = [10, 5, 11, 100, 55] filter: 过滤返回布尔类型 可以传递三个值 item 当前的的元素，index 当前数组下标， arr 当前整个数组 12345//数组取偶操作var numbers = nums.filter((item, index, arr) =&gt; &#123; return item % 2 == 0&#125;)console.log(numbers) map: 映射对所有的 item 进行操作 12345//对每个item进行*10操作var nums2 = nums.map((item) =&gt; &#123; return item * 10&#125;)console.log(nums2) forEach: 迭代","text":"js 中有很多高阶函数，能在日常的代码编写工作中提高效率。下面列举一些常用 js 的数组高阶函数 FOO 数组1var nums = [10, 5, 11, 100, 55] filter: 过滤返回布尔类型 可以传递三个值 item 当前的的元素，index 当前数组下标， arr 当前整个数组 12345//数组取偶操作var numbers = nums.filter((item, index, arr) =&gt; &#123; return item % 2 == 0&#125;)console.log(numbers) map: 映射对所有的 item 进行操作 12345//对每个item进行*10操作var nums2 = nums.map((item) =&gt; &#123; return item * 10&#125;)console.log(nums2) forEach: 迭代无返回值 1234//遍历数组，无返回值！nums.forEach((item) =&gt; &#123; console.log(item)&#125;) find/findIndex :查找查找 item/返还该 item/itemIndex 1234var item = nums.find((item) =&gt; &#123; return item == 11&#125;)console.log(item) reduce :累加preValue 前数据; 0:基础数据 12345//数组累加操作var total = nums.reduce((preValue, item) =&gt; &#123; return preValue + item&#125;, 0)console.log(total) 总结js 中很多高阶函数，我们还需继续探索。慢慢感受 js 的魅力！","categories":[{"name":"技术实现","slug":"技术实现","permalink":"http://oliverxuan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://oliverxuan.github.io/tags/JavaScript/"}]},{"title":"浅谈js闭包","slug":"浅谈js闭包","date":"2021-09-05T11:53:27.000Z","updated":"2021-09-05T13:43:02.040Z","comments":true,"path":"2021/09/05/浅谈js闭包/","link":"","permalink":"http://oliverxuan.github.io/2021/09/05/%E6%B5%85%E8%B0%88js%E9%97%AD%E5%8C%85/","excerpt":"最近在学习 Javascript 高级语法，研究到了一些底层逻辑，有了很多的心得体会。赶紧记录下来！ 什么是 Js 闭包？ js 中函数是一等公民什么是一等公民？就好比 java 中的对象。js 中的函数十分灵活！ 函数可以作为另一个函数的参数，也可以作为另一个函数的返回值来使用 自己可以编写高阶函数 可以使用内置的高阶函数 代码演示： 函数作为一等公民，可以作为参数传入其他的函数中 1234567function calc(num1, num2, fnc) &#123; console.log(fnc(num1, num2))&#125;function add(num1, num2) &#123; return num1 + num2&#125;calc(20, 30, add)","text":"最近在学习 Javascript 高级语法，研究到了一些底层逻辑，有了很多的心得体会。赶紧记录下来！ 什么是 Js 闭包？ js 中函数是一等公民什么是一等公民？就好比 java 中的对象。js 中的函数十分灵活！ 函数可以作为另一个函数的参数，也可以作为另一个函数的返回值来使用 自己可以编写高阶函数 可以使用内置的高阶函数 代码演示： 函数作为一等公民，可以作为参数传入其他的函数中 1234567function calc(num1, num2, fnc) &#123; console.log(fnc(num1, num2))&#125;function add(num1, num2) &#123; return num1 + num2&#125;calc(20, 30, add) js 允许函数的嵌套定义 12345678910111213141516171819function foo() &#123; function bar() &#123; console.log(&#x27;bar&#x27;) &#125; return bar&#125;var fn = foo()fn() function makeAdder(count) function add(num) &#123; return count + num &#125; return add &#125; var add5 = makeAdder(5) var add10 = makeAdder(10) console.log(add5(10)) console.log(add10(10)) 高阶函数:把一个函数，接受另一个函数的返回值，作为参数使用，称为高阶函数。 js 中的闭包定义官方式定义：在计算机科学中对闭包的定义（维基百科）： 闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures）； 是在支持 头等函数 的编程语言中，实现词法绑定的一种技术； 闭包在实现上是一个结构体，它存储了一个函数和一个关联的环境（相当于一个符号查找表）； 闭包跟函数最大的区别在于，当捕捉闭包的时候，它的 自由变量 会在捕捉时被确定，这样即使脱离了捕捉时的上下文，它也能照常运行； MDN 对 JavaScript 闭包的解释： 一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）； 也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域； 在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来； 我对 Js 闭包的理解： 广义上来讲，js 中的函数都是闭包 狭义上来讲，js 中的一个函数，如果访问了外层作用域的变量，那它就是一个闭包。 闭包：函数+可以访问的自由变量 简单的闭包，以及逻辑： 简单描述逻辑：GO 对象，执行上下文调用栈 EcStack-&gt;全局执行上下文，VO：GO-&gt;解析函数，创建函数对象,上层作用域,函数执行体-&gt;函数执行上下文-&gt;执行代码-&gt;执行上下文销毁，AO 也销毁 闭包中的问题闭包中的某些 AO 为什么不会被销毁？这就涉及到 Js 的内存回收机制：垃圾回收器会定期从这个根开始，找所有从根开始有引用到的对象，对于哪些没有引用到的对象，就认为是不可用的对象； 我们可以参考： 12345678910111213function foo() &#123; var name = &#x27;foo&#x27; var age = 18 function bar() &#123; console.log(name) console.log(age) &#125; return bar&#125;var fn = foo()fn() 我们对 function bar 进行研究。 创建 GO 对象，包含了 fn：undefined ，foo：undefined 运行 foo（） 创建 foo 函数对象，其中包含了他作用域链，函数执行体；创建 foo AO 对象，name：undefined …，并对 bar（）进行预加载 执行 foo 函数，对 foo AO 进行修改。 创建 bar 函数对象，bar AO 其中 bar 的函数对象中 父级作用域是 foo，指向 foo AO 。 返回 bar（） fn 存储 bar 的地址 运行 fn（） bar 开始寻找相关的 name，age，bar AO 无，则向 foo AO 中寻找。 找到相关数据，执行函数。 由于我们可以很清楚地找到一条线：GO 的 fn（）-&gt; bar-&gt;bar AO 父级作用域指向 foo 的 AO 所以此时的 foo AO 不会被销毁，因为我们可以从根目录开始寻找这一条线路。 闭包内存泄漏由于某些 AO 一直存在，就有着内存泄漏的问题存在。 解决方法就直接将其指向 null 如： 12345678910111213141516function foo() &#123; var name = &#x27;foo&#x27; var age = 18 function bar() &#123; console.log(name) console.log(age) &#125; return bar&#125;var fn = foo()fn()fn = nullfoo = null 就可以解决这个问题 总结JavaScript 博大精深，还需继续努力，深入研究其中的原理。冲冲冲！","categories":[{"name":"底层逻辑","slug":"底层逻辑","permalink":"http://oliverxuan.github.io/categories/%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://oliverxuan.github.io/tags/JavaScript/"}]},{"title":"vue表单提交时自动刷新","slug":"vue表单提交时自动刷新","date":"2021-08-31T05:41:29.000Z","updated":"2021-08-31T07:47:23.348Z","comments":true,"path":"2021/08/31/vue表单提交时自动刷新/","link":"","permalink":"http://oliverxuan.github.io/2021/08/31/vue%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4%E6%97%B6%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0/","excerpt":"问题描述在之前 mmjd 的项目中，我设计了一个登陆的界面。发现当第一次提交的时候，会默认刷新一次。导致用户提交的表单是空的。从而报错。 这直接导致了很不好的用户体验。 解决方案vue 中使用表单 form 默认提交行为是刷新一下，在这儿我们使用事件修饰符 prevent 来阻止 form 表单的默认行为 1&lt;input type=&quot;submit&quot; value=&quot;提交&quot; @click.prevent=&#x27;had&#x27;&gt; 总结这个点似曾相识，在以前学习的时候老师好像提到过。自己没注意到细节上的东西。反向说明了自己对 vue 的一些细节，和项目经验不足。需要继续提高！","text":"问题描述在之前 mmjd 的项目中，我设计了一个登陆的界面。发现当第一次提交的时候，会默认刷新一次。导致用户提交的表单是空的。从而报错。 这直接导致了很不好的用户体验。 解决方案vue 中使用表单 form 默认提交行为是刷新一下，在这儿我们使用事件修饰符 prevent 来阻止 form 表单的默认行为 1&lt;input type=&quot;submit&quot; value=&quot;提交&quot; @click.prevent=&#x27;had&#x27;&gt; 总结这个点似曾相识，在以前学习的时候老师好像提到过。自己没注意到细节上的东西。反向说明了自己对 vue 的一些细节，和项目经验不足。需要继续提高！","categories":[{"name":"Obstacle","slug":"Obstacle","permalink":"http://oliverxuan.github.io/categories/Obstacle/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://oliverxuan.github.io/tags/vue/"}]},{"title":"通过node如何创建一个接口","slug":"通过node如何创建一个接口","date":"2021-08-31T05:18:58.000Z","updated":"2021-09-15T06:46:24.097Z","comments":true,"path":"2021/08/31/通过node如何创建一个接口/","link":"","permalink":"http://oliverxuan.github.io/2021/08/31/%E9%80%9A%E8%BF%87node%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3/","excerpt":"主要功能通过 node.js 环境与 Koa 框架，编写一个接口 实现方法 app 文件夹 1234567891011121314151617&lt;!-- index.js --&gt;//导入Koa框架const Koa = require(&#x27;koa&#x27;)const bodyParser = require(&#x27;koa-bodyparser&#x27;)const errorHandler = require(&#x27;./error-handle&#x27;)const useRoutes = require(&#x27;../router&#x27;)//新建Koa实例const app = new Koa()app.use(bodyParser())useRoutes(app)app.on(&#x27;error&#x27;, errorHandler)module.exports = app main.js 文件 main.js 文件一般是程序的主要入口 12345678910111213//导入之前创建的app实例const app = require(&#x27;./app&#x27;)//导入数据库相关配置require(&#x27;./app/database&#x27;)//导入相关配置const config = require(&#x27;./app/config&#x27;)//创建启动服务器app.listen(config.APP_PORT, () =&gt; &#123; console.log(`服务器在$&#123;config.APP_PORT&#125;端口已启动`)&#125;) router 文件夹index.js 文件 主要用来配置 router（路由）相关信息 12345678910111213141516//导入fs插件const fs = require(&#x27;fs&#x27;)//创建useRoutesconst useRoutes = (app) =&gt; &#123; //自动生成router相关配置 fs.readdirSync(__dirname).forEach((file) =&gt; &#123; if (file === &#x27;index.js&#x27;) return const router = require(`./$&#123;file&#125;`) app.use(router.routes()) app.use(router.allowedMethods()) &#125;)&#125;module.exports = useRoutes","text":"主要功能通过 node.js 环境与 Koa 框架，编写一个接口 实现方法 app 文件夹 1234567891011121314151617&lt;!-- index.js --&gt;//导入Koa框架const Koa = require(&#x27;koa&#x27;)const bodyParser = require(&#x27;koa-bodyparser&#x27;)const errorHandler = require(&#x27;./error-handle&#x27;)const useRoutes = require(&#x27;../router&#x27;)//新建Koa实例const app = new Koa()app.use(bodyParser())useRoutes(app)app.on(&#x27;error&#x27;, errorHandler)module.exports = app main.js 文件 main.js 文件一般是程序的主要入口 12345678910111213//导入之前创建的app实例const app = require(&#x27;./app&#x27;)//导入数据库相关配置require(&#x27;./app/database&#x27;)//导入相关配置const config = require(&#x27;./app/config&#x27;)//创建启动服务器app.listen(config.APP_PORT, () =&gt; &#123; console.log(`服务器在$&#123;config.APP_PORT&#125;端口已启动`)&#125;) router 文件夹index.js 文件 主要用来配置 router（路由）相关信息 12345678910111213141516//导入fs插件const fs = require(&#x27;fs&#x27;)//创建useRoutesconst useRoutes = (app) =&gt; &#123; //自动生成router相关配置 fs.readdirSync(__dirname).forEach((file) =&gt; &#123; if (file === &#x27;index.js&#x27;) return const router = require(`./$&#123;file&#125;`) app.use(router.routes()) app.use(router.allowedMethods()) &#125;)&#125;module.exports = useRoutes img.router.js 具体的路由文件 12345678910111213141516//导入koa路由const Router = require(&#x27;koa-router&#x27;)//制定接口的路径const imgRouter = new Router(&#123; prefix: &#x27;/mmjd&#x27; &#125;)//导入相关方法/中间件const &#123; getImgs,personType,personImgs &#125; = require(&#x27;../controller/img.controller&#x27;)const &#123; verifyAuth &#125; = require(&#x27;../middleware/auth.middleware&#x27;)//注册接口，并标明请求方法imgRouter.get(&#x27;/&#x27;, getImgs)imgRouter.post(&#x27;/personimg&#x27;,verifyAuth,personType,personImgs)module.exports = imgRouter 其次就是在 middleware 或者 controller，service 中写具体操作了 总结其中还是有很多细节的东西没有掌握好，此点需要以后继续深入研究！","categories":[{"name":"技术实现","slug":"技术实现","permalink":"http://oliverxuan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://oliverxuan.github.io/tags/node-js/"}]},{"title":"axios拦截","slug":"axios拦截","date":"2021-08-30T09:17:04.000Z","updated":"2021-09-15T06:46:39.502Z","comments":true,"path":"2021/08/30/axios拦截/","link":"","permalink":"http://oliverxuan.github.io/2021/08/30/axios%E6%8B%A6%E6%88%AA/","excerpt":"主要功能实现在 axios 每次请求/响应时，对请求/响应进行相关的处理。我们把这种处理方式称之为拦截。 实现方法 request.js 文件的封装 首先我们要将 axios 主要的请求封装在 request.js 文件中，这样我们可以降低代码的耦合度，提高整体的效率，方便后期的维护。12345678910111213141516//将axios插件导入import axios from &quot;axios&quot;;//创建axios方法，并将该方法导出export function request(config) &#123; // 1.创建axios的实例 const instance = axios.create(&#123; baseURL: &quot;*******&quot;, timeout: 5000 &#125;); // 2.设立请求/响应拦截 // 3.发送真正的网络请求 return instance(config);&#125; axios 拦截器 请求拦截 可以在任何的请求上进行修饰，改变。此处我以添加 Authorization：Token 的方法为例： 12345678910111213141516//使用axios的请求拦截方法instance.interceptors.request.use( //对参数进行处理 config =&gt; &#123; //具体操作 if (localStorage.getItem(&quot;Authorization&quot;)) &#123; config.headers.Authorization = localStorage.getItem(&quot;Authorization&quot;); &#125; //最后注意需要返回修饰后的参数 return config; &#125;, error =&gt; &#123; //如果请求是错误的，我们将异常抛出 return Promise.reject(error); &#125; );","text":"主要功能实现在 axios 每次请求/响应时，对请求/响应进行相关的处理。我们把这种处理方式称之为拦截。 实现方法 request.js 文件的封装 首先我们要将 axios 主要的请求封装在 request.js 文件中，这样我们可以降低代码的耦合度，提高整体的效率，方便后期的维护。12345678910111213141516//将axios插件导入import axios from &quot;axios&quot;;//创建axios方法，并将该方法导出export function request(config) &#123; // 1.创建axios的实例 const instance = axios.create(&#123; baseURL: &quot;*******&quot;, timeout: 5000 &#125;); // 2.设立请求/响应拦截 // 3.发送真正的网络请求 return instance(config);&#125; axios 拦截器 请求拦截 可以在任何的请求上进行修饰，改变。此处我以添加 Authorization：Token 的方法为例： 12345678910111213141516//使用axios的请求拦截方法instance.interceptors.request.use( //对参数进行处理 config =&gt; &#123; //具体操作 if (localStorage.getItem(&quot;Authorization&quot;)) &#123; config.headers.Authorization = localStorage.getItem(&quot;Authorization&quot;); &#125; //最后注意需要返回修饰后的参数 return config; &#125;, error =&gt; &#123; //如果请求是错误的，我们将异常抛出 return Promise.reject(error); &#125; ); 响应拦截 1234567891011121314151617181920//axios响应拦截方法instance.interceptors.response.use( res =&gt; &#123; //获取响应参数，并返回 return res.data; &#125;, err =&gt; &#123; //如果返还错误，提取相关的Status响应码，进行错误提示 const &#123; response &#125; = err; if ((response.status = 401)) &#123; localStorage.removeItem(&quot;Authorization&quot;); localStorage.removeItem(&quot;userName&quot;); localStorage.removeItem(&quot;userId&quot;); alert(&quot;请登陆后再使用哦～&quot;); &#125; else &#123; console.log(err); &#125; &#125; ); 后续调用 如需对接后端接口，仅需要创建相关 js 文件，并写入具体请求方法。 user.js 1234567891011121314151617181920212223242526//导入我们之前封装好的request文件import &#123; request &#125; from &quot;./request&quot;;//写具体的对接接口的方法export function GetUser() &#123; return request(&#123; url: &quot;/users/name&quot;, method: &quot;POST&quot; &#125;);&#125;//传参类：//将需要的参数写在方法内export function ChangeUserSkin(flag, type, fix) &#123; return request(&#123; url: &quot;/users/skintest&quot;, method: &quot;POST&quot;, //将所需的数据创建好。 data: &#123; flag: flag, type: type, fix: fix &#125; &#125;);&#125; 总结axios 在日常的 vue 开发中是使用频率很高的组件，用来进行前后端数据交互工作。整体上并不难。需要我们熟练掌握相关的方法，逻辑。其中也需要注意代码的规范，体现封装性。","categories":[{"name":"技术实现","slug":"技术实现","permalink":"http://oliverxuan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/"}],"tags":[{"name":"axios","slug":"axios","permalink":"http://oliverxuan.github.io/tags/axios/"}]},{"title":"mmjd项目的完成情况","slug":"mmjd项目的完成情况","date":"2021-08-24T17:24:58.000Z","updated":"2021-08-24T17:43:34.300Z","comments":true,"path":"2021/08/25/mmjd项目的完成情况/","link":"","permalink":"http://oliverxuan.github.io/2021/08/25/mmjd%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%AE%8C%E6%88%90%E6%83%85%E5%86%B5/","excerpt":"项目进度:最近一直在做那个护肤品测评网站，可谓是从无到有，功能也都在慢慢实现。目前已经完成了 90% 剩余的就是 Debug 和样式 接口功能：不多说了，直接上图！ 后端接口： 真的是完完整地做完了整个项目的后端接口。从中真的学会了很多！慢慢也熟悉了 Node.js + Koa 开发接口的开发逻辑。 Mysql： 从中也重新回忆起了很多的 sql 语句（真的好久不用生疏了！）比如：left join ，json_object…. 前端界面：现在的前端界面真的奇丑无比，等着这两天我调好了我们再看！","text":"项目进度:最近一直在做那个护肤品测评网站，可谓是从无到有，功能也都在慢慢实现。目前已经完成了 90% 剩余的就是 Debug 和样式 接口功能：不多说了，直接上图！ 后端接口： 真的是完完整地做完了整个项目的后端接口。从中真的学会了很多！慢慢也熟悉了 Node.js + Koa 开发接口的开发逻辑。 Mysql： 从中也重新回忆起了很多的 sql 语句（真的好久不用生疏了！）比如：left join ，json_object…. 前端界面：现在的前端界面真的奇丑无比，等着这两天我调好了我们再看！ 技术栈： 前端：Html JavaScript CSS Vue Vuex VueRouter axios Webpack node.js Bootstrap 后端：node.js Koa mysql 数据库: mysql 收获：通过这次完完整整地独自开发前后端的项目，很多东西真的就是要亲自来才能深刻体会！希望自己以后能参与或创造更多的项目！ 开源地址: 前端：https://github.com/Oliverxuan/mmjd 后端：https://github.com/Oliverxuan/MMJD-node","categories":[{"name":"CodeLife","slug":"CodeLife","permalink":"http://oliverxuan.github.io/categories/CodeLife/"}],"tags":[{"name":"项目","slug":"项目","permalink":"http://oliverxuan.github.io/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"创建用户并验证合法性","slug":"创建用户并验证合法性","date":"2021-08-15T16:10:04.000Z","updated":"2021-09-15T06:46:28.417Z","comments":true,"path":"2021/08/16/创建用户并验证合法性/","link":"","permalink":"http://oliverxuan.github.io/2021/08/16/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E5%B9%B6%E9%AA%8C%E8%AF%81%E5%90%88%E6%B3%95%E6%80%A7/","excerpt":"主要功能实现一个接口，可以读取用户的输入信息，并检查其合法性。如果其合法，将其录入数据库中，如果不合法，返回其不合法的类型。 实现方法1.创建数据库：1234567CREATE TABLE IF NOT EXISTS `users`(id INT PRIMARY KEY AUTO_INCREMENT,name VARCHAR(30) NOT NULL UNIQUE,password VARCHAR(50) NOT NULL,createAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,updateAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP); 2.连接数据库1.配置数据库信息 将数据库的配置写入 .env 文件中 1234567# mysql配置MYSQL_HOST=xxxxxxMYSQL_PORT=xxxxMYSQL_DATABASE=xxxxxMYSQL_ROOT=xxxxxMYSQL_PASSWORD=xxxxxx 将数据库信息在 config.js 文件中导入","text":"主要功能实现一个接口，可以读取用户的输入信息，并检查其合法性。如果其合法，将其录入数据库中，如果不合法，返回其不合法的类型。 实现方法1.创建数据库：1234567CREATE TABLE IF NOT EXISTS `users`(id INT PRIMARY KEY AUTO_INCREMENT,name VARCHAR(30) NOT NULL UNIQUE,password VARCHAR(50) NOT NULL,createAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,updateAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP); 2.连接数据库1.配置数据库信息 将数据库的配置写入 .env 文件中 1234567# mysql配置MYSQL_HOST=xxxxxxMYSQL_PORT=xxxxMYSQL_DATABASE=xxxxxMYSQL_ROOT=xxxxxMYSQL_PASSWORD=xxxxxx 将数据库信息在 config.js 文件中导入 12345678module.exports = &#123; APP_PORT, MYSQL_HOST, MYSQL_PORT, MYSQL_DATABASE, MYSQL_ROOT, MYSQL_PASSWORD,&#125; = process.env 2.建立数据库连接 在全局文件夹（app）里新建关于数据库操作的 database.js 文件 导入 mysql 插件 1const mysql = require(&#x27;mysql2&#x27;) 将配置信息导入 1const config = require(&#x27;./config&#x27;) 创建数据库连接池,并将相关配置导入 12345678const connections = mysql.createPool(&#123; host: config.MYSQL_HOST, port: config.MYSQL_PORT, database: config.MYSQL_DATABASE, user: config.MYSQL_ROOT, password: config.MYSQL_PASSWORD,&#125;) 取得数据库连接，并设置数据库启动提示 123456789connections.getConnection((err, conn) =&gt; &#123; conn.connect((err) =&gt; &#123; if (err) &#123; console.log(&#x27;数据库连接失败!&#x27;) &#125; else &#123; console.log(&#x27;数据库连接成功！&#x27;) &#125; &#125;)&#125;) 将 connections 导出，从而达到封装。 12//操作都是建立在connections.promise（）上的，所以在导出的时候连带promise()module.exports = connections.promise() 在 main.js 中引入 database.js，从而达到加载目的 12require(&#x27;./app/database&#x27;) 测试连接,得到回应： 3.实现数据库的存入 实现 create 方法 12//查询数据 const result = await service.create(user) 在 service 的 user.service.js 中写入数据库操作 12345678910//操作都是异步的所以要加上async awaitasync create(user) &#123; //从user中获取user，password const &#123; name, password &#125; = user //sql语句 const statement = &#x27;INSERT INTO users (name,password) VALUES (?,?);&#x27; //执行sql语句，并将查询结果返还至result中 const result = await connection.execute(statement, [name, password]) return result[0] &#125; 执行结果 优化过程：验证输入的合法性 创建验证中间件 verifyUser ,并写入 UserRouter 中 1userRouter.post(&#x27;/&#x27;, verifyUser, create) 由于此类型的中间件在后续开发中会频繁创建，故统一在 middleware.js 中创建 12345678910111213141516171819202122232425262728293031323334353637383940// 导入错误类型const errorType = require(&#x27;../constants/error-types&#x27;)// 导入service 利用其中的getUserByName来验证是否已存在该用户const service = require(&#x27;../service/user.service&#x27;)//创建中间件，注意其也是异步操作！const verifyUser = async (ctx, next) =&gt; &#123; //获取用户名，密码 const &#123; name, password &#125; = ctx.request.body //判断不能为空 if (!name || !password) &#123; //如果为空，则新建Error，其错误类型为：NAME_OR_PASSWORD_IS_REQUIRED const error = new Error(errorType.NAME_OR_PASSWORD_IS_REQUIRED) //将错误发射出去 return ctx.app.emit(&#x27;error&#x27;, error, ctx) &#125; //判断本次注册的用户名是否被注册 const result = await service.getUserByNanme(name) //如果返还不为NULL if (result.length) &#123; //新建error 错误类型为：USER_ALREADY_EXISTS const error = new Error(errorType.USER_ALREADY_EXISTS) //将错误发射出去 return ctx.app.emit(&#x27;error&#x27;, error, ctx) &#125; //如果以上都未执行，则进行下一个中间件：create await next()&#125;//导出verifyUsermodule.exports = &#123; verifyUser,&#125; errorType 的创建由于以后的错误类型会有很多，所以统一写入在 errorType 中 1234567const NAME_OR_PASSWORD_IS_REQUIRED = &#x27;name_or_password_is_required&#x27;const USER_ALREADY_EXISTS = &#x27;user_already_exists&#x27;module.exports = &#123; NAME_OR_PASSWORD_IS_REQUIRED, USER_ALREADY_EXISTS,&#125; service 中的 getUserByName 方法 1234567async getUserByNanme(name) &#123; const statement = `SELECT * FROM users WHERE name = ?;` const result = await connection.execute(statement, [name]) return result[0]&#125; 在 index.js 中接收报错信息 12app.on(&#x27;error&#x27;, errorHandler) 创建错误处理 error-handle.js在其中统一处理错误信息 12345678910111213141516171819202122232425262728293031//导入错误类型const errorTypes = require(&#x27;../constants/error-types&#x27;)// 导入之前发射出来的参数error，ctx，并进行分析处理const errorHandler = (error, ctx) =&gt; &#123; //建立状态变量，和报错提示 let status, message //通过传入的错误类型来判断处理方式 switch (error.message) &#123; case errorTypes.NAME_OR_PASSWORD_IS_REQUIRED: status = 400 //Bad request message = &#x27;用户名或者密码为空&#x27; break case errorTypes.USER_ALREADY_EXISTS: console.log(&#x27;1&#x27;) status = 409 //Conflict message = &#x27;用户名已存在&#x27; break default: status = 404 message = &#x27;NOT FOUND&#x27; &#125; //将错误信息导入ctx中 ctx.status = status ctx.body = message&#125;module.exports = errorHandler 错误展示用户已存在：状态码： 用户输入名或密码为空:状态码： 总结经过今天的汇总，逐渐将其中的思路理清楚，为以后开发接口提供了思路。","categories":[{"name":"技术实现","slug":"技术实现","permalink":"http://oliverxuan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://oliverxuan.github.io/tags/node-js/"}]},{"title":"node.js 用户登陆初体验","slug":"node-js-用户登陆初体验","date":"2021-08-13T16:59:57.000Z","updated":"2021-09-15T06:47:09.500Z","comments":true,"path":"2021/08/14/node-js-用户登陆初体验/","link":"","permalink":"http://oliverxuan.github.io/2021/08/14/node-js-%E7%94%A8%E6%88%B7%E7%99%BB%E9%99%86%E5%88%9D%E4%BD%93%E9%AA%8C/","excerpt":"实现目标写一个接口，实现从用户输入中获得数据 技术点文件夹功能分类 app (app 操作文件夹) index.js (导入所使用的插件，中间件) 12345678910111213141516// 导入所需的插件，中间件const Koa = require(&#x27;koa&#x27;)const bodyParser = require(&#x27;koa-bodyparser&#x27;)const userRouter = require(&#x27;../router/user.router&#x27;)//实例化Koa对象const app = new Koa()//注册/使用插件，中间件app.use(bodyParser())app.use(userRouter.routes())app.use(userRouter.allowedMethods())//导出app 以便其他模块使用module.exports = app config.js (配置操作) 12345678//导入插件const dotenv = require(&#x27;dotenv&#x27;)//使用插件的方法，导入写好的配置文件（.env）dotenv.config()module.exports = &#123; APP_PORT &#125; = process.env main.js (程序的总入口)","text":"实现目标写一个接口，实现从用户输入中获得数据 技术点文件夹功能分类 app (app 操作文件夹) index.js (导入所使用的插件，中间件) 12345678910111213141516// 导入所需的插件，中间件const Koa = require(&#x27;koa&#x27;)const bodyParser = require(&#x27;koa-bodyparser&#x27;)const userRouter = require(&#x27;../router/user.router&#x27;)//实例化Koa对象const app = new Koa()//注册/使用插件，中间件app.use(bodyParser())app.use(userRouter.routes())app.use(userRouter.allowedMethods())//导出app 以便其他模块使用module.exports = app config.js (配置操作) 12345678//导入插件const dotenv = require(&#x27;dotenv&#x27;)//使用插件的方法，导入写好的配置文件（.env）dotenv.config()module.exports = &#123; APP_PORT &#125; = process.env main.js (程序的总入口) 123456789// 导入之前的Koa实例化的对象app。 导入配置文件const app = require(&#x27;./app&#x27;)const config = require(&#x27;./app/config&#x27;)//创建服务器，并利用config的APP_PORT参数app.listen(config.APP_PORT, () =&gt; &#123; console.log(`服务器在$&#123;config.APP_PORT&#125;端口已启动`)&#125;) router (所有的路由管理文件夹) user.router.js (user 的路由管理) 12345678910111213141516// 路由相关的js 注册接口适用//导入koa-router组件const Router = require(&#x27;koa-router&#x27;)//导入方法const &#123; create &#125; = require(&#x27;../controller/user.controller&#x27;)//注册路由 其路径为/usersconst userRouter = new Router(&#123; prefix: &#x27;/users&#x27; &#125;)//设置路由的响应方式，响应方法userRouter.post(&#x27;/&#x27;, create)//导出路由module.exports = userRouter controller (管理不同路径下的不同的情况下的方法，操作) user.controller.js (user 的一些方法，操作) 12345678910111213141516171819//导入写好的方法const service = require(&#x27;../service/user.service&#x27;)//创建类 其中包含了不同情况下的不同方法class UserController &#123; async create(ctx, next) &#123; //获取用户请求的参数 const user = ctx.request.body //查询数据 const result = await service.create(user) //返回数据 ctx.body = result &#125;&#125;module.exports = new UserController() service (业务层，其一般对接着 mysql 数据库操作) user.service.js 1234567891011//创建类class UserService &#123; async create(user) &#123; console.log(&#x27;将用户数据保存到数据库中&#x27;, user) //将user存储到数据库中 return &#x27;创建用户成功&#x27; &#125;&#125;module.exports = new UserService() utils (工具类) .env (配置文件) 123# 服务器端口号APP_PORT=8000 实现结果 总结本次实现了一个小功能，主要目的是想让自己理清楚这个文件与文件之间的关系，以及不同的文件之间的分工。","categories":[{"name":"技术实现","slug":"技术实现","permalink":"http://oliverxuan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://oliverxuan.github.io/tags/node-js/"}]},{"title":"Better-scroll 中无法滚动问题","slug":"Better-scroll-中无法滚动问题","date":"2021-08-11T06:25:44.000Z","updated":"2021-08-31T05:42:20.684Z","comments":true,"path":"2021/08/11/Better-scroll-中无法滚动问题/","link":"","permalink":"http://oliverxuan.github.io/2021/08/11/Better-scroll-%E4%B8%AD%E6%97%A0%E6%B3%95%E6%BB%9A%E5%8A%A8%E9%97%AE%E9%A2%98/","excerpt":"问题描述在昨天我在使用 Vue 开发前端页面的时候，我遇到了在使用 better-scroll 实现页面滚动的时候无法滚动经过排查，问题出在与 better-scroll 的滚动原理与实际高度之间产生矛盾（图片异步加载问题） 问题分析在之前的 GoodsList 组件中，有一个加载接口图片的操作 12345678910&lt;template&gt; &lt;div class=&quot;goods-item&quot;&gt; &lt;img :src=&quot;goodsItem.img&quot; alt=&quot;&quot; /&gt; &lt;div class=&quot;goods-info&quot;&gt; &lt;p&gt;&#123;&#123; goodsItem.name &#125;&#125;&lt;/p&gt; &lt;span class=&quot;price&quot;&gt;RMB:&#123;&#123; goodsItem.price &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 由于 better-scroll 在计算 wrapper content 高度的时候是在一开始就会计算好 从而达到滚动的目的 但是 Goods list 会加载网路图片，存在一个异步问题加载完后，实际的高度会远超于之前 better-scroll 计算的高度 从而导致 better-scroll 之间计算无效了，最终无法滚动 解决方法123456789&lt;template&gt; &lt;div class=&quot;goods-item&quot;&gt; &lt;img :src=&quot;goodsItem.img&quot; alt=&quot;&quot; @load=&quot;imageload&quot; /&gt; &lt;div class=&quot;goods-info&quot;&gt; &lt;p&gt;&#123;&#123; goodsItem.name &#125;&#125;&lt;/p&gt; &lt;span class=&quot;price&quot;&gt;RMB:&#123;&#123; goodsItem.price &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;","text":"问题描述在昨天我在使用 Vue 开发前端页面的时候，我遇到了在使用 better-scroll 实现页面滚动的时候无法滚动经过排查，问题出在与 better-scroll 的滚动原理与实际高度之间产生矛盾（图片异步加载问题） 问题分析在之前的 GoodsList 组件中，有一个加载接口图片的操作 12345678910&lt;template&gt; &lt;div class=&quot;goods-item&quot;&gt; &lt;img :src=&quot;goodsItem.img&quot; alt=&quot;&quot; /&gt; &lt;div class=&quot;goods-info&quot;&gt; &lt;p&gt;&#123;&#123; goodsItem.name &#125;&#125;&lt;/p&gt; &lt;span class=&quot;price&quot;&gt;RMB:&#123;&#123; goodsItem.price &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 由于 better-scroll 在计算 wrapper content 高度的时候是在一开始就会计算好 从而达到滚动的目的 但是 Goods list 会加载网路图片，存在一个异步问题加载完后，实际的高度会远超于之前 better-scroll 计算的高度 从而导致 better-scroll 之间计算无效了，最终无法滚动 解决方法123456789&lt;template&gt; &lt;div class=&quot;goods-item&quot;&gt; &lt;img :src=&quot;goodsItem.img&quot; alt=&quot;&quot; @load=&quot;imageload&quot; /&gt; &lt;div class=&quot;goods-info&quot;&gt; &lt;p&gt;&#123;&#123; goodsItem.name &#125;&#125;&lt;/p&gt; &lt;span class=&quot;price&quot;&gt;RMB:&#123;&#123; goodsItem.price &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 在原代码 “&lt; img &gt;”标签处新增 @load=”imageload“ 监听事件 12345methods: &#123; imageload() &#123; this.$bus.$emit(&quot;itemImageLoad&quot;); &#125; &#125; 随后在方法里将此事件发射到事件总线里面 注意，需要在 main.js 里注册 事件总线 12345678910111213import Vue from &quot;vue&quot;;import App from &quot;./App.vue&quot;;import router from &quot;./router&quot;;import store from &quot;./store&quot;;Vue.config.productionTip = false;Vue.prototype.$bus = new Vue();new Vue(&#123; router, store, render: h =&gt; h(App)&#125;).$mount(&quot;#app&quot;); 将事件传入事件总线后 需要在 better-scroll 滚动页面里面监听事件 12345mounted() &#123; this.$bus.$on(&quot;itemImageLoad&quot;, () =&gt; &#123; this.$refs.scroll.scroll.refresh(); &#125;); &#125;, 提前设置 better-scroll 中的 refs 从而方便操作 最后监听到图片加载后 调用 scroll 的 refresh（）函数达到重新计算高度的目的 性能优化由于之前的频繁发出事件 image load 导致 实际上会 refresh 很多次 此处就需要 dbounce 防抖函数来处理 ： 12345678910function debounce(fn,delay)&#123; var handle; return function()&#123; clearTimeout(handle) handle=setTimeout(function()&#123; fn() &#125;,delay) &#125; &#125; 从而达到性能优化的目的","categories":[{"name":"Obstacle","slug":"Obstacle","permalink":"http://oliverxuan.github.io/categories/Obstacle/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://oliverxuan.github.io/tags/vue/"}]},{"title":"Hello,好久不见","slug":"Hello-好久不见","date":"2021-08-11T06:04:48.000Z","updated":"2021-08-11T06:25:13.431Z","comments":true,"path":"2021/08/11/Hello-好久不见/","link":"","permalink":"http://oliverxuan.github.io/2021/08/11/Hello-%E5%A5%BD%E4%B9%85%E4%B8%8D%E8%A7%81/","excerpt":"最近都去干什么了？距离上次更新我的博客已经过去了 10 多天了，在这段时间里我开始新的征程 =&gt; 准备 9 月份的 辽宁省大学生移动开发大赛 我计划着开发一个护肤品测评网站，整个网站的架构为：前端：Vue 全家桶，axios 后端：Node.js，express 数据库：Mysql 期间遇到的问题困难由于我之前没有涉及过后端的接口开发，所以我在这 10 天的时间里自学了一点 Node.js 的开发基础。顺便学习了 Express，Koa 框架的基本开发。 到目前为止，我已成功地将写好的使用 Express 的 Js 程序用 Node.js 部署在我的云服务器上。 在这其中我遇到了很多的困难，例如： 在服务器上部署合适的 Node &amp; Mysql 如何在本地通过 ssh 连接远端服务器","text":"最近都去干什么了？距离上次更新我的博客已经过去了 10 多天了，在这段时间里我开始新的征程 =&gt; 准备 9 月份的 辽宁省大学生移动开发大赛 我计划着开发一个护肤品测评网站，整个网站的架构为：前端：Vue 全家桶，axios 后端：Node.js，express 数据库：Mysql 期间遇到的问题困难由于我之前没有涉及过后端的接口开发，所以我在这 10 天的时间里自学了一点 Node.js 的开发基础。顺便学习了 Express，Koa 框架的基本开发。 到目前为止，我已成功地将写好的使用 Express 的 Js 程序用 Node.js 部署在我的云服务器上。 在这其中我遇到了很多的困难，例如： 在服务器上部署合适的 Node &amp; Mysql 如何在本地通过 ssh 连接远端服务器 ssh root@ip 如何在 vs code navicat-mysql ssh 连接远端数据 vs code 通过远程资源管理器 mysql 里设置可远端读写权限 navicat 在建立连接时正确写入服务器中的数据库信息 注意需要在服务器安全组里开放相应的端口 建立数据库，在 Vue 里通过 axios 连接远端数据库 处理接口数据 如何在服务器上一直运行 Node 项目 npm2 管理插件 在此感谢前辈们在遇到困难时留下的宝贵经验，以至于我在后续开发时遇到问题都能及时解决","categories":[{"name":"CodeLife","slug":"CodeLife","permalink":"http://oliverxuan.github.io/categories/CodeLife/"}],"tags":[{"name":"规划","slug":"规划","permalink":"http://oliverxuan.github.io/tags/%E8%A7%84%E5%88%92/"}]},{"title":"岛屿问题的实现","slug":"岛屿问题的实现","date":"2021-07-31T06:42:14.000Z","updated":"2021-09-14T07:41:54.388Z","comments":true,"path":"2021/07/31/岛屿问题的实现/","link":"","permalink":"http://oliverxuan.github.io/2021/07/31/%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"问题描述给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/number-of-islands著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解决方案此问题与上一期的门墙算法的实现的思想基本一致，属于利用队列，以及广度优先搜索（dfs）的方式解决问题。但是并不是完全的相同。本问题需要注意在于广度优先搜索的时候，需要有“感染”的思想。 首先遍历整个二维数组，寻找数组中的岛 再在孤岛的基础上 遍历他的上下左右临格元素 是否也为“1”岛屿 如果是 将它感染。 1234567891011121314151617181920212223242526272829public class Solution &#123; public int numIslands(char[][] grid) &#123; if(grid.length==0)&#123; return 0; &#125; int count=0; for (int i = 0; i &lt; grid.length; i++) &#123; for (int j = 0; j &lt; grid[0].length; j++) &#123; if(grid[i][j]==&#x27;1&#x27;)&#123; count++; dfs(grid,i,j); &#125; &#125; &#125; return count; &#125; private void dfs(char[][] grid, int i, int j) &#123; if(i&lt;0 || i&gt;= grid.length || j&lt;0 || j&gt;=grid[0].length || grid[i][j]==&#x27;0&#x27;)&#123; return; &#125; grid[i][j]=&#x27;0&#x27;; dfs(grid, i - 1, j); dfs(grid, i + 1, j); dfs(grid, i, j + 1); dfs(grid, i, j - 1); &#125;&#125;","text":"问题描述给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/number-of-islands著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解决方案此问题与上一期的门墙算法的实现的思想基本一致，属于利用队列，以及广度优先搜索（dfs）的方式解决问题。但是并不是完全的相同。本问题需要注意在于广度优先搜索的时候，需要有“感染”的思想。 首先遍历整个二维数组，寻找数组中的岛 再在孤岛的基础上 遍历他的上下左右临格元素 是否也为“1”岛屿 如果是 将它感染。 1234567891011121314151617181920212223242526272829public class Solution &#123; public int numIslands(char[][] grid) &#123; if(grid.length==0)&#123; return 0; &#125; int count=0; for (int i = 0; i &lt; grid.length; i++) &#123; for (int j = 0; j &lt; grid[0].length; j++) &#123; if(grid[i][j]==&#x27;1&#x27;)&#123; count++; dfs(grid,i,j); &#125; &#125; &#125; return count; &#125; private void dfs(char[][] grid, int i, int j) &#123; if(i&lt;0 || i&gt;= grid.length || j&lt;0 || j&gt;=grid[0].length || grid[i][j]==&#x27;0&#x27;)&#123; return; &#125; grid[i][j]=&#x27;0&#x27;; dfs(grid, i - 1, j); dfs(grid, i + 1, j); dfs(grid, i, j + 1); dfs(grid, i, j - 1); &#125;&#125;","categories":[{"name":"Problems","slug":"Problems","permalink":"http://oliverxuan.github.io/categories/Problems/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://oliverxuan.github.io/tags/leetcode/"}]},{"title":"门与墙算法的实现","slug":"门与墙算法的实现","date":"2021-07-29T14:50:18.000Z","updated":"2021-07-30T15:16:58.408Z","comments":true,"path":"2021/07/29/门与墙算法的实现/","link":"","permalink":"http://oliverxuan.github.io/2021/07/29/%E9%97%A8%E4%B8%8E%E5%A2%99%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"问题描述：你被给定一个 m × n 的二维网格 rooms ，网格中有以下三种可能的初始化值：-1 表示墙或是障碍物 0 表示一扇门INF 无限表示一个空的房间。然后，我们用 231 - 1 = 2147483647 代表 INF。你可以认为通往门的距离总是小于 2147483647 的。你要给每个空房间位上填上该房间到 最近门的距离 ，如果无法到达门，则填 INF 即可。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/walls-and-gates著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 建立基本数据以及辅助坐标 先寻找门坐标，将其入队 取出队头元素 A 进行解析 分析 A 上下左右 block 是否可用 合法 A 是否未赋值 将合法的 block 进行赋值（步数） 将新的 block 入队 结束条件当取出的区域 上下左右都已经赋值 ｜｜ 为墙，为门 则无需处理，退出处理队列 本题的突破点: 理解队列先进先出的性质 广度优先搜索的性质 先找门，后赋值的思路 ps：block 我的定义是 INF 即可用的房间","text":"问题描述：你被给定一个 m × n 的二维网格 rooms ，网格中有以下三种可能的初始化值：-1 表示墙或是障碍物 0 表示一扇门INF 无限表示一个空的房间。然后，我们用 231 - 1 = 2147483647 代表 INF。你可以认为通往门的距离总是小于 2147483647 的。你要给每个空房间位上填上该房间到 最近门的距离 ，如果无法到达门，则填 INF 即可。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/walls-and-gates著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 建立基本数据以及辅助坐标 先寻找门坐标，将其入队 取出队头元素 A 进行解析 分析 A 上下左右 block 是否可用 合法 A 是否未赋值 将合法的 block 进行赋值（步数） 将新的 block 入队 结束条件当取出的区域 上下左右都已经赋值 ｜｜ 为墙，为门 则无需处理，退出处理队列 本题的突破点: 理解队列先进先出的性质 广度优先搜索的性质 先找门，后赋值的思路 ps：block 我的定义是 INF 即可用的房间 实现难点 如何寻找 block 的上下左右房间 该房间的周围空间是否有用 能否联想到新的 block 就当作是一个新门，再从新门找他的上下左右 block 如何进行数据处理 细节处理 象形理解把每一个门当作一个大的问题小孩（类似孩子王），队列就是记录未解决问题小孩的清单。我们把每一个 INF 区域当作一个医生，安排医生用最小的距离去解决这些问题小孩。我们先在房间里寻找大问题小孩，将他们全部记录在清单上。我们开始分析他周围是否也有问题小孩（孩子王的小跟班）（上下左右检查）如果有（该区域为空）且该问题其他医生没有解决（未赋值）我们就指派该区域的医生去解决这个问题小孩，并且记录该问题小孩离孩子王有多远。（为 block 赋值）如果周围的问题小孩已经有医生解决了，我们就不管。将新的问题小孩记录在队列上，原先的孩子王的下线已经全盘供出，所以他从问题清单上划除。继续解决清单上的新的问题小孩….（可能有点不怎么容易理解。。。。我真的尽力了 源码 yyds ） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Solution &#123; //定义空房间的特征值 private static final int INF = 2147483647; //定义门的特殊值 private static final int DOOR = 0; //定义辅助坐标 以此来表示房间的上下左右 private static final List&lt;int[]&gt; DIRECTIONS = Arrays.asList( new int[]&#123;1, 0&#125;, new int[]&#123;-1, 0&#125;, new int[]&#123;0, -1&#125;, new int[]&#123;0, 1&#125; ); public void wallsAndGates(int[][] rooms) &#123; //记录房间的长宽 int m= rooms.length; int n=rooms[0].length; if(m==0)&#123; return; &#125; //创建队列 Queue&lt;int []&gt; queue=new LinkedList&lt;&gt;(); //遍历rooms 寻找所有的门 for (int row = 0; row &lt; m; row++) &#123; for (int col = 0; col &lt; n; col++) &#123; //当检测到该地区为门的时候 将门的坐标元素入队 if(rooms[row][col]==DOOR)&#123; queue.add(new int[]&#123;row,col&#125;); &#125; &#125; &#125; //核心区域 （当队列不为空的时候，继续执行） while(!queue.isEmpty())&#123; //取出队头的元素 也是最先入队的元素 （ d,c,b,a =&gt; a) int[] block = queue.poll(); //记录原生的行，列数据 int row=block[0]; int col=block[1]; //制造当前block的上下左右block 利用辅助坐标快速制作出新的坐标数据 for (int [] direction: DIRECTIONS) &#123; int r=row+direction[0]; int c=col+direction[1]; //判断新的坐标是否合法 是否存在障碍物 ！！（重点！）是否之前已经被被赋值过！！ //如果已经被赋值 说明当前值就是该区域的最短路径，再次改变就是不准确值 // 因为是广度优先 所以当前值一定是最优值 if(r&lt;0 || c&lt;0 || r&gt;=rooms.length || c&gt;=rooms[0].length || rooms[r][c]!=INF)&#123; continue; &#125; //细节点 需要在前一个block的值上进行+1 否则步数全为1 rooms[r][c]=rooms[row][col]+1; //如果都不是 则为全新的为赋值block 将其加入队列（列尾） queue.add(new int[]&#123;r,c&#125;); &#125; &#125; &#125;&#125;","categories":[{"name":"Problems","slug":"Problems","permalink":"http://oliverxuan.github.io/categories/Problems/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://oliverxuan.github.io/tags/leetcode/"}]},{"title":"循环队列的实现","slug":"循环队列的实现","date":"2021-07-27T17:21:50.000Z","updated":"2021-07-30T15:17:02.169Z","comments":true,"path":"2021/07/28/循环队列的实现/","link":"","permalink":"http://oliverxuan.github.io/2021/07/28/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"问题描述：设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。 循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。 你的实现应该支持如下操作： MyCircularQueue(k): 构造器，设置队列长度为 k 。Front: 从队首获取元素。如果队列为空，返回 -1 。Rear: 获取队尾元素。如果队列为空，返回 -1 。enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。isEmpty(): 检查循环队列是否为空。isFull(): 检查循环队列是否已满。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/design-circular-queue 示例：MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3circularQueue.enQueue(1); // 返回 truecircularQueue.enQueue(2); // 返回 truecircularQueue.enQueue(3); // 返回 truecircularQueue.enQueue(4); // 返回 false，队列已满circularQueue.Rear(); // 返回 3circularQueue.isFull(); // 返回 truecircularQueue.deQueue(); // 返回 truecircularQueue.enQueue(4); // 返回 truecircularQueue.Rear(); // 返回 4 解题思路： 首先要明白循环队列的原理 如何设计循环队列中的两个指针 细节处理","text":"问题描述：设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。 循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。 你的实现应该支持如下操作： MyCircularQueue(k): 构造器，设置队列长度为 k 。Front: 从队首获取元素。如果队列为空，返回 -1 。Rear: 获取队尾元素。如果队列为空，返回 -1 。enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。isEmpty(): 检查循环队列是否为空。isFull(): 检查循环队列是否已满。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/design-circular-queue 示例：MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3circularQueue.enQueue(1); // 返回 truecircularQueue.enQueue(2); // 返回 truecircularQueue.enQueue(3); // 返回 truecircularQueue.enQueue(4); // 返回 false，队列已满circularQueue.Rear(); // 返回 3circularQueue.isFull(); // 返回 truecircularQueue.deQueue(); // 返回 truecircularQueue.enQueue(4); // 返回 truecircularQueue.Rear(); // 返回 4 解题思路： 首先要明白循环队列的原理 如何设计循环队列中的两个指针 细节处理 循环队列原理https://www.bilibili.com/video/BV1yx411e7nb?from=search&amp;seid=13632348157331521482/ 实现难点： 为什么要在 eg：head（head+1）% size 取模？ 为什么 get tail 的时候不能直接返回？ 细节处理 实现代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class MyCircularQueue &#123; //构造原始数组 int[] arr; //数组长度 int size; //头指针，记录循环列表的头部 int head; //尾指针，记录循环列表的尾部 int tail; //计数器，记录总共有多少个元素 int count; //构造器，将原始的数组arr转化为实体，以及一些变量的初始化 public MyCircularQueue(int k) &#123; arr = new int[k]; size = k; head = 0; tail = 0; count = 0; &#125; //入队操作 public boolean enQueue(int value) &#123; //先判断队列是否已满。 if (isFull()) &#123; return false; &#125; arr[tail] = value; //关键点！此处的指针也应该跟着循环，不能说到了数组的size（最大长度）就一直无限延续 //所以这里需要取模运算&quot;%&quot; 例：k=size=7 tail=7 tail=（7+1%7=1 所以下次tail //的位置就在下角标为 1 的位置 从而达到循环指针的目的 后面的head指针同理 tail = (tail + 1) % size; count++; return true; &#125; //出队操作 public boolean deQueue() &#123; //判断是否为空 if (isEmpty()) &#123; return false; &#125; head = (head + 1) % size; count--; return true; &#125; //取头元素 public int Front() &#123; if (isEmpty()) &#123; return -1; &#125; return arr[head]; &#125; public int Rear() &#123; if(isEmpty())&#123; return -1; &#125; //此处需要注意tail的真实位置到底指向的是哪里。 //注意数据的处理不能取负。 return arr[(tail - 1 + size) % size]; &#125; //判断空 public boolean isEmpty() &#123; return count==0; &#125; //判断满 public boolean isFull() &#123; return size==count; &#125;&#125; 总结：在对循环队列实现的时候，注意的细节点有很多，需要做到指针循环才能达到整体的循环目的。总的来说还是难度中等。","categories":[{"name":"Problems","slug":"Problems","permalink":"http://oliverxuan.github.io/categories/Problems/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://oliverxuan.github.io/tags/leetcode/"}]},{"title":"hexo s 时4000端口被占用问题","slug":"hexo-s-时4000端口被占用问题","date":"2021-07-25T14:47:18.000Z","updated":"2021-07-29T17:24:31.003Z","comments":true,"path":"2021/07/25/hexo-s-时4000端口被占用问题/","link":"","permalink":"http://oliverxuan.github.io/2021/07/25/hexo-s-%E6%97%B64000%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98/","excerpt":"问题描述：hexo s 启动的时候遇到了 4000 端口无法创建使用的问题。具体打开 localhost：4000 发现 4000 端口下 hexo 依然在运行！ 解决方案：(mac 环境): sudo lsof -i tcp:4000查询当前端口的进程 报错： 12COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEnode 19087 root 23u IPv6 0xe0d367ae3505eeb3 0t0 TCP *:terabase (LISTEN) 发现进程 19087 sudo kill 19087 再次打开就没有 hexo 的页面了 最后成功在 4000 默认端口下启动 hexo","text":"问题描述：hexo s 启动的时候遇到了 4000 端口无法创建使用的问题。具体打开 localhost：4000 发现 4000 端口下 hexo 依然在运行！ 解决方案：(mac 环境): sudo lsof -i tcp:4000查询当前端口的进程 报错： 12COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEnode 19087 root 23u IPv6 0xe0d367ae3505eeb3 0t0 TCP *:terabase (LISTEN) 发现进程 19087 sudo kill 19087 再次打开就没有 hexo 的页面了 最后成功在 4000 默认端口下启动 hexo","categories":[{"name":"Obstacle","slug":"Obstacle","permalink":"http://oliverxuan.github.io/categories/Obstacle/"}],"tags":[{"name":"技术踩坑","slug":"技术踩坑","permalink":"http://oliverxuan.github.io/tags/%E6%8A%80%E6%9C%AF%E8%B8%A9%E5%9D%91/"}]},{"title":"关于大三一年的计划","slug":"关于大三一年的计划","date":"2021-07-25T14:39:56.000Z","updated":"2021-07-30T15:18:55.613Z","comments":true,"path":"2021/07/25/关于大三一年的计划/","link":"","permalink":"http://oliverxuan.github.io/2021/07/25/%E5%85%B3%E4%BA%8E%E5%A4%A7%E4%B8%89%E4%B8%80%E5%B9%B4%E7%9A%84%E8%AE%A1%E5%88%92/","excerpt":"大三这一年真的是无比关键.想着明年的今天就是我实习的日子.心里多少还是有些焦虑。 回顾自身：大一光顾着玩耍，等到大一暑假的时候突然感觉”玩的索然无味“玩的甚至有点空虚。觉得这不是自己想要的生活。于是放下了我喜欢的游戏。打开了哔哩哔哩，搜起了关于 Java 的教学视频，我还记着我第一次装 Jdk 第一次配置环境变量的时候的一脸懵逼。（这和我学的 C 不一样呀）好奇心促使我继续坚持学习了下去。就这样，我听着尚硅谷的宋红康老师的 Java 课程度过了第一个充实的暑假，也是在那个暑假，我渐渐地明白了，计算机的路，我才刚刚开始。等到了大二，我渐渐尝试着做一些简单的静态页面，跟着做一些简单的 JavaWeb 项目。当我第一次在我自己的数据库接收到前端页面发来的数据的时候，我真的无比激动！这真的是一件很有成就感的事情！到了大二的下学期，在好朋友的指引下，我渐渐接触一些更深层次的东西，我学习了 CoderWhy 老师的 Vue，学完了 Vue 我也深刻体会到组件化开发的便利性。真的佩服我们的尤大佬！能开发出这么好的框架！我什么时候才能到达他这种能力呀！大二这一年，是我学习进步最快的一年，我渐渐明白到了真正的差距到底有多大。所以我想在我大三这一年，有计划有目标地进行学习！争取在一年后的今天能取得互联网大厂的 offer！ 大三规划：大方向：扎实内功，基础。深入底层逻辑，原理。追求技术深度。多总结，多学习。具体目标，步骤: 复习巩固计算机原理，数据结构等计算机基础。（巩固基础） leetcode 坚持每天刷题。（巩固基础） 学习 Node.js 以达到能够做出前后端分离的全栈完整项目。（完善自己的技术面） 学习 uniapp 或 flutter 以达到跨平台，多处运用的目的。（完善自己的技术面） 深入研究 Javascript，Vue 的底层逻辑，以及源码。以达到一定的技术深度。（提高自己技术深度） 多做项目，多参加比赛。提高自己的眼界，技术的多样性，学习别人的优点，改善自己的不足。（提高自己技术深度）","text":"大三这一年真的是无比关键.想着明年的今天就是我实习的日子.心里多少还是有些焦虑。 回顾自身：大一光顾着玩耍，等到大一暑假的时候突然感觉”玩的索然无味“玩的甚至有点空虚。觉得这不是自己想要的生活。于是放下了我喜欢的游戏。打开了哔哩哔哩，搜起了关于 Java 的教学视频，我还记着我第一次装 Jdk 第一次配置环境变量的时候的一脸懵逼。（这和我学的 C 不一样呀）好奇心促使我继续坚持学习了下去。就这样，我听着尚硅谷的宋红康老师的 Java 课程度过了第一个充实的暑假，也是在那个暑假，我渐渐地明白了，计算机的路，我才刚刚开始。等到了大二，我渐渐尝试着做一些简单的静态页面，跟着做一些简单的 JavaWeb 项目。当我第一次在我自己的数据库接收到前端页面发来的数据的时候，我真的无比激动！这真的是一件很有成就感的事情！到了大二的下学期，在好朋友的指引下，我渐渐接触一些更深层次的东西，我学习了 CoderWhy 老师的 Vue，学完了 Vue 我也深刻体会到组件化开发的便利性。真的佩服我们的尤大佬！能开发出这么好的框架！我什么时候才能到达他这种能力呀！大二这一年，是我学习进步最快的一年，我渐渐明白到了真正的差距到底有多大。所以我想在我大三这一年，有计划有目标地进行学习！争取在一年后的今天能取得互联网大厂的 offer！ 大三规划：大方向：扎实内功，基础。深入底层逻辑，原理。追求技术深度。多总结，多学习。具体目标，步骤: 复习巩固计算机原理，数据结构等计算机基础。（巩固基础） leetcode 坚持每天刷题。（巩固基础） 学习 Node.js 以达到能够做出前后端分离的全栈完整项目。（完善自己的技术面） 学习 uniapp 或 flutter 以达到跨平台，多处运用的目的。（完善自己的技术面） 深入研究 Javascript，Vue 的底层逻辑，以及源码。以达到一定的技术深度。（提高自己技术深度） 多做项目，多参加比赛。提高自己的眼界，技术的多样性，学习别人的优点，改善自己的不足。（提高自己技术深度）","categories":[{"name":"CodeLife","slug":"CodeLife","permalink":"http://oliverxuan.github.io/categories/CodeLife/"}],"tags":[{"name":"规划","slug":"规划","permalink":"http://oliverxuan.github.io/tags/%E8%A7%84%E5%88%92/"}]}],"categories":[{"name":"字节","slug":"字节","permalink":"http://oliverxuan.github.io/categories/%E5%AD%97%E8%8A%82/"},{"name":"技术实现","slug":"技术实现","permalink":"http://oliverxuan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/"},{"name":"底层逻辑","slug":"底层逻辑","permalink":"http://oliverxuan.github.io/categories/%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/"},{"name":"ES6","slug":"ES6","permalink":"http://oliverxuan.github.io/categories/ES6/"},{"name":"练习题","slug":"练习题","permalink":"http://oliverxuan.github.io/categories/%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"name":"Obstacle","slug":"Obstacle","permalink":"http://oliverxuan.github.io/categories/Obstacle/"},{"name":"CodeLife","slug":"CodeLife","permalink":"http://oliverxuan.github.io/categories/CodeLife/"},{"name":"Problems","slug":"Problems","permalink":"http://oliverxuan.github.io/categories/Problems/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://oliverxuan.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"React","slug":"React","permalink":"http://oliverxuan.github.io/tags/React/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://oliverxuan.github.io/tags/JavaScript/"},{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"http://oliverxuan.github.io/tags/HTML-CSS/"},{"name":"node.js","slug":"node-js","permalink":"http://oliverxuan.github.io/tags/node-js/"},{"name":"vue","slug":"vue","permalink":"http://oliverxuan.github.io/tags/vue/"},{"name":"axios","slug":"axios","permalink":"http://oliverxuan.github.io/tags/axios/"},{"name":"项目","slug":"项目","permalink":"http://oliverxuan.github.io/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"规划","slug":"规划","permalink":"http://oliverxuan.github.io/tags/%E8%A7%84%E5%88%92/"},{"name":"leetcode","slug":"leetcode","permalink":"http://oliverxuan.github.io/tags/leetcode/"},{"name":"技术踩坑","slug":"技术踩坑","permalink":"http://oliverxuan.github.io/tags/%E6%8A%80%E6%9C%AF%E8%B8%A9%E5%9D%91/"}]}