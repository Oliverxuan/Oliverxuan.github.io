{"meta":{"title":"Oliver-xuan","subtitle":"记录我的程序员生涯","description":"","author":"Oliverxuan","url":"http://oliverxuan.github.io","root":"/"},"pages":[{"title":"关于","date":"2021-07-29T16:58:19.069Z","updated":"2021-07-29T16:58:19.069Z","comments":true,"path":"about/index.html","permalink":"http://oliverxuan.github.io/about/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-07-29T16:57:59.520Z","updated":"2021-07-29T16:57:59.520Z","comments":true,"path":"tags/index.html","permalink":"http://oliverxuan.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-07-29T16:58:11.125Z","updated":"2021-07-29T16:58:11.125Z","comments":true,"path":"categories/index.html","permalink":"http://oliverxuan.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"岛屿问题的实现","slug":"岛屿问题的实现","date":"2021-07-31T06:42:14.000Z","updated":"2021-07-31T06:51:19.367Z","comments":true,"path":"2021/07/31/岛屿问题的实现/","link":"","permalink":"http://oliverxuan.github.io/2021/07/31/%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"问题描述给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/number-of-islands著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解决方案此问题与上一期的门墙算法的实现的思想基本一致，属于利用队列，以及广度优先搜索（dfs）的方式解决问题。但是并不是完全的相同。本问题需要注意在于广度优先搜索的时候，需要有“感染”的思想。 首先遍历整个二维数组，寻找数组中的岛 再在孤岛的基础上 遍历他的上下左右临格元素 是否也为“1”岛屿 如果是 将它感染。 1234567891011121314151617181920212223242526272829public class Solution &#123; public int numIslands(char[][] grid) &#123; if(grid.length==0)&#123; return 0; &#125; int count=0; for (int i = 0; i &lt; grid.length; i++) &#123; for (int j = 0; j &lt; grid[0].length; j++) &#123; if(grid[i][j]==&#x27;1&#x27;)&#123; count++; dfs(grid,i,j); &#125; &#125; &#125; return count; &#125; private void dfs(char[][] grid, int i, int j) &#123; if(i&lt;0 || i&gt;= grid.length || j&lt;0 || j&gt;=grid[0].length || grid[i][j]==&#x27;0&#x27;)&#123; return; &#125; grid[i][j]=&#x27;0&#x27;; dfs(grid, i - 1, j); dfs(grid, i + 1, j); dfs(grid, i, j + 1); dfs(grid, i, j - 1); &#125;&#125;","text":"问题描述给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/number-of-islands著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解决方案此问题与上一期的门墙算法的实现的思想基本一致，属于利用队列，以及广度优先搜索（dfs）的方式解决问题。但是并不是完全的相同。本问题需要注意在于广度优先搜索的时候，需要有“感染”的思想。 首先遍历整个二维数组，寻找数组中的岛 再在孤岛的基础上 遍历他的上下左右临格元素 是否也为“1”岛屿 如果是 将它感染。 1234567891011121314151617181920212223242526272829public class Solution &#123; public int numIslands(char[][] grid) &#123; if(grid.length==0)&#123; return 0; &#125; int count=0; for (int i = 0; i &lt; grid.length; i++) &#123; for (int j = 0; j &lt; grid[0].length; j++) &#123; if(grid[i][j]==&#x27;1&#x27;)&#123; count++; dfs(grid,i,j); &#125; &#125; &#125; return count; &#125; private void dfs(char[][] grid, int i, int j) &#123; if(i&lt;0 || i&gt;= grid.length || j&lt;0 || j&gt;=grid[0].length || grid[i][j]==&#x27;0&#x27;)&#123; return; &#125; grid[i][j]=&#x27;0&#x27;; dfs(grid, i - 1, j); dfs(grid, i + 1, j); dfs(grid, i, j + 1); dfs(grid, i, j - 1); &#125;&#125;","categories":[{"name":"Problems","slug":"Problems","permalink":"http://oliverxuan.github.io/categories/Problems/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://oliverxuan.github.io/tags/leetcode/"}]},{"title":"门与墙算法的实现","slug":"门与墙算法的实现","date":"2021-07-29T14:50:18.000Z","updated":"2021-07-30T15:16:58.408Z","comments":true,"path":"2021/07/29/门与墙算法的实现/","link":"","permalink":"http://oliverxuan.github.io/2021/07/29/%E9%97%A8%E4%B8%8E%E5%A2%99%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"问题描述：你被给定一个 m × n 的二维网格 rooms ，网格中有以下三种可能的初始化值：-1 表示墙或是障碍物 0 表示一扇门INF 无限表示一个空的房间。然后，我们用 231 - 1 = 2147483647 代表 INF。你可以认为通往门的距离总是小于 2147483647 的。你要给每个空房间位上填上该房间到 最近门的距离 ，如果无法到达门，则填 INF 即可。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/walls-and-gates著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 建立基本数据以及辅助坐标 先寻找门坐标，将其入队 取出队头元素 A 进行解析 分析 A 上下左右 block 是否可用 合法 A 是否未赋值 将合法的 block 进行赋值（步数） 将新的 block 入队 结束条件当取出的区域 上下左右都已经赋值 ｜｜ 为墙，为门 则无需处理，退出处理队列 本题的突破点: 理解队列先进先出的性质 广度优先搜索的性质 先找门，后赋值的思路 ps：block 我的定义是 INF 即可用的房间","text":"问题描述：你被给定一个 m × n 的二维网格 rooms ，网格中有以下三种可能的初始化值：-1 表示墙或是障碍物 0 表示一扇门INF 无限表示一个空的房间。然后，我们用 231 - 1 = 2147483647 代表 INF。你可以认为通往门的距离总是小于 2147483647 的。你要给每个空房间位上填上该房间到 最近门的距离 ，如果无法到达门，则填 INF 即可。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/walls-and-gates著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 建立基本数据以及辅助坐标 先寻找门坐标，将其入队 取出队头元素 A 进行解析 分析 A 上下左右 block 是否可用 合法 A 是否未赋值 将合法的 block 进行赋值（步数） 将新的 block 入队 结束条件当取出的区域 上下左右都已经赋值 ｜｜ 为墙，为门 则无需处理，退出处理队列 本题的突破点: 理解队列先进先出的性质 广度优先搜索的性质 先找门，后赋值的思路 ps：block 我的定义是 INF 即可用的房间 实现难点 如何寻找 block 的上下左右房间 该房间的周围空间是否有用 能否联想到新的 block 就当作是一个新门，再从新门找他的上下左右 block 如何进行数据处理 细节处理 象形理解把每一个门当作一个大的问题小孩（类似孩子王），队列就是记录未解决问题小孩的清单。我们把每一个 INF 区域当作一个医生，安排医生用最小的距离去解决这些问题小孩。我们先在房间里寻找大问题小孩，将他们全部记录在清单上。我们开始分析他周围是否也有问题小孩（孩子王的小跟班）（上下左右检查）如果有（该区域为空）且该问题其他医生没有解决（未赋值）我们就指派该区域的医生去解决这个问题小孩，并且记录该问题小孩离孩子王有多远。（为 block 赋值）如果周围的问题小孩已经有医生解决了，我们就不管。将新的问题小孩记录在队列上，原先的孩子王的下线已经全盘供出，所以他从问题清单上划除。继续解决清单上的新的问题小孩….（可能有点不怎么容易理解。。。。我真的尽力了 源码 yyds ） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Solution &#123; //定义空房间的特征值 private static final int INF = 2147483647; //定义门的特殊值 private static final int DOOR = 0; //定义辅助坐标 以此来表示房间的上下左右 private static final List&lt;int[]&gt; DIRECTIONS = Arrays.asList( new int[]&#123;1, 0&#125;, new int[]&#123;-1, 0&#125;, new int[]&#123;0, -1&#125;, new int[]&#123;0, 1&#125; ); public void wallsAndGates(int[][] rooms) &#123; //记录房间的长宽 int m= rooms.length; int n=rooms[0].length; if(m==0)&#123; return; &#125; //创建队列 Queue&lt;int []&gt; queue=new LinkedList&lt;&gt;(); //遍历rooms 寻找所有的门 for (int row = 0; row &lt; m; row++) &#123; for (int col = 0; col &lt; n; col++) &#123; //当检测到该地区为门的时候 将门的坐标元素入队 if(rooms[row][col]==DOOR)&#123; queue.add(new int[]&#123;row,col&#125;); &#125; &#125; &#125; //核心区域 （当队列不为空的时候，继续执行） while(!queue.isEmpty())&#123; //取出队头的元素 也是最先入队的元素 （ d,c,b,a =&gt; a) int[] block = queue.poll(); //记录原生的行，列数据 int row=block[0]; int col=block[1]; //制造当前block的上下左右block 利用辅助坐标快速制作出新的坐标数据 for (int [] direction: DIRECTIONS) &#123; int r=row+direction[0]; int c=col+direction[1]; //判断新的坐标是否合法 是否存在障碍物 ！！（重点！）是否之前已经被被赋值过！！ //如果已经被赋值 说明当前值就是该区域的最短路径，再次改变就是不准确值 // 因为是广度优先 所以当前值一定是最优值 if(r&lt;0 || c&lt;0 || r&gt;=rooms.length || c&gt;=rooms[0].length || rooms[r][c]!=INF)&#123; continue; &#125; //细节点 需要在前一个block的值上进行+1 否则步数全为1 rooms[r][c]=rooms[row][col]+1; //如果都不是 则为全新的为赋值block 将其加入队列（列尾） queue.add(new int[]&#123;r,c&#125;); &#125; &#125; &#125;&#125;","categories":[{"name":"Problems","slug":"Problems","permalink":"http://oliverxuan.github.io/categories/Problems/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://oliverxuan.github.io/tags/leetcode/"}]},{"title":"循环队列的实现","slug":"循环队列的实现","date":"2021-07-27T17:21:50.000Z","updated":"2021-07-30T15:17:02.169Z","comments":true,"path":"2021/07/28/循环队列的实现/","link":"","permalink":"http://oliverxuan.github.io/2021/07/28/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"问题描述：设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。 循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。 你的实现应该支持如下操作： MyCircularQueue(k): 构造器，设置队列长度为 k 。Front: 从队首获取元素。如果队列为空，返回 -1 。Rear: 获取队尾元素。如果队列为空，返回 -1 。enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。isEmpty(): 检查循环队列是否为空。isFull(): 检查循环队列是否已满。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/design-circular-queue 示例：MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3circularQueue.enQueue(1); // 返回 truecircularQueue.enQueue(2); // 返回 truecircularQueue.enQueue(3); // 返回 truecircularQueue.enQueue(4); // 返回 false，队列已满circularQueue.Rear(); // 返回 3circularQueue.isFull(); // 返回 truecircularQueue.deQueue(); // 返回 truecircularQueue.enQueue(4); // 返回 truecircularQueue.Rear(); // 返回 4 解题思路： 首先要明白循环队列的原理 如何设计循环队列中的两个指针 细节处理","text":"问题描述：设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。 循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。 你的实现应该支持如下操作： MyCircularQueue(k): 构造器，设置队列长度为 k 。Front: 从队首获取元素。如果队列为空，返回 -1 。Rear: 获取队尾元素。如果队列为空，返回 -1 。enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。isEmpty(): 检查循环队列是否为空。isFull(): 检查循环队列是否已满。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/design-circular-queue 示例：MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3circularQueue.enQueue(1); // 返回 truecircularQueue.enQueue(2); // 返回 truecircularQueue.enQueue(3); // 返回 truecircularQueue.enQueue(4); // 返回 false，队列已满circularQueue.Rear(); // 返回 3circularQueue.isFull(); // 返回 truecircularQueue.deQueue(); // 返回 truecircularQueue.enQueue(4); // 返回 truecircularQueue.Rear(); // 返回 4 解题思路： 首先要明白循环队列的原理 如何设计循环队列中的两个指针 细节处理 循环队列原理https://www.bilibili.com/video/BV1yx411e7nb?from=search&amp;seid=13632348157331521482/ 实现难点： 为什么要在 eg：head（head+1）% size 取模？ 为什么 get tail 的时候不能直接返回？ 细节处理 实现代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class MyCircularQueue &#123; //构造原始数组 int[] arr; //数组长度 int size; //头指针，记录循环列表的头部 int head; //尾指针，记录循环列表的尾部 int tail; //计数器，记录总共有多少个元素 int count; //构造器，将原始的数组arr转化为实体，以及一些变量的初始化 public MyCircularQueue(int k) &#123; arr = new int[k]; size = k; head = 0; tail = 0; count = 0; &#125; //入队操作 public boolean enQueue(int value) &#123; //先判断队列是否已满。 if (isFull()) &#123; return false; &#125; arr[tail] = value; //关键点！此处的指针也应该跟着循环，不能说到了数组的size（最大长度）就一直无限延续 //所以这里需要取模运算&quot;%&quot; 例：k=size=7 tail=7 tail=（7+1%7=1 所以下次tail //的位置就在下角标为 1 的位置 从而达到循环指针的目的 后面的head指针同理 tail = (tail + 1) % size; count++; return true; &#125; //出队操作 public boolean deQueue() &#123; //判断是否为空 if (isEmpty()) &#123; return false; &#125; head = (head + 1) % size; count--; return true; &#125; //取头元素 public int Front() &#123; if (isEmpty()) &#123; return -1; &#125; return arr[head]; &#125; public int Rear() &#123; if(isEmpty())&#123; return -1; &#125; //此处需要注意tail的真实位置到底指向的是哪里。 //注意数据的处理不能取负。 return arr[(tail - 1 + size) % size]; &#125; //判断空 public boolean isEmpty() &#123; return count==0; &#125; //判断满 public boolean isFull() &#123; return size==count; &#125;&#125; 总结：在对循环队列实现的时候，注意的细节点有很多，需要做到指针循环才能达到整体的循环目的。总的来说还是难度中等。","categories":[{"name":"Problems","slug":"Problems","permalink":"http://oliverxuan.github.io/categories/Problems/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://oliverxuan.github.io/tags/leetcode/"}]},{"title":"hexo s 时4000端口被占用问题","slug":"hexo-s-时4000端口被占用问题","date":"2021-07-25T14:47:18.000Z","updated":"2021-07-29T17:24:31.003Z","comments":true,"path":"2021/07/25/hexo-s-时4000端口被占用问题/","link":"","permalink":"http://oliverxuan.github.io/2021/07/25/hexo-s-%E6%97%B64000%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98/","excerpt":"问题描述：hexo s 启动的时候遇到了 4000 端口无法创建使用的问题。具体打开 localhost：4000 发现 4000 端口下 hexo 依然在运行！ 解决方案：(mac 环境): sudo lsof -i tcp:4000查询当前端口的进程 报错： 12COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEnode 19087 root 23u IPv6 0xe0d367ae3505eeb3 0t0 TCP *:terabase (LISTEN) 发现进程 19087 sudo kill 19087 再次打开就没有 hexo 的页面了 最后成功在 4000 默认端口下启动 hexo","text":"问题描述：hexo s 启动的时候遇到了 4000 端口无法创建使用的问题。具体打开 localhost：4000 发现 4000 端口下 hexo 依然在运行！ 解决方案：(mac 环境): sudo lsof -i tcp:4000查询当前端口的进程 报错： 12COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEnode 19087 root 23u IPv6 0xe0d367ae3505eeb3 0t0 TCP *:terabase (LISTEN) 发现进程 19087 sudo kill 19087 再次打开就没有 hexo 的页面了 最后成功在 4000 默认端口下启动 hexo","categories":[{"name":"Obstacle","slug":"Obstacle","permalink":"http://oliverxuan.github.io/categories/Obstacle/"}],"tags":[{"name":"技术踩坑","slug":"技术踩坑","permalink":"http://oliverxuan.github.io/tags/%E6%8A%80%E6%9C%AF%E8%B8%A9%E5%9D%91/"}]},{"title":"关于大三一年的计划","slug":"关于大三一年的计划","date":"2021-07-25T14:39:56.000Z","updated":"2021-07-30T15:18:55.613Z","comments":true,"path":"2021/07/25/关于大三一年的计划/","link":"","permalink":"http://oliverxuan.github.io/2021/07/25/%E5%85%B3%E4%BA%8E%E5%A4%A7%E4%B8%89%E4%B8%80%E5%B9%B4%E7%9A%84%E8%AE%A1%E5%88%92/","excerpt":"大三这一年真的是无比关键.想着明年的今天就是我实习的日子.心里多少还是有些焦虑。 回顾自身：大一光顾着玩耍，等到大一暑假的时候突然感觉”玩的索然无味“玩的甚至有点空虚。觉得这不是自己想要的生活。于是放下了我喜欢的游戏。打开了哔哩哔哩，搜起了关于 Java 的教学视频，我还记着我第一次装 Jdk 第一次配置环境变量的时候的一脸懵逼。（这和我学的 C 不一样呀）好奇心促使我继续坚持学习了下去。就这样，我听着尚硅谷的宋红康老师的 Java 课程度过了第一个充实的暑假，也是在那个暑假，我渐渐地明白了，计算机的路，我才刚刚开始。等到了大二，我渐渐尝试着做一些简单的静态页面，跟着做一些简单的 JavaWeb 项目。当我第一次在我自己的数据库接收到前端页面发来的数据的时候，我真的无比激动！这真的是一件很有成就感的事情！到了大二的下学期，在好朋友的指引下，我渐渐接触一些更深层次的东西，我学习了 CoderWhy 老师的 Vue，学完了 Vue 我也深刻体会到组件化开发的便利性。真的佩服我们的尤大佬！能开发出这么好的框架！我什么时候才能到达他这种能力呀！大二这一年，是我学习进步最快的一年，我渐渐明白到了真正的差距到底有多大。所以我想在我大三这一年，有计划有目标地进行学习！争取在一年后的今天能取得互联网大厂的 offer！ 大三规划：大方向：扎实内功，基础。深入底层逻辑，原理。追求技术深度。多总结，多学习。具体目标，步骤: 复习巩固计算机原理，数据结构等计算机基础。（巩固基础） leetcode 坚持每天刷题。（巩固基础） 学习 Node.js 以达到能够做出前后端分离的全栈完整项目。（完善自己的技术面） 学习 uniapp 或 flutter 以达到跨平台，多处运用的目的。（完善自己的技术面） 深入研究 Javascript，Vue 的底层逻辑，以及源码。以达到一定的技术深度。（提高自己技术深度） 多做项目，多参加比赛。提高自己的眼界，技术的多样性，学习别人的优点，改善自己的不足。（提高自己技术深度）","text":"大三这一年真的是无比关键.想着明年的今天就是我实习的日子.心里多少还是有些焦虑。 回顾自身：大一光顾着玩耍，等到大一暑假的时候突然感觉”玩的索然无味“玩的甚至有点空虚。觉得这不是自己想要的生活。于是放下了我喜欢的游戏。打开了哔哩哔哩，搜起了关于 Java 的教学视频，我还记着我第一次装 Jdk 第一次配置环境变量的时候的一脸懵逼。（这和我学的 C 不一样呀）好奇心促使我继续坚持学习了下去。就这样，我听着尚硅谷的宋红康老师的 Java 课程度过了第一个充实的暑假，也是在那个暑假，我渐渐地明白了，计算机的路，我才刚刚开始。等到了大二，我渐渐尝试着做一些简单的静态页面，跟着做一些简单的 JavaWeb 项目。当我第一次在我自己的数据库接收到前端页面发来的数据的时候，我真的无比激动！这真的是一件很有成就感的事情！到了大二的下学期，在好朋友的指引下，我渐渐接触一些更深层次的东西，我学习了 CoderWhy 老师的 Vue，学完了 Vue 我也深刻体会到组件化开发的便利性。真的佩服我们的尤大佬！能开发出这么好的框架！我什么时候才能到达他这种能力呀！大二这一年，是我学习进步最快的一年，我渐渐明白到了真正的差距到底有多大。所以我想在我大三这一年，有计划有目标地进行学习！争取在一年后的今天能取得互联网大厂的 offer！ 大三规划：大方向：扎实内功，基础。深入底层逻辑，原理。追求技术深度。多总结，多学习。具体目标，步骤: 复习巩固计算机原理，数据结构等计算机基础。（巩固基础） leetcode 坚持每天刷题。（巩固基础） 学习 Node.js 以达到能够做出前后端分离的全栈完整项目。（完善自己的技术面） 学习 uniapp 或 flutter 以达到跨平台，多处运用的目的。（完善自己的技术面） 深入研究 Javascript，Vue 的底层逻辑，以及源码。以达到一定的技术深度。（提高自己技术深度） 多做项目，多参加比赛。提高自己的眼界，技术的多样性，学习别人的优点，改善自己的不足。（提高自己技术深度）","categories":[{"name":"CodeLife","slug":"CodeLife","permalink":"http://oliverxuan.github.io/categories/CodeLife/"}],"tags":[{"name":"规划","slug":"规划","permalink":"http://oliverxuan.github.io/tags/%E8%A7%84%E5%88%92/"}]}],"categories":[{"name":"Problems","slug":"Problems","permalink":"http://oliverxuan.github.io/categories/Problems/"},{"name":"Obstacle","slug":"Obstacle","permalink":"http://oliverxuan.github.io/categories/Obstacle/"},{"name":"CodeLife","slug":"CodeLife","permalink":"http://oliverxuan.github.io/categories/CodeLife/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://oliverxuan.github.io/tags/leetcode/"},{"name":"技术踩坑","slug":"技术踩坑","permalink":"http://oliverxuan.github.io/tags/%E6%8A%80%E6%9C%AF%E8%B8%A9%E5%9D%91/"},{"name":"规划","slug":"规划","permalink":"http://oliverxuan.github.io/tags/%E8%A7%84%E5%88%92/"}]}