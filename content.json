{"meta":{"title":"Oliver-xuan","subtitle":"记录我的程序员生涯","description":"","author":"Oliverxuan","url":"http://oliverxuan.github.io","root":"/"},"pages":[{"title":"分类","date":"2021-07-29T16:58:11.125Z","updated":"2021-07-29T16:58:11.125Z","comments":true,"path":"categories/index.html","permalink":"http://oliverxuan.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-07-29T16:57:59.520Z","updated":"2021-07-29T16:57:59.520Z","comments":true,"path":"tags/index.html","permalink":"http://oliverxuan.github.io/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-07-29T16:58:19.069Z","updated":"2021-07-29T16:58:19.069Z","comments":true,"path":"about/index.html","permalink":"http://oliverxuan.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"node.js 用户登陆初体验","slug":"node-js-用户登陆初体验","date":"2021-08-13T16:59:57.000Z","updated":"2021-08-13T17:48:58.913Z","comments":true,"path":"2021/08/14/node-js-用户登陆初体验/","link":"","permalink":"http://oliverxuan.github.io/2021/08/14/node-js-%E7%94%A8%E6%88%B7%E7%99%BB%E9%99%86%E5%88%9D%E4%BD%93%E9%AA%8C/","excerpt":"实现目标写一个接口，实现从用户输入中获得数据 技术点文件夹功能分类 app (app 操作文件夹) index.js (导入所使用的插件，中间件) 12345678910111213141516// 导入所需的插件，中间件const Koa = require(&#x27;koa&#x27;)const bodyParser = require(&#x27;koa-bodyparser&#x27;)const userRouter = require(&#x27;../router/user.router&#x27;)//实例化Koa对象const app = new Koa()//注册/使用插件，中间件app.use(bodyParser())app.use(userRouter.routes())app.use(userRouter.allowedMethods())//导出app 以便其他模块使用module.exports = app config.js (配置操作) 12345678//导入插件const dotenv = require(&#x27;dotenv&#x27;)//使用插件的方法，导入写好的配置文件（.env）dotenv.config()module.exports = &#123; APP_PORT &#125; = process.env main.js (程序的总入口)","text":"实现目标写一个接口，实现从用户输入中获得数据 技术点文件夹功能分类 app (app 操作文件夹) index.js (导入所使用的插件，中间件) 12345678910111213141516// 导入所需的插件，中间件const Koa = require(&#x27;koa&#x27;)const bodyParser = require(&#x27;koa-bodyparser&#x27;)const userRouter = require(&#x27;../router/user.router&#x27;)//实例化Koa对象const app = new Koa()//注册/使用插件，中间件app.use(bodyParser())app.use(userRouter.routes())app.use(userRouter.allowedMethods())//导出app 以便其他模块使用module.exports = app config.js (配置操作) 12345678//导入插件const dotenv = require(&#x27;dotenv&#x27;)//使用插件的方法，导入写好的配置文件（.env）dotenv.config()module.exports = &#123; APP_PORT &#125; = process.env main.js (程序的总入口) 123456789// 导入之前的Koa实例化的对象app。 导入配置文件const app = require(&#x27;./app&#x27;)const config = require(&#x27;./app/config&#x27;)//创建服务器，并利用config的APP_PORT参数app.listen(config.APP_PORT, () =&gt; &#123; console.log(`服务器在$&#123;config.APP_PORT&#125;端口已启动`)&#125;) router (所有的路由管理文件夹) user.router.js (user 的路由管理) 12345678910111213141516// 路由相关的js 注册接口适用//导入koa-router组件const Router = require(&#x27;koa-router&#x27;)//导入方法const &#123; create &#125; = require(&#x27;../controller/user.controller&#x27;)//注册路由 其路径为/usersconst userRouter = new Router(&#123; prefix: &#x27;/users&#x27; &#125;)//设置路由的响应方式，响应方法userRouter.post(&#x27;/&#x27;, create)//导出路由module.exports = userRouter controller (管理不同路径下的不同的情况下的方法，操作) user.controller.js (user 的一些方法，操作) 12345678910111213141516171819//导入写好的方法const service = require(&#x27;../service/user.service&#x27;)//创建类 其中包含了不同情况下的不同方法class UserController &#123; async create(ctx, next) &#123; //获取用户请求的参数 const user = ctx.request.body //查询数据 const result = await service.create(user) //返回数据 ctx.body = result &#125;&#125;module.exports = new UserController() service (业务层，其一般对接着 mysql 数据库操作) user.service.js 1234567891011//创建类class UserService &#123; async create(user) &#123; console.log(&#x27;将用户数据保存到数据库中&#x27;, user) //将user存储到数据库中 return &#x27;创建用户成功&#x27; &#125;&#125;module.exports = new UserService() utils (工具类) .env (配置文件) 123# 服务器端口号APP_PORT=8000 实现结果 总结本次实现了一个小功能，主要目的是想让自己理清楚这个文件与文件之间的关系，以及不同的文件之间的分工。","categories":[{"name":"technology","slug":"technology","permalink":"http://oliverxuan.github.io/categories/technology/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://oliverxuan.github.io/tags/node-js/"}]},{"title":"Better-scroll 中无法滚动问题","slug":"Better-scroll-中无法滚动问题","date":"2021-08-11T06:25:44.000Z","updated":"2021-08-11T06:50:36.367Z","comments":true,"path":"2021/08/11/Better-scroll-中无法滚动问题/","link":"","permalink":"http://oliverxuan.github.io/2021/08/11/Better-scroll-%E4%B8%AD%E6%97%A0%E6%B3%95%E6%BB%9A%E5%8A%A8%E9%97%AE%E9%A2%98/","excerpt":"问题描述在昨天我在使用 Vue 开发前端页面的时候，我遇到了在使用 better-scroll 实现页面滚动的时候无法滚动经过排查，问题出在与 better-scroll 的滚动原理与实际高度之间产生矛盾（图片异步加载问题） 问题分析在之前的 GoodsList 组件中，有一个加载接口图片的操作 12345678910&lt;template&gt; &lt;div class=&quot;goods-item&quot;&gt; &lt;img :src=&quot;goodsItem.img&quot; alt=&quot;&quot; /&gt; &lt;div class=&quot;goods-info&quot;&gt; &lt;p&gt;&#123;&#123; goodsItem.name &#125;&#125;&lt;/p&gt; &lt;span class=&quot;price&quot;&gt;RMB:&#123;&#123; goodsItem.price &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 由于 better-scroll 在计算 wrapper content 高度的时候是在一开始就会计算好 从而达到滚动的目的 但是 Goods list 会加载网路图片，存在一个异步问题加载完后，实际的高度会远超于之前 better-scroll 计算的高度 从而导致 better-scroll 之间计算无效了，最终无法滚动 解决方法123456789&lt;template&gt; &lt;div class=&quot;goods-item&quot;&gt; &lt;img :src=&quot;goodsItem.img&quot; alt=&quot;&quot; @load=&quot;imageload&quot; /&gt; &lt;div class=&quot;goods-info&quot;&gt; &lt;p&gt;&#123;&#123; goodsItem.name &#125;&#125;&lt;/p&gt; &lt;span class=&quot;price&quot;&gt;RMB:&#123;&#123; goodsItem.price &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;","text":"问题描述在昨天我在使用 Vue 开发前端页面的时候，我遇到了在使用 better-scroll 实现页面滚动的时候无法滚动经过排查，问题出在与 better-scroll 的滚动原理与实际高度之间产生矛盾（图片异步加载问题） 问题分析在之前的 GoodsList 组件中，有一个加载接口图片的操作 12345678910&lt;template&gt; &lt;div class=&quot;goods-item&quot;&gt; &lt;img :src=&quot;goodsItem.img&quot; alt=&quot;&quot; /&gt; &lt;div class=&quot;goods-info&quot;&gt; &lt;p&gt;&#123;&#123; goodsItem.name &#125;&#125;&lt;/p&gt; &lt;span class=&quot;price&quot;&gt;RMB:&#123;&#123; goodsItem.price &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 由于 better-scroll 在计算 wrapper content 高度的时候是在一开始就会计算好 从而达到滚动的目的 但是 Goods list 会加载网路图片，存在一个异步问题加载完后，实际的高度会远超于之前 better-scroll 计算的高度 从而导致 better-scroll 之间计算无效了，最终无法滚动 解决方法123456789&lt;template&gt; &lt;div class=&quot;goods-item&quot;&gt; &lt;img :src=&quot;goodsItem.img&quot; alt=&quot;&quot; @load=&quot;imageload&quot; /&gt; &lt;div class=&quot;goods-info&quot;&gt; &lt;p&gt;&#123;&#123; goodsItem.name &#125;&#125;&lt;/p&gt; &lt;span class=&quot;price&quot;&gt;RMB:&#123;&#123; goodsItem.price &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 在原代码 “&lt; img &gt;”标签处新增 @load=”imageload“ 监听事件 12345methods: &#123; imageload() &#123; this.$bus.$emit(&quot;itemImageLoad&quot;); &#125; &#125; 随后在方法里将此事件发射到事件总线里面 注意，需要在 main.js 里注册 事件总线 12345678910111213import Vue from &quot;vue&quot;;import App from &quot;./App.vue&quot;;import router from &quot;./router&quot;;import store from &quot;./store&quot;;Vue.config.productionTip = false;Vue.prototype.$bus = new Vue();new Vue(&#123; router, store, render: h =&gt; h(App)&#125;).$mount(&quot;#app&quot;); 将事件传入事件总线后 需要在 better-scroll 滚动页面里面监听事件 12345mounted() &#123; this.$bus.$on(&quot;itemImageLoad&quot;, () =&gt; &#123; this.$refs.scroll.scroll.refresh(); &#125;); &#125;, 提前设置 better-scroll 中的 refs 从而方便操作 最后监听到图片加载后 调用 scroll 的 refresh（）函数达到重新计算高度的目的 性能优化由于之前的频繁发出事件 image load 导致 实际上会 refresh 很多次 此处就需要 dbounce 防抖函数来处理 ： 12345678910function debounce(fn,delay)&#123; var handle; return function()&#123; clearTimeout(handle) handle=setTimeout(function()&#123; fn() &#125;,delay) &#125; &#125; 从而达到性能优化的目的","categories":[{"name":"Obstacle","slug":"Obstacle","permalink":"http://oliverxuan.github.io/categories/Obstacle/"}],"tags":[{"name":"技术踩坑","slug":"技术踩坑","permalink":"http://oliverxuan.github.io/tags/%E6%8A%80%E6%9C%AF%E8%B8%A9%E5%9D%91/"}]},{"title":"Hello,好久不见","slug":"Hello-好久不见","date":"2021-08-11T06:04:48.000Z","updated":"2021-08-11T06:25:13.431Z","comments":true,"path":"2021/08/11/Hello-好久不见/","link":"","permalink":"http://oliverxuan.github.io/2021/08/11/Hello-%E5%A5%BD%E4%B9%85%E4%B8%8D%E8%A7%81/","excerpt":"最近都去干什么了？距离上次更新我的博客已经过去了 10 多天了，在这段时间里我开始新的征程 =&gt; 准备 9 月份的 辽宁省大学生移动开发大赛 我计划着开发一个护肤品测评网站，整个网站的架构为：前端：Vue 全家桶，axios 后端：Node.js，express 数据库：Mysql 期间遇到的问题困难由于我之前没有涉及过后端的接口开发，所以我在这 10 天的时间里自学了一点 Node.js 的开发基础。顺便学习了 Express，Koa 框架的基本开发。 到目前为止，我已成功地将写好的使用 Express 的 Js 程序用 Node.js 部署在我的云服务器上。 在这其中我遇到了很多的困难，例如： 在服务器上部署合适的 Node &amp; Mysql 如何在本地通过 ssh 连接远端服务器","text":"最近都去干什么了？距离上次更新我的博客已经过去了 10 多天了，在这段时间里我开始新的征程 =&gt; 准备 9 月份的 辽宁省大学生移动开发大赛 我计划着开发一个护肤品测评网站，整个网站的架构为：前端：Vue 全家桶，axios 后端：Node.js，express 数据库：Mysql 期间遇到的问题困难由于我之前没有涉及过后端的接口开发，所以我在这 10 天的时间里自学了一点 Node.js 的开发基础。顺便学习了 Express，Koa 框架的基本开发。 到目前为止，我已成功地将写好的使用 Express 的 Js 程序用 Node.js 部署在我的云服务器上。 在这其中我遇到了很多的困难，例如： 在服务器上部署合适的 Node &amp; Mysql 如何在本地通过 ssh 连接远端服务器 ssh root@ip 如何在 vs code navicat-mysql ssh 连接远端数据 vs code 通过远程资源管理器 mysql 里设置可远端读写权限 navicat 在建立连接时正确写入服务器中的数据库信息 注意需要在服务器安全组里开放相应的端口 建立数据库，在 Vue 里通过 axios 连接远端数据库 处理接口数据 如何在服务器上一直运行 Node 项目 npm2 管理插件 在此感谢前辈们在遇到困难时留下的宝贵经验，以至于我在后续开发时遇到问题都能及时解决","categories":[{"name":"CodeLife","slug":"CodeLife","permalink":"http://oliverxuan.github.io/categories/CodeLife/"}],"tags":[{"name":"规划","slug":"规划","permalink":"http://oliverxuan.github.io/tags/%E8%A7%84%E5%88%92/"}]},{"title":"岛屿问题的实现","slug":"岛屿问题的实现","date":"2021-07-31T06:42:14.000Z","updated":"2021-07-31T06:51:19.367Z","comments":true,"path":"2021/07/31/岛屿问题的实现/","link":"","permalink":"http://oliverxuan.github.io/2021/07/31/%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"问题描述给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/number-of-islands著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解决方案此问题与上一期的门墙算法的实现的思想基本一致，属于利用队列，以及广度优先搜索（dfs）的方式解决问题。但是并不是完全的相同。本问题需要注意在于广度优先搜索的时候，需要有“感染”的思想。 首先遍历整个二维数组，寻找数组中的岛 再在孤岛的基础上 遍历他的上下左右临格元素 是否也为“1”岛屿 如果是 将它感染。 1234567891011121314151617181920212223242526272829public class Solution &#123; public int numIslands(char[][] grid) &#123; if(grid.length==0)&#123; return 0; &#125; int count=0; for (int i = 0; i &lt; grid.length; i++) &#123; for (int j = 0; j &lt; grid[0].length; j++) &#123; if(grid[i][j]==&#x27;1&#x27;)&#123; count++; dfs(grid,i,j); &#125; &#125; &#125; return count; &#125; private void dfs(char[][] grid, int i, int j) &#123; if(i&lt;0 || i&gt;= grid.length || j&lt;0 || j&gt;=grid[0].length || grid[i][j]==&#x27;0&#x27;)&#123; return; &#125; grid[i][j]=&#x27;0&#x27;; dfs(grid, i - 1, j); dfs(grid, i + 1, j); dfs(grid, i, j + 1); dfs(grid, i, j - 1); &#125;&#125;","text":"问题描述给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/number-of-islands著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解决方案此问题与上一期的门墙算法的实现的思想基本一致，属于利用队列，以及广度优先搜索（dfs）的方式解决问题。但是并不是完全的相同。本问题需要注意在于广度优先搜索的时候，需要有“感染”的思想。 首先遍历整个二维数组，寻找数组中的岛 再在孤岛的基础上 遍历他的上下左右临格元素 是否也为“1”岛屿 如果是 将它感染。 1234567891011121314151617181920212223242526272829public class Solution &#123; public int numIslands(char[][] grid) &#123; if(grid.length==0)&#123; return 0; &#125; int count=0; for (int i = 0; i &lt; grid.length; i++) &#123; for (int j = 0; j &lt; grid[0].length; j++) &#123; if(grid[i][j]==&#x27;1&#x27;)&#123; count++; dfs(grid,i,j); &#125; &#125; &#125; return count; &#125; private void dfs(char[][] grid, int i, int j) &#123; if(i&lt;0 || i&gt;= grid.length || j&lt;0 || j&gt;=grid[0].length || grid[i][j]==&#x27;0&#x27;)&#123; return; &#125; grid[i][j]=&#x27;0&#x27;; dfs(grid, i - 1, j); dfs(grid, i + 1, j); dfs(grid, i, j + 1); dfs(grid, i, j - 1); &#125;&#125;","categories":[{"name":"Problems","slug":"Problems","permalink":"http://oliverxuan.github.io/categories/Problems/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://oliverxuan.github.io/tags/leetcode/"}]},{"title":"门与墙算法的实现","slug":"门与墙算法的实现","date":"2021-07-29T14:50:18.000Z","updated":"2021-07-30T15:16:58.408Z","comments":true,"path":"2021/07/29/门与墙算法的实现/","link":"","permalink":"http://oliverxuan.github.io/2021/07/29/%E9%97%A8%E4%B8%8E%E5%A2%99%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"问题描述：你被给定一个 m × n 的二维网格 rooms ，网格中有以下三种可能的初始化值：-1 表示墙或是障碍物 0 表示一扇门INF 无限表示一个空的房间。然后，我们用 231 - 1 = 2147483647 代表 INF。你可以认为通往门的距离总是小于 2147483647 的。你要给每个空房间位上填上该房间到 最近门的距离 ，如果无法到达门，则填 INF 即可。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/walls-and-gates著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 建立基本数据以及辅助坐标 先寻找门坐标，将其入队 取出队头元素 A 进行解析 分析 A 上下左右 block 是否可用 合法 A 是否未赋值 将合法的 block 进行赋值（步数） 将新的 block 入队 结束条件当取出的区域 上下左右都已经赋值 ｜｜ 为墙，为门 则无需处理，退出处理队列 本题的突破点: 理解队列先进先出的性质 广度优先搜索的性质 先找门，后赋值的思路 ps：block 我的定义是 INF 即可用的房间","text":"问题描述：你被给定一个 m × n 的二维网格 rooms ，网格中有以下三种可能的初始化值：-1 表示墙或是障碍物 0 表示一扇门INF 无限表示一个空的房间。然后，我们用 231 - 1 = 2147483647 代表 INF。你可以认为通往门的距离总是小于 2147483647 的。你要给每个空房间位上填上该房间到 最近门的距离 ，如果无法到达门，则填 INF 即可。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/walls-and-gates著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 建立基本数据以及辅助坐标 先寻找门坐标，将其入队 取出队头元素 A 进行解析 分析 A 上下左右 block 是否可用 合法 A 是否未赋值 将合法的 block 进行赋值（步数） 将新的 block 入队 结束条件当取出的区域 上下左右都已经赋值 ｜｜ 为墙，为门 则无需处理，退出处理队列 本题的突破点: 理解队列先进先出的性质 广度优先搜索的性质 先找门，后赋值的思路 ps：block 我的定义是 INF 即可用的房间 实现难点 如何寻找 block 的上下左右房间 该房间的周围空间是否有用 能否联想到新的 block 就当作是一个新门，再从新门找他的上下左右 block 如何进行数据处理 细节处理 象形理解把每一个门当作一个大的问题小孩（类似孩子王），队列就是记录未解决问题小孩的清单。我们把每一个 INF 区域当作一个医生，安排医生用最小的距离去解决这些问题小孩。我们先在房间里寻找大问题小孩，将他们全部记录在清单上。我们开始分析他周围是否也有问题小孩（孩子王的小跟班）（上下左右检查）如果有（该区域为空）且该问题其他医生没有解决（未赋值）我们就指派该区域的医生去解决这个问题小孩，并且记录该问题小孩离孩子王有多远。（为 block 赋值）如果周围的问题小孩已经有医生解决了，我们就不管。将新的问题小孩记录在队列上，原先的孩子王的下线已经全盘供出，所以他从问题清单上划除。继续解决清单上的新的问题小孩….（可能有点不怎么容易理解。。。。我真的尽力了 源码 yyds ） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Solution &#123; //定义空房间的特征值 private static final int INF = 2147483647; //定义门的特殊值 private static final int DOOR = 0; //定义辅助坐标 以此来表示房间的上下左右 private static final List&lt;int[]&gt; DIRECTIONS = Arrays.asList( new int[]&#123;1, 0&#125;, new int[]&#123;-1, 0&#125;, new int[]&#123;0, -1&#125;, new int[]&#123;0, 1&#125; ); public void wallsAndGates(int[][] rooms) &#123; //记录房间的长宽 int m= rooms.length; int n=rooms[0].length; if(m==0)&#123; return; &#125; //创建队列 Queue&lt;int []&gt; queue=new LinkedList&lt;&gt;(); //遍历rooms 寻找所有的门 for (int row = 0; row &lt; m; row++) &#123; for (int col = 0; col &lt; n; col++) &#123; //当检测到该地区为门的时候 将门的坐标元素入队 if(rooms[row][col]==DOOR)&#123; queue.add(new int[]&#123;row,col&#125;); &#125; &#125; &#125; //核心区域 （当队列不为空的时候，继续执行） while(!queue.isEmpty())&#123; //取出队头的元素 也是最先入队的元素 （ d,c,b,a =&gt; a) int[] block = queue.poll(); //记录原生的行，列数据 int row=block[0]; int col=block[1]; //制造当前block的上下左右block 利用辅助坐标快速制作出新的坐标数据 for (int [] direction: DIRECTIONS) &#123; int r=row+direction[0]; int c=col+direction[1]; //判断新的坐标是否合法 是否存在障碍物 ！！（重点！）是否之前已经被被赋值过！！ //如果已经被赋值 说明当前值就是该区域的最短路径，再次改变就是不准确值 // 因为是广度优先 所以当前值一定是最优值 if(r&lt;0 || c&lt;0 || r&gt;=rooms.length || c&gt;=rooms[0].length || rooms[r][c]!=INF)&#123; continue; &#125; //细节点 需要在前一个block的值上进行+1 否则步数全为1 rooms[r][c]=rooms[row][col]+1; //如果都不是 则为全新的为赋值block 将其加入队列（列尾） queue.add(new int[]&#123;r,c&#125;); &#125; &#125; &#125;&#125;","categories":[{"name":"Problems","slug":"Problems","permalink":"http://oliverxuan.github.io/categories/Problems/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://oliverxuan.github.io/tags/leetcode/"}]},{"title":"循环队列的实现","slug":"循环队列的实现","date":"2021-07-27T17:21:50.000Z","updated":"2021-07-30T15:17:02.169Z","comments":true,"path":"2021/07/28/循环队列的实现/","link":"","permalink":"http://oliverxuan.github.io/2021/07/28/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"问题描述：设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。 循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。 你的实现应该支持如下操作： MyCircularQueue(k): 构造器，设置队列长度为 k 。Front: 从队首获取元素。如果队列为空，返回 -1 。Rear: 获取队尾元素。如果队列为空，返回 -1 。enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。isEmpty(): 检查循环队列是否为空。isFull(): 检查循环队列是否已满。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/design-circular-queue 示例：MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3circularQueue.enQueue(1); // 返回 truecircularQueue.enQueue(2); // 返回 truecircularQueue.enQueue(3); // 返回 truecircularQueue.enQueue(4); // 返回 false，队列已满circularQueue.Rear(); // 返回 3circularQueue.isFull(); // 返回 truecircularQueue.deQueue(); // 返回 truecircularQueue.enQueue(4); // 返回 truecircularQueue.Rear(); // 返回 4 解题思路： 首先要明白循环队列的原理 如何设计循环队列中的两个指针 细节处理","text":"问题描述：设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。 循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。 你的实现应该支持如下操作： MyCircularQueue(k): 构造器，设置队列长度为 k 。Front: 从队首获取元素。如果队列为空，返回 -1 。Rear: 获取队尾元素。如果队列为空，返回 -1 。enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。isEmpty(): 检查循环队列是否为空。isFull(): 检查循环队列是否已满。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/design-circular-queue 示例：MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3circularQueue.enQueue(1); // 返回 truecircularQueue.enQueue(2); // 返回 truecircularQueue.enQueue(3); // 返回 truecircularQueue.enQueue(4); // 返回 false，队列已满circularQueue.Rear(); // 返回 3circularQueue.isFull(); // 返回 truecircularQueue.deQueue(); // 返回 truecircularQueue.enQueue(4); // 返回 truecircularQueue.Rear(); // 返回 4 解题思路： 首先要明白循环队列的原理 如何设计循环队列中的两个指针 细节处理 循环队列原理https://www.bilibili.com/video/BV1yx411e7nb?from=search&amp;seid=13632348157331521482/ 实现难点： 为什么要在 eg：head（head+1）% size 取模？ 为什么 get tail 的时候不能直接返回？ 细节处理 实现代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class MyCircularQueue &#123; //构造原始数组 int[] arr; //数组长度 int size; //头指针，记录循环列表的头部 int head; //尾指针，记录循环列表的尾部 int tail; //计数器，记录总共有多少个元素 int count; //构造器，将原始的数组arr转化为实体，以及一些变量的初始化 public MyCircularQueue(int k) &#123; arr = new int[k]; size = k; head = 0; tail = 0; count = 0; &#125; //入队操作 public boolean enQueue(int value) &#123; //先判断队列是否已满。 if (isFull()) &#123; return false; &#125; arr[tail] = value; //关键点！此处的指针也应该跟着循环，不能说到了数组的size（最大长度）就一直无限延续 //所以这里需要取模运算&quot;%&quot; 例：k=size=7 tail=7 tail=（7+1%7=1 所以下次tail //的位置就在下角标为 1 的位置 从而达到循环指针的目的 后面的head指针同理 tail = (tail + 1) % size; count++; return true; &#125; //出队操作 public boolean deQueue() &#123; //判断是否为空 if (isEmpty()) &#123; return false; &#125; head = (head + 1) % size; count--; return true; &#125; //取头元素 public int Front() &#123; if (isEmpty()) &#123; return -1; &#125; return arr[head]; &#125; public int Rear() &#123; if(isEmpty())&#123; return -1; &#125; //此处需要注意tail的真实位置到底指向的是哪里。 //注意数据的处理不能取负。 return arr[(tail - 1 + size) % size]; &#125; //判断空 public boolean isEmpty() &#123; return count==0; &#125; //判断满 public boolean isFull() &#123; return size==count; &#125;&#125; 总结：在对循环队列实现的时候，注意的细节点有很多，需要做到指针循环才能达到整体的循环目的。总的来说还是难度中等。","categories":[{"name":"Problems","slug":"Problems","permalink":"http://oliverxuan.github.io/categories/Problems/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://oliverxuan.github.io/tags/leetcode/"}]},{"title":"hexo s 时4000端口被占用问题","slug":"hexo-s-时4000端口被占用问题","date":"2021-07-25T14:47:18.000Z","updated":"2021-07-29T17:24:31.003Z","comments":true,"path":"2021/07/25/hexo-s-时4000端口被占用问题/","link":"","permalink":"http://oliverxuan.github.io/2021/07/25/hexo-s-%E6%97%B64000%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98/","excerpt":"问题描述：hexo s 启动的时候遇到了 4000 端口无法创建使用的问题。具体打开 localhost：4000 发现 4000 端口下 hexo 依然在运行！ 解决方案：(mac 环境): sudo lsof -i tcp:4000查询当前端口的进程 报错： 12COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEnode 19087 root 23u IPv6 0xe0d367ae3505eeb3 0t0 TCP *:terabase (LISTEN) 发现进程 19087 sudo kill 19087 再次打开就没有 hexo 的页面了 最后成功在 4000 默认端口下启动 hexo","text":"问题描述：hexo s 启动的时候遇到了 4000 端口无法创建使用的问题。具体打开 localhost：4000 发现 4000 端口下 hexo 依然在运行！ 解决方案：(mac 环境): sudo lsof -i tcp:4000查询当前端口的进程 报错： 12COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEnode 19087 root 23u IPv6 0xe0d367ae3505eeb3 0t0 TCP *:terabase (LISTEN) 发现进程 19087 sudo kill 19087 再次打开就没有 hexo 的页面了 最后成功在 4000 默认端口下启动 hexo","categories":[{"name":"Obstacle","slug":"Obstacle","permalink":"http://oliverxuan.github.io/categories/Obstacle/"}],"tags":[{"name":"技术踩坑","slug":"技术踩坑","permalink":"http://oliverxuan.github.io/tags/%E6%8A%80%E6%9C%AF%E8%B8%A9%E5%9D%91/"}]},{"title":"关于大三一年的计划","slug":"关于大三一年的计划","date":"2021-07-25T14:39:56.000Z","updated":"2021-07-30T15:18:55.613Z","comments":true,"path":"2021/07/25/关于大三一年的计划/","link":"","permalink":"http://oliverxuan.github.io/2021/07/25/%E5%85%B3%E4%BA%8E%E5%A4%A7%E4%B8%89%E4%B8%80%E5%B9%B4%E7%9A%84%E8%AE%A1%E5%88%92/","excerpt":"大三这一年真的是无比关键.想着明年的今天就是我实习的日子.心里多少还是有些焦虑。 回顾自身：大一光顾着玩耍，等到大一暑假的时候突然感觉”玩的索然无味“玩的甚至有点空虚。觉得这不是自己想要的生活。于是放下了我喜欢的游戏。打开了哔哩哔哩，搜起了关于 Java 的教学视频，我还记着我第一次装 Jdk 第一次配置环境变量的时候的一脸懵逼。（这和我学的 C 不一样呀）好奇心促使我继续坚持学习了下去。就这样，我听着尚硅谷的宋红康老师的 Java 课程度过了第一个充实的暑假，也是在那个暑假，我渐渐地明白了，计算机的路，我才刚刚开始。等到了大二，我渐渐尝试着做一些简单的静态页面，跟着做一些简单的 JavaWeb 项目。当我第一次在我自己的数据库接收到前端页面发来的数据的时候，我真的无比激动！这真的是一件很有成就感的事情！到了大二的下学期，在好朋友的指引下，我渐渐接触一些更深层次的东西，我学习了 CoderWhy 老师的 Vue，学完了 Vue 我也深刻体会到组件化开发的便利性。真的佩服我们的尤大佬！能开发出这么好的框架！我什么时候才能到达他这种能力呀！大二这一年，是我学习进步最快的一年，我渐渐明白到了真正的差距到底有多大。所以我想在我大三这一年，有计划有目标地进行学习！争取在一年后的今天能取得互联网大厂的 offer！ 大三规划：大方向：扎实内功，基础。深入底层逻辑，原理。追求技术深度。多总结，多学习。具体目标，步骤: 复习巩固计算机原理，数据结构等计算机基础。（巩固基础） leetcode 坚持每天刷题。（巩固基础） 学习 Node.js 以达到能够做出前后端分离的全栈完整项目。（完善自己的技术面） 学习 uniapp 或 flutter 以达到跨平台，多处运用的目的。（完善自己的技术面） 深入研究 Javascript，Vue 的底层逻辑，以及源码。以达到一定的技术深度。（提高自己技术深度） 多做项目，多参加比赛。提高自己的眼界，技术的多样性，学习别人的优点，改善自己的不足。（提高自己技术深度）","text":"大三这一年真的是无比关键.想着明年的今天就是我实习的日子.心里多少还是有些焦虑。 回顾自身：大一光顾着玩耍，等到大一暑假的时候突然感觉”玩的索然无味“玩的甚至有点空虚。觉得这不是自己想要的生活。于是放下了我喜欢的游戏。打开了哔哩哔哩，搜起了关于 Java 的教学视频，我还记着我第一次装 Jdk 第一次配置环境变量的时候的一脸懵逼。（这和我学的 C 不一样呀）好奇心促使我继续坚持学习了下去。就这样，我听着尚硅谷的宋红康老师的 Java 课程度过了第一个充实的暑假，也是在那个暑假，我渐渐地明白了，计算机的路，我才刚刚开始。等到了大二，我渐渐尝试着做一些简单的静态页面，跟着做一些简单的 JavaWeb 项目。当我第一次在我自己的数据库接收到前端页面发来的数据的时候，我真的无比激动！这真的是一件很有成就感的事情！到了大二的下学期，在好朋友的指引下，我渐渐接触一些更深层次的东西，我学习了 CoderWhy 老师的 Vue，学完了 Vue 我也深刻体会到组件化开发的便利性。真的佩服我们的尤大佬！能开发出这么好的框架！我什么时候才能到达他这种能力呀！大二这一年，是我学习进步最快的一年，我渐渐明白到了真正的差距到底有多大。所以我想在我大三这一年，有计划有目标地进行学习！争取在一年后的今天能取得互联网大厂的 offer！ 大三规划：大方向：扎实内功，基础。深入底层逻辑，原理。追求技术深度。多总结，多学习。具体目标，步骤: 复习巩固计算机原理，数据结构等计算机基础。（巩固基础） leetcode 坚持每天刷题。（巩固基础） 学习 Node.js 以达到能够做出前后端分离的全栈完整项目。（完善自己的技术面） 学习 uniapp 或 flutter 以达到跨平台，多处运用的目的。（完善自己的技术面） 深入研究 Javascript，Vue 的底层逻辑，以及源码。以达到一定的技术深度。（提高自己技术深度） 多做项目，多参加比赛。提高自己的眼界，技术的多样性，学习别人的优点，改善自己的不足。（提高自己技术深度）","categories":[{"name":"CodeLife","slug":"CodeLife","permalink":"http://oliverxuan.github.io/categories/CodeLife/"}],"tags":[{"name":"规划","slug":"规划","permalink":"http://oliverxuan.github.io/tags/%E8%A7%84%E5%88%92/"}]}],"categories":[{"name":"technology","slug":"technology","permalink":"http://oliverxuan.github.io/categories/technology/"},{"name":"Obstacle","slug":"Obstacle","permalink":"http://oliverxuan.github.io/categories/Obstacle/"},{"name":"CodeLife","slug":"CodeLife","permalink":"http://oliverxuan.github.io/categories/CodeLife/"},{"name":"Problems","slug":"Problems","permalink":"http://oliverxuan.github.io/categories/Problems/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://oliverxuan.github.io/tags/node-js/"},{"name":"技术踩坑","slug":"技术踩坑","permalink":"http://oliverxuan.github.io/tags/%E6%8A%80%E6%9C%AF%E8%B8%A9%E5%9D%91/"},{"name":"规划","slug":"规划","permalink":"http://oliverxuan.github.io/tags/%E8%A7%84%E5%88%92/"},{"name":"leetcode","slug":"leetcode","permalink":"http://oliverxuan.github.io/tags/leetcode/"}]}