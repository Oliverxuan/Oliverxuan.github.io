{"meta":{"title":"Oliver-xuan","subtitle":"记录我的程序员生涯","description":"","author":"Oliverxuan","url":"http://oliverxuan.github.io","root":"/"},"pages":[{"title":"分类","date":"2021-07-29T16:58:11.125Z","updated":"2021-07-29T16:58:11.125Z","comments":true,"path":"categories/index.html","permalink":"http://oliverxuan.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-07-29T16:57:59.520Z","updated":"2021-07-29T16:57:59.520Z","comments":true,"path":"tags/index.html","permalink":"http://oliverxuan.github.io/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-07-29T16:58:19.069Z","updated":"2021-07-29T16:58:19.069Z","comments":true,"path":"about/index.html","permalink":"http://oliverxuan.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"axios拦截","slug":"axios拦截","date":"2021-08-30T09:17:04.000Z","updated":"2021-08-30T11:49:56.612Z","comments":true,"path":"2021/08/30/axios拦截/","link":"","permalink":"http://oliverxuan.github.io/2021/08/30/axios%E6%8B%A6%E6%88%AA/","excerpt":"主要功能实现在 axios 每次请求/响应时，对请求/响应进行相关的处理。我们把这种处理方式称之为拦截。 实现方法 request.js 文件的封装 首先我们要将 axios 主要的请求封装在 request.js 文件中，这样我们可以降低代码的耦合度，提高整体的效率，方便后期的维护。12345678910111213141516//将axios插件导入import axios from &quot;axios&quot;;//创建axios方法，并将该方法导出export function request(config) &#123; // 1.创建axios的实例 const instance = axios.create(&#123; baseURL: &quot;*******&quot;, timeout: 5000 &#125;); // 2.设立请求/响应拦截 // 3.发送真正的网络请求 return instance(config);&#125; axios 拦截器 请求拦截 可以在任何的请求上进行修饰，改变。此处我以添加 Authorization：Token 的方法为例： 12345678910111213141516//使用axios的请求拦截方法instance.interceptors.request.use( //对参数进行处理 config =&gt; &#123; //具体操作 if (localStorage.getItem(&quot;Authorization&quot;)) &#123; config.headers.Authorization = localStorage.getItem(&quot;Authorization&quot;); &#125; //最后注意需要返回修饰后的参数 return config; &#125;, error =&gt; &#123; //如果请求是错误的，我们将异常抛出 return Promise.reject(error); &#125; );","text":"主要功能实现在 axios 每次请求/响应时，对请求/响应进行相关的处理。我们把这种处理方式称之为拦截。 实现方法 request.js 文件的封装 首先我们要将 axios 主要的请求封装在 request.js 文件中，这样我们可以降低代码的耦合度，提高整体的效率，方便后期的维护。12345678910111213141516//将axios插件导入import axios from &quot;axios&quot;;//创建axios方法，并将该方法导出export function request(config) &#123; // 1.创建axios的实例 const instance = axios.create(&#123; baseURL: &quot;*******&quot;, timeout: 5000 &#125;); // 2.设立请求/响应拦截 // 3.发送真正的网络请求 return instance(config);&#125; axios 拦截器 请求拦截 可以在任何的请求上进行修饰，改变。此处我以添加 Authorization：Token 的方法为例： 12345678910111213141516//使用axios的请求拦截方法instance.interceptors.request.use( //对参数进行处理 config =&gt; &#123; //具体操作 if (localStorage.getItem(&quot;Authorization&quot;)) &#123; config.headers.Authorization = localStorage.getItem(&quot;Authorization&quot;); &#125; //最后注意需要返回修饰后的参数 return config; &#125;, error =&gt; &#123; //如果请求是错误的，我们将异常抛出 return Promise.reject(error); &#125; ); 响应拦截 1234567891011121314151617181920//axios响应拦截方法instance.interceptors.response.use( res =&gt; &#123; //获取响应参数，并返回 return res.data; &#125;, err =&gt; &#123; //如果返还错误，提取相关的Status响应码，进行错误提示 const &#123; response &#125; = err; if ((response.status = 401)) &#123; localStorage.removeItem(&quot;Authorization&quot;); localStorage.removeItem(&quot;userName&quot;); localStorage.removeItem(&quot;userId&quot;); alert(&quot;请登陆后再使用哦～&quot;); &#125; else &#123; console.log(err); &#125; &#125; ); 后续调用 如需对接后端接口，仅需要创建相关 js 文件，并写入具体请求方法。 user.js 1234567891011121314151617181920212223242526//导入我们之前封装好的request文件import &#123; request &#125; from &quot;./request&quot;;//写具体的对接接口的方法export function GetUser() &#123; return request(&#123; url: &quot;/users/name&quot;, method: &quot;POST&quot; &#125;);&#125;//传参类：//将需要的参数写在方法内export function ChangeUserSkin(flag, type, fix) &#123; return request(&#123; url: &quot;/users/skintest&quot;, method: &quot;POST&quot;, //将所需的数据创建好。 data: &#123; flag: flag, type: type, fix: fix &#125; &#125;);&#125; 总结axios 在日常的 vue 开发中是使用频率很高的组件，用来进行前后端数据交互工作。整体上并不难。需要我们熟练掌握相关的方法，逻辑。其中也需要注意代码的规范，体现封装性。","categories":[{"name":"technology","slug":"technology","permalink":"http://oliverxuan.github.io/categories/technology/"}],"tags":[{"name":"axios","slug":"axios","permalink":"http://oliverxuan.github.io/tags/axios/"}]},{"title":"mmjd项目的完成情况","slug":"mmjd项目的完成情况","date":"2021-08-24T17:24:58.000Z","updated":"2021-08-24T17:43:34.300Z","comments":true,"path":"2021/08/25/mmjd项目的完成情况/","link":"","permalink":"http://oliverxuan.github.io/2021/08/25/mmjd%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%AE%8C%E6%88%90%E6%83%85%E5%86%B5/","excerpt":"项目进度:最近一直在做那个护肤品测评网站，可谓是从无到有，功能也都在慢慢实现。目前已经完成了 90% 剩余的就是 Debug 和样式 接口功能：不多说了，直接上图！ 后端接口： 真的是完完整地做完了整个项目的后端接口。从中真的学会了很多！慢慢也熟悉了 Node.js + Koa 开发接口的开发逻辑。 Mysql： 从中也重新回忆起了很多的 sql 语句（真的好久不用生疏了！）比如：left join ，json_object…. 前端界面：现在的前端界面真的奇丑无比，等着这两天我调好了我们再看！","text":"项目进度:最近一直在做那个护肤品测评网站，可谓是从无到有，功能也都在慢慢实现。目前已经完成了 90% 剩余的就是 Debug 和样式 接口功能：不多说了，直接上图！ 后端接口： 真的是完完整地做完了整个项目的后端接口。从中真的学会了很多！慢慢也熟悉了 Node.js + Koa 开发接口的开发逻辑。 Mysql： 从中也重新回忆起了很多的 sql 语句（真的好久不用生疏了！）比如：left join ，json_object…. 前端界面：现在的前端界面真的奇丑无比，等着这两天我调好了我们再看！ 技术栈： 前端：Html JavaScript CSS Vue Vuex VueRouter axios Webpack node.js Bootstrap 后端：node.js Koa mysql 数据库: mysql 收获：通过这次完完整整地独自开发前后端的项目，很多东西真的就是要亲自来才能深刻体会！希望自己以后能参与或创造更多的项目！ 开源地址: 前端：https://github.com/Oliverxuan/mmjd 后端：https://github.com/Oliverxuan/MMJD-node","categories":[{"name":"CodeLife","slug":"CodeLife","permalink":"http://oliverxuan.github.io/categories/CodeLife/"}],"tags":[{"name":"项目","slug":"项目","permalink":"http://oliverxuan.github.io/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"创建用户并验证合法性","slug":"创建用户并验证合法性","date":"2021-08-15T16:10:04.000Z","updated":"2021-08-15T16:54:39.145Z","comments":true,"path":"2021/08/16/创建用户并验证合法性/","link":"","permalink":"http://oliverxuan.github.io/2021/08/16/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E5%B9%B6%E9%AA%8C%E8%AF%81%E5%90%88%E6%B3%95%E6%80%A7/","excerpt":"主要功能实现一个接口，可以读取用户的输入信息，并检查其合法性。如果其合法，将其录入数据库中，如果不合法，返回其不合法的类型。 实现方法1.创建数据库：1234567CREATE TABLE IF NOT EXISTS `users`(id INT PRIMARY KEY AUTO_INCREMENT,name VARCHAR(30) NOT NULL UNIQUE,password VARCHAR(50) NOT NULL,createAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,updateAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP); 2.连接数据库1.配置数据库信息 将数据库的配置写入 .env 文件中 1234567# mysql配置MYSQL_HOST=xxxxxxMYSQL_PORT=xxxxMYSQL_DATABASE=xxxxxMYSQL_ROOT=xxxxxMYSQL_PASSWORD=xxxxxx 将数据库信息在 config.js 文件中导入","text":"主要功能实现一个接口，可以读取用户的输入信息，并检查其合法性。如果其合法，将其录入数据库中，如果不合法，返回其不合法的类型。 实现方法1.创建数据库：1234567CREATE TABLE IF NOT EXISTS `users`(id INT PRIMARY KEY AUTO_INCREMENT,name VARCHAR(30) NOT NULL UNIQUE,password VARCHAR(50) NOT NULL,createAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,updateAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP); 2.连接数据库1.配置数据库信息 将数据库的配置写入 .env 文件中 1234567# mysql配置MYSQL_HOST=xxxxxxMYSQL_PORT=xxxxMYSQL_DATABASE=xxxxxMYSQL_ROOT=xxxxxMYSQL_PASSWORD=xxxxxx 将数据库信息在 config.js 文件中导入 12345678module.exports = &#123; APP_PORT, MYSQL_HOST, MYSQL_PORT, MYSQL_DATABASE, MYSQL_ROOT, MYSQL_PASSWORD,&#125; = process.env 2.建立数据库连接 在全局文件夹（app）里新建关于数据库操作的 database.js 文件 导入 mysql 插件 1const mysql = require(&#x27;mysql2&#x27;) 将配置信息导入 1const config = require(&#x27;./config&#x27;) 创建数据库连接池,并将相关配置导入 12345678const connections = mysql.createPool(&#123; host: config.MYSQL_HOST, port: config.MYSQL_PORT, database: config.MYSQL_DATABASE, user: config.MYSQL_ROOT, password: config.MYSQL_PASSWORD,&#125;) 取得数据库连接，并设置数据库启动提示 123456789connections.getConnection((err, conn) =&gt; &#123; conn.connect((err) =&gt; &#123; if (err) &#123; console.log(&#x27;数据库连接失败!&#x27;) &#125; else &#123; console.log(&#x27;数据库连接成功！&#x27;) &#125; &#125;)&#125;) 将 connections 导出，从而达到封装。 12//操作都是建立在connections.promise（）上的，所以在导出的时候连带promise()module.exports = connections.promise() 在 main.js 中引入 database.js，从而达到加载目的 12require(&#x27;./app/database&#x27;) 测试连接,得到回应： 3.实现数据库的存入 实现 create 方法 12//查询数据 const result = await service.create(user) 在 service 的 user.service.js 中写入数据库操作 12345678910//操作都是异步的所以要加上async awaitasync create(user) &#123; //从user中获取user，password const &#123; name, password &#125; = user //sql语句 const statement = &#x27;INSERT INTO users (name,password) VALUES (?,?);&#x27; //执行sql语句，并将查询结果返还至result中 const result = await connection.execute(statement, [name, password]) return result[0] &#125; 执行结果 优化过程：验证输入的合法性 创建验证中间件 verifyUser ,并写入 UserRouter 中 1userRouter.post(&#x27;/&#x27;, verifyUser, create) 由于此类型的中间件在后续开发中会频繁创建，故统一在 middleware.js 中创建 12345678910111213141516171819202122232425262728293031323334353637383940// 导入错误类型const errorType = require(&#x27;../constants/error-types&#x27;)// 导入service 利用其中的getUserByName来验证是否已存在该用户const service = require(&#x27;../service/user.service&#x27;)//创建中间件，注意其也是异步操作！const verifyUser = async (ctx, next) =&gt; &#123; //获取用户名，密码 const &#123; name, password &#125; = ctx.request.body //判断不能为空 if (!name || !password) &#123; //如果为空，则新建Error，其错误类型为：NAME_OR_PASSWORD_IS_REQUIRED const error = new Error(errorType.NAME_OR_PASSWORD_IS_REQUIRED) //将错误发射出去 return ctx.app.emit(&#x27;error&#x27;, error, ctx) &#125; //判断本次注册的用户名是否被注册 const result = await service.getUserByNanme(name) //如果返还不为NULL if (result.length) &#123; //新建error 错误类型为：USER_ALREADY_EXISTS const error = new Error(errorType.USER_ALREADY_EXISTS) //将错误发射出去 return ctx.app.emit(&#x27;error&#x27;, error, ctx) &#125; //如果以上都未执行，则进行下一个中间件：create await next()&#125;//导出verifyUsermodule.exports = &#123; verifyUser,&#125; errorType 的创建由于以后的错误类型会有很多，所以统一写入在 errorType 中 1234567const NAME_OR_PASSWORD_IS_REQUIRED = &#x27;name_or_password_is_required&#x27;const USER_ALREADY_EXISTS = &#x27;user_already_exists&#x27;module.exports = &#123; NAME_OR_PASSWORD_IS_REQUIRED, USER_ALREADY_EXISTS,&#125; service 中的 getUserByName 方法 1234567async getUserByNanme(name) &#123; const statement = `SELECT * FROM users WHERE name = ?;` const result = await connection.execute(statement, [name]) return result[0]&#125; 在 index.js 中接收报错信息 12app.on(&#x27;error&#x27;, errorHandler) 创建错误处理 error-handle.js在其中统一处理错误信息 12345678910111213141516171819202122232425262728293031//导入错误类型const errorTypes = require(&#x27;../constants/error-types&#x27;)// 导入之前发射出来的参数error，ctx，并进行分析处理const errorHandler = (error, ctx) =&gt; &#123; //建立状态变量，和报错提示 let status, message //通过传入的错误类型来判断处理方式 switch (error.message) &#123; case errorTypes.NAME_OR_PASSWORD_IS_REQUIRED: status = 400 //Bad request message = &#x27;用户名或者密码为空&#x27; break case errorTypes.USER_ALREADY_EXISTS: console.log(&#x27;1&#x27;) status = 409 //Conflict message = &#x27;用户名已存在&#x27; break default: status = 404 message = &#x27;NOT FOUND&#x27; &#125; //将错误信息导入ctx中 ctx.status = status ctx.body = message&#125;module.exports = errorHandler 错误展示用户已存在：状态码： 用户输入名或密码为空:状态码： 总结经过今天的汇总，逐渐将其中的思路理清楚，为以后开发接口提供了思路。","categories":[{"name":"technology","slug":"technology","permalink":"http://oliverxuan.github.io/categories/technology/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://oliverxuan.github.io/tags/node-js/"}]},{"title":"node.js 用户登陆初体验","slug":"node-js-用户登陆初体验","date":"2021-08-13T16:59:57.000Z","updated":"2021-08-13T17:48:58.913Z","comments":true,"path":"2021/08/14/node-js-用户登陆初体验/","link":"","permalink":"http://oliverxuan.github.io/2021/08/14/node-js-%E7%94%A8%E6%88%B7%E7%99%BB%E9%99%86%E5%88%9D%E4%BD%93%E9%AA%8C/","excerpt":"实现目标写一个接口，实现从用户输入中获得数据 技术点文件夹功能分类 app (app 操作文件夹) index.js (导入所使用的插件，中间件) 12345678910111213141516// 导入所需的插件，中间件const Koa = require(&#x27;koa&#x27;)const bodyParser = require(&#x27;koa-bodyparser&#x27;)const userRouter = require(&#x27;../router/user.router&#x27;)//实例化Koa对象const app = new Koa()//注册/使用插件，中间件app.use(bodyParser())app.use(userRouter.routes())app.use(userRouter.allowedMethods())//导出app 以便其他模块使用module.exports = app config.js (配置操作) 12345678//导入插件const dotenv = require(&#x27;dotenv&#x27;)//使用插件的方法，导入写好的配置文件（.env）dotenv.config()module.exports = &#123; APP_PORT &#125; = process.env main.js (程序的总入口)","text":"实现目标写一个接口，实现从用户输入中获得数据 技术点文件夹功能分类 app (app 操作文件夹) index.js (导入所使用的插件，中间件) 12345678910111213141516// 导入所需的插件，中间件const Koa = require(&#x27;koa&#x27;)const bodyParser = require(&#x27;koa-bodyparser&#x27;)const userRouter = require(&#x27;../router/user.router&#x27;)//实例化Koa对象const app = new Koa()//注册/使用插件，中间件app.use(bodyParser())app.use(userRouter.routes())app.use(userRouter.allowedMethods())//导出app 以便其他模块使用module.exports = app config.js (配置操作) 12345678//导入插件const dotenv = require(&#x27;dotenv&#x27;)//使用插件的方法，导入写好的配置文件（.env）dotenv.config()module.exports = &#123; APP_PORT &#125; = process.env main.js (程序的总入口) 123456789// 导入之前的Koa实例化的对象app。 导入配置文件const app = require(&#x27;./app&#x27;)const config = require(&#x27;./app/config&#x27;)//创建服务器，并利用config的APP_PORT参数app.listen(config.APP_PORT, () =&gt; &#123; console.log(`服务器在$&#123;config.APP_PORT&#125;端口已启动`)&#125;) router (所有的路由管理文件夹) user.router.js (user 的路由管理) 12345678910111213141516// 路由相关的js 注册接口适用//导入koa-router组件const Router = require(&#x27;koa-router&#x27;)//导入方法const &#123; create &#125; = require(&#x27;../controller/user.controller&#x27;)//注册路由 其路径为/usersconst userRouter = new Router(&#123; prefix: &#x27;/users&#x27; &#125;)//设置路由的响应方式，响应方法userRouter.post(&#x27;/&#x27;, create)//导出路由module.exports = userRouter controller (管理不同路径下的不同的情况下的方法，操作) user.controller.js (user 的一些方法，操作) 12345678910111213141516171819//导入写好的方法const service = require(&#x27;../service/user.service&#x27;)//创建类 其中包含了不同情况下的不同方法class UserController &#123; async create(ctx, next) &#123; //获取用户请求的参数 const user = ctx.request.body //查询数据 const result = await service.create(user) //返回数据 ctx.body = result &#125;&#125;module.exports = new UserController() service (业务层，其一般对接着 mysql 数据库操作) user.service.js 1234567891011//创建类class UserService &#123; async create(user) &#123; console.log(&#x27;将用户数据保存到数据库中&#x27;, user) //将user存储到数据库中 return &#x27;创建用户成功&#x27; &#125;&#125;module.exports = new UserService() utils (工具类) .env (配置文件) 123# 服务器端口号APP_PORT=8000 实现结果 总结本次实现了一个小功能，主要目的是想让自己理清楚这个文件与文件之间的关系，以及不同的文件之间的分工。","categories":[{"name":"technology","slug":"technology","permalink":"http://oliverxuan.github.io/categories/technology/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://oliverxuan.github.io/tags/node-js/"}]},{"title":"Better-scroll 中无法滚动问题","slug":"Better-scroll-中无法滚动问题","date":"2021-08-11T06:25:44.000Z","updated":"2021-08-11T06:50:36.367Z","comments":true,"path":"2021/08/11/Better-scroll-中无法滚动问题/","link":"","permalink":"http://oliverxuan.github.io/2021/08/11/Better-scroll-%E4%B8%AD%E6%97%A0%E6%B3%95%E6%BB%9A%E5%8A%A8%E9%97%AE%E9%A2%98/","excerpt":"问题描述在昨天我在使用 Vue 开发前端页面的时候，我遇到了在使用 better-scroll 实现页面滚动的时候无法滚动经过排查，问题出在与 better-scroll 的滚动原理与实际高度之间产生矛盾（图片异步加载问题） 问题分析在之前的 GoodsList 组件中，有一个加载接口图片的操作 12345678910&lt;template&gt; &lt;div class=&quot;goods-item&quot;&gt; &lt;img :src=&quot;goodsItem.img&quot; alt=&quot;&quot; /&gt; &lt;div class=&quot;goods-info&quot;&gt; &lt;p&gt;&#123;&#123; goodsItem.name &#125;&#125;&lt;/p&gt; &lt;span class=&quot;price&quot;&gt;RMB:&#123;&#123; goodsItem.price &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 由于 better-scroll 在计算 wrapper content 高度的时候是在一开始就会计算好 从而达到滚动的目的 但是 Goods list 会加载网路图片，存在一个异步问题加载完后，实际的高度会远超于之前 better-scroll 计算的高度 从而导致 better-scroll 之间计算无效了，最终无法滚动 解决方法123456789&lt;template&gt; &lt;div class=&quot;goods-item&quot;&gt; &lt;img :src=&quot;goodsItem.img&quot; alt=&quot;&quot; @load=&quot;imageload&quot; /&gt; &lt;div class=&quot;goods-info&quot;&gt; &lt;p&gt;&#123;&#123; goodsItem.name &#125;&#125;&lt;/p&gt; &lt;span class=&quot;price&quot;&gt;RMB:&#123;&#123; goodsItem.price &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;","text":"问题描述在昨天我在使用 Vue 开发前端页面的时候，我遇到了在使用 better-scroll 实现页面滚动的时候无法滚动经过排查，问题出在与 better-scroll 的滚动原理与实际高度之间产生矛盾（图片异步加载问题） 问题分析在之前的 GoodsList 组件中，有一个加载接口图片的操作 12345678910&lt;template&gt; &lt;div class=&quot;goods-item&quot;&gt; &lt;img :src=&quot;goodsItem.img&quot; alt=&quot;&quot; /&gt; &lt;div class=&quot;goods-info&quot;&gt; &lt;p&gt;&#123;&#123; goodsItem.name &#125;&#125;&lt;/p&gt; &lt;span class=&quot;price&quot;&gt;RMB:&#123;&#123; goodsItem.price &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 由于 better-scroll 在计算 wrapper content 高度的时候是在一开始就会计算好 从而达到滚动的目的 但是 Goods list 会加载网路图片，存在一个异步问题加载完后，实际的高度会远超于之前 better-scroll 计算的高度 从而导致 better-scroll 之间计算无效了，最终无法滚动 解决方法123456789&lt;template&gt; &lt;div class=&quot;goods-item&quot;&gt; &lt;img :src=&quot;goodsItem.img&quot; alt=&quot;&quot; @load=&quot;imageload&quot; /&gt; &lt;div class=&quot;goods-info&quot;&gt; &lt;p&gt;&#123;&#123; goodsItem.name &#125;&#125;&lt;/p&gt; &lt;span class=&quot;price&quot;&gt;RMB:&#123;&#123; goodsItem.price &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 在原代码 “&lt; img &gt;”标签处新增 @load=”imageload“ 监听事件 12345methods: &#123; imageload() &#123; this.$bus.$emit(&quot;itemImageLoad&quot;); &#125; &#125; 随后在方法里将此事件发射到事件总线里面 注意，需要在 main.js 里注册 事件总线 12345678910111213import Vue from &quot;vue&quot;;import App from &quot;./App.vue&quot;;import router from &quot;./router&quot;;import store from &quot;./store&quot;;Vue.config.productionTip = false;Vue.prototype.$bus = new Vue();new Vue(&#123; router, store, render: h =&gt; h(App)&#125;).$mount(&quot;#app&quot;); 将事件传入事件总线后 需要在 better-scroll 滚动页面里面监听事件 12345mounted() &#123; this.$bus.$on(&quot;itemImageLoad&quot;, () =&gt; &#123; this.$refs.scroll.scroll.refresh(); &#125;); &#125;, 提前设置 better-scroll 中的 refs 从而方便操作 最后监听到图片加载后 调用 scroll 的 refresh（）函数达到重新计算高度的目的 性能优化由于之前的频繁发出事件 image load 导致 实际上会 refresh 很多次 此处就需要 dbounce 防抖函数来处理 ： 12345678910function debounce(fn,delay)&#123; var handle; return function()&#123; clearTimeout(handle) handle=setTimeout(function()&#123; fn() &#125;,delay) &#125; &#125; 从而达到性能优化的目的","categories":[{"name":"Obstacle","slug":"Obstacle","permalink":"http://oliverxuan.github.io/categories/Obstacle/"}],"tags":[{"name":"技术踩坑","slug":"技术踩坑","permalink":"http://oliverxuan.github.io/tags/%E6%8A%80%E6%9C%AF%E8%B8%A9%E5%9D%91/"}]},{"title":"Hello,好久不见","slug":"Hello-好久不见","date":"2021-08-11T06:04:48.000Z","updated":"2021-08-11T06:25:13.431Z","comments":true,"path":"2021/08/11/Hello-好久不见/","link":"","permalink":"http://oliverxuan.github.io/2021/08/11/Hello-%E5%A5%BD%E4%B9%85%E4%B8%8D%E8%A7%81/","excerpt":"最近都去干什么了？距离上次更新我的博客已经过去了 10 多天了，在这段时间里我开始新的征程 =&gt; 准备 9 月份的 辽宁省大学生移动开发大赛 我计划着开发一个护肤品测评网站，整个网站的架构为：前端：Vue 全家桶，axios 后端：Node.js，express 数据库：Mysql 期间遇到的问题困难由于我之前没有涉及过后端的接口开发，所以我在这 10 天的时间里自学了一点 Node.js 的开发基础。顺便学习了 Express，Koa 框架的基本开发。 到目前为止，我已成功地将写好的使用 Express 的 Js 程序用 Node.js 部署在我的云服务器上。 在这其中我遇到了很多的困难，例如： 在服务器上部署合适的 Node &amp; Mysql 如何在本地通过 ssh 连接远端服务器","text":"最近都去干什么了？距离上次更新我的博客已经过去了 10 多天了，在这段时间里我开始新的征程 =&gt; 准备 9 月份的 辽宁省大学生移动开发大赛 我计划着开发一个护肤品测评网站，整个网站的架构为：前端：Vue 全家桶，axios 后端：Node.js，express 数据库：Mysql 期间遇到的问题困难由于我之前没有涉及过后端的接口开发，所以我在这 10 天的时间里自学了一点 Node.js 的开发基础。顺便学习了 Express，Koa 框架的基本开发。 到目前为止，我已成功地将写好的使用 Express 的 Js 程序用 Node.js 部署在我的云服务器上。 在这其中我遇到了很多的困难，例如： 在服务器上部署合适的 Node &amp; Mysql 如何在本地通过 ssh 连接远端服务器 ssh root@ip 如何在 vs code navicat-mysql ssh 连接远端数据 vs code 通过远程资源管理器 mysql 里设置可远端读写权限 navicat 在建立连接时正确写入服务器中的数据库信息 注意需要在服务器安全组里开放相应的端口 建立数据库，在 Vue 里通过 axios 连接远端数据库 处理接口数据 如何在服务器上一直运行 Node 项目 npm2 管理插件 在此感谢前辈们在遇到困难时留下的宝贵经验，以至于我在后续开发时遇到问题都能及时解决","categories":[{"name":"CodeLife","slug":"CodeLife","permalink":"http://oliverxuan.github.io/categories/CodeLife/"}],"tags":[{"name":"规划","slug":"规划","permalink":"http://oliverxuan.github.io/tags/%E8%A7%84%E5%88%92/"}]},{"title":"岛屿问题的实现","slug":"岛屿问题的实现","date":"2021-07-31T06:42:14.000Z","updated":"2021-07-31T06:51:19.367Z","comments":true,"path":"2021/07/31/岛屿问题的实现/","link":"","permalink":"http://oliverxuan.github.io/2021/07/31/%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"问题描述给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/number-of-islands著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解决方案此问题与上一期的门墙算法的实现的思想基本一致，属于利用队列，以及广度优先搜索（dfs）的方式解决问题。但是并不是完全的相同。本问题需要注意在于广度优先搜索的时候，需要有“感染”的思想。 首先遍历整个二维数组，寻找数组中的岛 再在孤岛的基础上 遍历他的上下左右临格元素 是否也为“1”岛屿 如果是 将它感染。 1234567891011121314151617181920212223242526272829public class Solution &#123; public int numIslands(char[][] grid) &#123; if(grid.length==0)&#123; return 0; &#125; int count=0; for (int i = 0; i &lt; grid.length; i++) &#123; for (int j = 0; j &lt; grid[0].length; j++) &#123; if(grid[i][j]==&#x27;1&#x27;)&#123; count++; dfs(grid,i,j); &#125; &#125; &#125; return count; &#125; private void dfs(char[][] grid, int i, int j) &#123; if(i&lt;0 || i&gt;= grid.length || j&lt;0 || j&gt;=grid[0].length || grid[i][j]==&#x27;0&#x27;)&#123; return; &#125; grid[i][j]=&#x27;0&#x27;; dfs(grid, i - 1, j); dfs(grid, i + 1, j); dfs(grid, i, j + 1); dfs(grid, i, j - 1); &#125;&#125;","text":"问题描述给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/number-of-islands著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解决方案此问题与上一期的门墙算法的实现的思想基本一致，属于利用队列，以及广度优先搜索（dfs）的方式解决问题。但是并不是完全的相同。本问题需要注意在于广度优先搜索的时候，需要有“感染”的思想。 首先遍历整个二维数组，寻找数组中的岛 再在孤岛的基础上 遍历他的上下左右临格元素 是否也为“1”岛屿 如果是 将它感染。 1234567891011121314151617181920212223242526272829public class Solution &#123; public int numIslands(char[][] grid) &#123; if(grid.length==0)&#123; return 0; &#125; int count=0; for (int i = 0; i &lt; grid.length; i++) &#123; for (int j = 0; j &lt; grid[0].length; j++) &#123; if(grid[i][j]==&#x27;1&#x27;)&#123; count++; dfs(grid,i,j); &#125; &#125; &#125; return count; &#125; private void dfs(char[][] grid, int i, int j) &#123; if(i&lt;0 || i&gt;= grid.length || j&lt;0 || j&gt;=grid[0].length || grid[i][j]==&#x27;0&#x27;)&#123; return; &#125; grid[i][j]=&#x27;0&#x27;; dfs(grid, i - 1, j); dfs(grid, i + 1, j); dfs(grid, i, j + 1); dfs(grid, i, j - 1); &#125;&#125;","categories":[{"name":"Problems","slug":"Problems","permalink":"http://oliverxuan.github.io/categories/Problems/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://oliverxuan.github.io/tags/leetcode/"}]},{"title":"门与墙算法的实现","slug":"门与墙算法的实现","date":"2021-07-29T14:50:18.000Z","updated":"2021-07-30T15:16:58.408Z","comments":true,"path":"2021/07/29/门与墙算法的实现/","link":"","permalink":"http://oliverxuan.github.io/2021/07/29/%E9%97%A8%E4%B8%8E%E5%A2%99%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"问题描述：你被给定一个 m × n 的二维网格 rooms ，网格中有以下三种可能的初始化值：-1 表示墙或是障碍物 0 表示一扇门INF 无限表示一个空的房间。然后，我们用 231 - 1 = 2147483647 代表 INF。你可以认为通往门的距离总是小于 2147483647 的。你要给每个空房间位上填上该房间到 最近门的距离 ，如果无法到达门，则填 INF 即可。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/walls-and-gates著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 建立基本数据以及辅助坐标 先寻找门坐标，将其入队 取出队头元素 A 进行解析 分析 A 上下左右 block 是否可用 合法 A 是否未赋值 将合法的 block 进行赋值（步数） 将新的 block 入队 结束条件当取出的区域 上下左右都已经赋值 ｜｜ 为墙，为门 则无需处理，退出处理队列 本题的突破点: 理解队列先进先出的性质 广度优先搜索的性质 先找门，后赋值的思路 ps：block 我的定义是 INF 即可用的房间","text":"问题描述：你被给定一个 m × n 的二维网格 rooms ，网格中有以下三种可能的初始化值：-1 表示墙或是障碍物 0 表示一扇门INF 无限表示一个空的房间。然后，我们用 231 - 1 = 2147483647 代表 INF。你可以认为通往门的距离总是小于 2147483647 的。你要给每个空房间位上填上该房间到 最近门的距离 ，如果无法到达门，则填 INF 即可。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/walls-and-gates著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 建立基本数据以及辅助坐标 先寻找门坐标，将其入队 取出队头元素 A 进行解析 分析 A 上下左右 block 是否可用 合法 A 是否未赋值 将合法的 block 进行赋值（步数） 将新的 block 入队 结束条件当取出的区域 上下左右都已经赋值 ｜｜ 为墙，为门 则无需处理，退出处理队列 本题的突破点: 理解队列先进先出的性质 广度优先搜索的性质 先找门，后赋值的思路 ps：block 我的定义是 INF 即可用的房间 实现难点 如何寻找 block 的上下左右房间 该房间的周围空间是否有用 能否联想到新的 block 就当作是一个新门，再从新门找他的上下左右 block 如何进行数据处理 细节处理 象形理解把每一个门当作一个大的问题小孩（类似孩子王），队列就是记录未解决问题小孩的清单。我们把每一个 INF 区域当作一个医生，安排医生用最小的距离去解决这些问题小孩。我们先在房间里寻找大问题小孩，将他们全部记录在清单上。我们开始分析他周围是否也有问题小孩（孩子王的小跟班）（上下左右检查）如果有（该区域为空）且该问题其他医生没有解决（未赋值）我们就指派该区域的医生去解决这个问题小孩，并且记录该问题小孩离孩子王有多远。（为 block 赋值）如果周围的问题小孩已经有医生解决了，我们就不管。将新的问题小孩记录在队列上，原先的孩子王的下线已经全盘供出，所以他从问题清单上划除。继续解决清单上的新的问题小孩….（可能有点不怎么容易理解。。。。我真的尽力了 源码 yyds ） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Solution &#123; //定义空房间的特征值 private static final int INF = 2147483647; //定义门的特殊值 private static final int DOOR = 0; //定义辅助坐标 以此来表示房间的上下左右 private static final List&lt;int[]&gt; DIRECTIONS = Arrays.asList( new int[]&#123;1, 0&#125;, new int[]&#123;-1, 0&#125;, new int[]&#123;0, -1&#125;, new int[]&#123;0, 1&#125; ); public void wallsAndGates(int[][] rooms) &#123; //记录房间的长宽 int m= rooms.length; int n=rooms[0].length; if(m==0)&#123; return; &#125; //创建队列 Queue&lt;int []&gt; queue=new LinkedList&lt;&gt;(); //遍历rooms 寻找所有的门 for (int row = 0; row &lt; m; row++) &#123; for (int col = 0; col &lt; n; col++) &#123; //当检测到该地区为门的时候 将门的坐标元素入队 if(rooms[row][col]==DOOR)&#123; queue.add(new int[]&#123;row,col&#125;); &#125; &#125; &#125; //核心区域 （当队列不为空的时候，继续执行） while(!queue.isEmpty())&#123; //取出队头的元素 也是最先入队的元素 （ d,c,b,a =&gt; a) int[] block = queue.poll(); //记录原生的行，列数据 int row=block[0]; int col=block[1]; //制造当前block的上下左右block 利用辅助坐标快速制作出新的坐标数据 for (int [] direction: DIRECTIONS) &#123; int r=row+direction[0]; int c=col+direction[1]; //判断新的坐标是否合法 是否存在障碍物 ！！（重点！）是否之前已经被被赋值过！！ //如果已经被赋值 说明当前值就是该区域的最短路径，再次改变就是不准确值 // 因为是广度优先 所以当前值一定是最优值 if(r&lt;0 || c&lt;0 || r&gt;=rooms.length || c&gt;=rooms[0].length || rooms[r][c]!=INF)&#123; continue; &#125; //细节点 需要在前一个block的值上进行+1 否则步数全为1 rooms[r][c]=rooms[row][col]+1; //如果都不是 则为全新的为赋值block 将其加入队列（列尾） queue.add(new int[]&#123;r,c&#125;); &#125; &#125; &#125;&#125;","categories":[{"name":"Problems","slug":"Problems","permalink":"http://oliverxuan.github.io/categories/Problems/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://oliverxuan.github.io/tags/leetcode/"}]},{"title":"循环队列的实现","slug":"循环队列的实现","date":"2021-07-27T17:21:50.000Z","updated":"2021-07-30T15:17:02.169Z","comments":true,"path":"2021/07/28/循环队列的实现/","link":"","permalink":"http://oliverxuan.github.io/2021/07/28/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"问题描述：设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。 循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。 你的实现应该支持如下操作： MyCircularQueue(k): 构造器，设置队列长度为 k 。Front: 从队首获取元素。如果队列为空，返回 -1 。Rear: 获取队尾元素。如果队列为空，返回 -1 。enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。isEmpty(): 检查循环队列是否为空。isFull(): 检查循环队列是否已满。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/design-circular-queue 示例：MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3circularQueue.enQueue(1); // 返回 truecircularQueue.enQueue(2); // 返回 truecircularQueue.enQueue(3); // 返回 truecircularQueue.enQueue(4); // 返回 false，队列已满circularQueue.Rear(); // 返回 3circularQueue.isFull(); // 返回 truecircularQueue.deQueue(); // 返回 truecircularQueue.enQueue(4); // 返回 truecircularQueue.Rear(); // 返回 4 解题思路： 首先要明白循环队列的原理 如何设计循环队列中的两个指针 细节处理","text":"问题描述：设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。 循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。 你的实现应该支持如下操作： MyCircularQueue(k): 构造器，设置队列长度为 k 。Front: 从队首获取元素。如果队列为空，返回 -1 。Rear: 获取队尾元素。如果队列为空，返回 -1 。enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。isEmpty(): 检查循环队列是否为空。isFull(): 检查循环队列是否已满。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/design-circular-queue 示例：MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3circularQueue.enQueue(1); // 返回 truecircularQueue.enQueue(2); // 返回 truecircularQueue.enQueue(3); // 返回 truecircularQueue.enQueue(4); // 返回 false，队列已满circularQueue.Rear(); // 返回 3circularQueue.isFull(); // 返回 truecircularQueue.deQueue(); // 返回 truecircularQueue.enQueue(4); // 返回 truecircularQueue.Rear(); // 返回 4 解题思路： 首先要明白循环队列的原理 如何设计循环队列中的两个指针 细节处理 循环队列原理https://www.bilibili.com/video/BV1yx411e7nb?from=search&amp;seid=13632348157331521482/ 实现难点： 为什么要在 eg：head（head+1）% size 取模？ 为什么 get tail 的时候不能直接返回？ 细节处理 实现代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class MyCircularQueue &#123; //构造原始数组 int[] arr; //数组长度 int size; //头指针，记录循环列表的头部 int head; //尾指针，记录循环列表的尾部 int tail; //计数器，记录总共有多少个元素 int count; //构造器，将原始的数组arr转化为实体，以及一些变量的初始化 public MyCircularQueue(int k) &#123; arr = new int[k]; size = k; head = 0; tail = 0; count = 0; &#125; //入队操作 public boolean enQueue(int value) &#123; //先判断队列是否已满。 if (isFull()) &#123; return false; &#125; arr[tail] = value; //关键点！此处的指针也应该跟着循环，不能说到了数组的size（最大长度）就一直无限延续 //所以这里需要取模运算&quot;%&quot; 例：k=size=7 tail=7 tail=（7+1%7=1 所以下次tail //的位置就在下角标为 1 的位置 从而达到循环指针的目的 后面的head指针同理 tail = (tail + 1) % size; count++; return true; &#125; //出队操作 public boolean deQueue() &#123; //判断是否为空 if (isEmpty()) &#123; return false; &#125; head = (head + 1) % size; count--; return true; &#125; //取头元素 public int Front() &#123; if (isEmpty()) &#123; return -1; &#125; return arr[head]; &#125; public int Rear() &#123; if(isEmpty())&#123; return -1; &#125; //此处需要注意tail的真实位置到底指向的是哪里。 //注意数据的处理不能取负。 return arr[(tail - 1 + size) % size]; &#125; //判断空 public boolean isEmpty() &#123; return count==0; &#125; //判断满 public boolean isFull() &#123; return size==count; &#125;&#125; 总结：在对循环队列实现的时候，注意的细节点有很多，需要做到指针循环才能达到整体的循环目的。总的来说还是难度中等。","categories":[{"name":"Problems","slug":"Problems","permalink":"http://oliverxuan.github.io/categories/Problems/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://oliverxuan.github.io/tags/leetcode/"}]},{"title":"hexo s 时4000端口被占用问题","slug":"hexo-s-时4000端口被占用问题","date":"2021-07-25T14:47:18.000Z","updated":"2021-07-29T17:24:31.003Z","comments":true,"path":"2021/07/25/hexo-s-时4000端口被占用问题/","link":"","permalink":"http://oliverxuan.github.io/2021/07/25/hexo-s-%E6%97%B64000%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98/","excerpt":"问题描述：hexo s 启动的时候遇到了 4000 端口无法创建使用的问题。具体打开 localhost：4000 发现 4000 端口下 hexo 依然在运行！ 解决方案：(mac 环境): sudo lsof -i tcp:4000查询当前端口的进程 报错： 12COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEnode 19087 root 23u IPv6 0xe0d367ae3505eeb3 0t0 TCP *:terabase (LISTEN) 发现进程 19087 sudo kill 19087 再次打开就没有 hexo 的页面了 最后成功在 4000 默认端口下启动 hexo","text":"问题描述：hexo s 启动的时候遇到了 4000 端口无法创建使用的问题。具体打开 localhost：4000 发现 4000 端口下 hexo 依然在运行！ 解决方案：(mac 环境): sudo lsof -i tcp:4000查询当前端口的进程 报错： 12COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEnode 19087 root 23u IPv6 0xe0d367ae3505eeb3 0t0 TCP *:terabase (LISTEN) 发现进程 19087 sudo kill 19087 再次打开就没有 hexo 的页面了 最后成功在 4000 默认端口下启动 hexo","categories":[{"name":"Obstacle","slug":"Obstacle","permalink":"http://oliverxuan.github.io/categories/Obstacle/"}],"tags":[{"name":"技术踩坑","slug":"技术踩坑","permalink":"http://oliverxuan.github.io/tags/%E6%8A%80%E6%9C%AF%E8%B8%A9%E5%9D%91/"}]},{"title":"关于大三一年的计划","slug":"关于大三一年的计划","date":"2021-07-25T14:39:56.000Z","updated":"2021-07-30T15:18:55.613Z","comments":true,"path":"2021/07/25/关于大三一年的计划/","link":"","permalink":"http://oliverxuan.github.io/2021/07/25/%E5%85%B3%E4%BA%8E%E5%A4%A7%E4%B8%89%E4%B8%80%E5%B9%B4%E7%9A%84%E8%AE%A1%E5%88%92/","excerpt":"大三这一年真的是无比关键.想着明年的今天就是我实习的日子.心里多少还是有些焦虑。 回顾自身：大一光顾着玩耍，等到大一暑假的时候突然感觉”玩的索然无味“玩的甚至有点空虚。觉得这不是自己想要的生活。于是放下了我喜欢的游戏。打开了哔哩哔哩，搜起了关于 Java 的教学视频，我还记着我第一次装 Jdk 第一次配置环境变量的时候的一脸懵逼。（这和我学的 C 不一样呀）好奇心促使我继续坚持学习了下去。就这样，我听着尚硅谷的宋红康老师的 Java 课程度过了第一个充实的暑假，也是在那个暑假，我渐渐地明白了，计算机的路，我才刚刚开始。等到了大二，我渐渐尝试着做一些简单的静态页面，跟着做一些简单的 JavaWeb 项目。当我第一次在我自己的数据库接收到前端页面发来的数据的时候，我真的无比激动！这真的是一件很有成就感的事情！到了大二的下学期，在好朋友的指引下，我渐渐接触一些更深层次的东西，我学习了 CoderWhy 老师的 Vue，学完了 Vue 我也深刻体会到组件化开发的便利性。真的佩服我们的尤大佬！能开发出这么好的框架！我什么时候才能到达他这种能力呀！大二这一年，是我学习进步最快的一年，我渐渐明白到了真正的差距到底有多大。所以我想在我大三这一年，有计划有目标地进行学习！争取在一年后的今天能取得互联网大厂的 offer！ 大三规划：大方向：扎实内功，基础。深入底层逻辑，原理。追求技术深度。多总结，多学习。具体目标，步骤: 复习巩固计算机原理，数据结构等计算机基础。（巩固基础） leetcode 坚持每天刷题。（巩固基础） 学习 Node.js 以达到能够做出前后端分离的全栈完整项目。（完善自己的技术面） 学习 uniapp 或 flutter 以达到跨平台，多处运用的目的。（完善自己的技术面） 深入研究 Javascript，Vue 的底层逻辑，以及源码。以达到一定的技术深度。（提高自己技术深度） 多做项目，多参加比赛。提高自己的眼界，技术的多样性，学习别人的优点，改善自己的不足。（提高自己技术深度）","text":"大三这一年真的是无比关键.想着明年的今天就是我实习的日子.心里多少还是有些焦虑。 回顾自身：大一光顾着玩耍，等到大一暑假的时候突然感觉”玩的索然无味“玩的甚至有点空虚。觉得这不是自己想要的生活。于是放下了我喜欢的游戏。打开了哔哩哔哩，搜起了关于 Java 的教学视频，我还记着我第一次装 Jdk 第一次配置环境变量的时候的一脸懵逼。（这和我学的 C 不一样呀）好奇心促使我继续坚持学习了下去。就这样，我听着尚硅谷的宋红康老师的 Java 课程度过了第一个充实的暑假，也是在那个暑假，我渐渐地明白了，计算机的路，我才刚刚开始。等到了大二，我渐渐尝试着做一些简单的静态页面，跟着做一些简单的 JavaWeb 项目。当我第一次在我自己的数据库接收到前端页面发来的数据的时候，我真的无比激动！这真的是一件很有成就感的事情！到了大二的下学期，在好朋友的指引下，我渐渐接触一些更深层次的东西，我学习了 CoderWhy 老师的 Vue，学完了 Vue 我也深刻体会到组件化开发的便利性。真的佩服我们的尤大佬！能开发出这么好的框架！我什么时候才能到达他这种能力呀！大二这一年，是我学习进步最快的一年，我渐渐明白到了真正的差距到底有多大。所以我想在我大三这一年，有计划有目标地进行学习！争取在一年后的今天能取得互联网大厂的 offer！ 大三规划：大方向：扎实内功，基础。深入底层逻辑，原理。追求技术深度。多总结，多学习。具体目标，步骤: 复习巩固计算机原理，数据结构等计算机基础。（巩固基础） leetcode 坚持每天刷题。（巩固基础） 学习 Node.js 以达到能够做出前后端分离的全栈完整项目。（完善自己的技术面） 学习 uniapp 或 flutter 以达到跨平台，多处运用的目的。（完善自己的技术面） 深入研究 Javascript，Vue 的底层逻辑，以及源码。以达到一定的技术深度。（提高自己技术深度） 多做项目，多参加比赛。提高自己的眼界，技术的多样性，学习别人的优点，改善自己的不足。（提高自己技术深度）","categories":[{"name":"CodeLife","slug":"CodeLife","permalink":"http://oliverxuan.github.io/categories/CodeLife/"}],"tags":[{"name":"规划","slug":"规划","permalink":"http://oliverxuan.github.io/tags/%E8%A7%84%E5%88%92/"}]}],"categories":[{"name":"technology","slug":"technology","permalink":"http://oliverxuan.github.io/categories/technology/"},{"name":"CodeLife","slug":"CodeLife","permalink":"http://oliverxuan.github.io/categories/CodeLife/"},{"name":"Obstacle","slug":"Obstacle","permalink":"http://oliverxuan.github.io/categories/Obstacle/"},{"name":"Problems","slug":"Problems","permalink":"http://oliverxuan.github.io/categories/Problems/"}],"tags":[{"name":"axios","slug":"axios","permalink":"http://oliverxuan.github.io/tags/axios/"},{"name":"项目","slug":"项目","permalink":"http://oliverxuan.github.io/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"node.js","slug":"node-js","permalink":"http://oliverxuan.github.io/tags/node-js/"},{"name":"技术踩坑","slug":"技术踩坑","permalink":"http://oliverxuan.github.io/tags/%E6%8A%80%E6%9C%AF%E8%B8%A9%E5%9D%91/"},{"name":"规划","slug":"规划","permalink":"http://oliverxuan.github.io/tags/%E8%A7%84%E5%88%92/"},{"name":"leetcode","slug":"leetcode","permalink":"http://oliverxuan.github.io/tags/leetcode/"}]}