{"meta":{"title":"Oliver-xuan","subtitle":"记录我的程序员生涯","description":"","author":"Oliverxuan","url":"http://oliverxuan.github.io","root":"/"},"pages":[{"title":"关于","date":"2021-07-29T16:58:19.069Z","updated":"2021-07-29T16:58:19.069Z","comments":true,"path":"about/index.html","permalink":"http://oliverxuan.github.io/about/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-07-29T16:57:59.520Z","updated":"2021-07-29T16:57:59.520Z","comments":true,"path":"tags/index.html","permalink":"http://oliverxuan.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-07-29T16:58:11.125Z","updated":"2021-07-29T16:58:11.125Z","comments":true,"path":"categories/index.html","permalink":"http://oliverxuan.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Js中的构造函数及原型","slug":"Js中的构造函数及原型","date":"2021-09-22T09:33:31.000Z","updated":"2021-09-22T10:24:51.258Z","comments":true,"path":"2021/09/22/Js中的构造函数及原型/","link":"","permalink":"http://oliverxuan.github.io/2021/09/22/Js%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%8A%E5%8E%9F%E5%9E%8B/","excerpt":"构造函数Js 中的构造函数与 Java 的构造函数思想区别不大，只是需要注意下细节。 1234567891011121314151617181920212223// 规范: 构造函数的首字母一般是大写function Person(name, age, height, address) &#123; this.name = name this.age = age this.height = height this.address = address this.eating = function () &#123; console.log(this.name + &#x27;在吃东西~&#x27;) &#125; this.running = function () &#123; console.log(this.name + &#x27;在跑步&#x27;) &#125;&#125;var p1 = new Person(&#x27;张三&#x27;, 18, 1.88, &#x27;广州市&#x27;)var p2 = new Person(&#x27;李四&#x27;, 20, 1.98, &#x27;北京市&#x27;)console.log(p1)console.log(p2)p1.eating()p2.eating() 构造函数的缺点：容易产生很多的代码冗余，例如这里的 eating，running。 构造函数中的 new如果一个函数被使用 new 操作符调用了，那么它会执行如下操作： 在内存中创建一个新的对象（空对象）； 这个对象内部的[[prototype]]属性会被赋值为该构造函数的 prototype 属性； 构造函数内部的 this，会指向创建出来的新对象； 执行函数的内部代码（函数体代码）； 如果构造函数没有返回非空对象，则返回创建出来的新对象； 对象原型JavaScript 当中每个对象都有一个特殊的内置属性 [[prototype]]，这个特殊的对象可以指向另外一个对象。 我们可以通过 _ proto _ / Object.getPrototypeOf 来查看对象的对象原型","text":"构造函数Js 中的构造函数与 Java 的构造函数思想区别不大，只是需要注意下细节。 1234567891011121314151617181920212223// 规范: 构造函数的首字母一般是大写function Person(name, age, height, address) &#123; this.name = name this.age = age this.height = height this.address = address this.eating = function () &#123; console.log(this.name + &#x27;在吃东西~&#x27;) &#125; this.running = function () &#123; console.log(this.name + &#x27;在跑步&#x27;) &#125;&#125;var p1 = new Person(&#x27;张三&#x27;, 18, 1.88, &#x27;广州市&#x27;)var p2 = new Person(&#x27;李四&#x27;, 20, 1.98, &#x27;北京市&#x27;)console.log(p1)console.log(p2)p1.eating()p2.eating() 构造函数的缺点：容易产生很多的代码冗余，例如这里的 eating，running。 构造函数中的 new如果一个函数被使用 new 操作符调用了，那么它会执行如下操作： 在内存中创建一个新的对象（空对象）； 这个对象内部的[[prototype]]属性会被赋值为该构造函数的 prototype 属性； 构造函数内部的 this，会指向创建出来的新对象； 执行函数的内部代码（函数体代码）； 如果构造函数没有返回非空对象，则返回创建出来的新对象； 对象原型JavaScript 当中每个对象都有一个特殊的内置属性 [[prototype]]，这个特殊的对象可以指向另外一个对象。 我们可以通过 _ proto _ / Object.getPrototypeOf 来查看对象的对象原型 所有的函数都有一个 prototype 属性 12345678910111213function foo() &#123;&#125;// 函数也是一个对象// console.log(foo.__proto__) // 函数作为对象来说, 它也是有[[prototype]] 隐式原型// 函数它因为是一个函数, 所以它还会多出来一个显示原型属性: prototypeconsole.log(foo.prototype)var f1 = new foo()var f2 = new foo()console.log(f1.__proto__ === foo.prototype)console.log(f2.__proto__ === foo.prototype) new 创建新的对象时 在内存中创建一个新的对象（空对象）； 这个对象内部的[[prototype]]属性会被赋值为该构造函数的 prototype 属性； 对象原型的应用12345678910111213141516171819202122232425262728293031function Person(name, age, height, address) &#123; this.name = name this.age = age this.height = height this.address = address&#125;//在上构造函数的方式创建对象时，有一个弊端：会创建出重复的函数，比如running、eating这些函数//所以我们这里使用prototype来给对象原型添加方法，属性Person.prototype.eating = function () &#123; console.log(this.name + &#x27;在吃东西~&#x27;)&#125;Person.prototype.running = function () &#123; console.log(this.name + &#x27;在跑步~&#x27;)&#125;var p1 = new Person(&#x27;OLiver&#x27;, 18, 1.88, &#x27;北京市&#x27;)var p2 = new Person(&#x27;kobe&#x27;, 20, 1.98, &#x27;洛杉矶市&#x27;)p1.eating()p2.eating()Person.prototype.page = &#x27;xuan&#x27;p1.eating() // Oliver在吃东西~p2.eating() // kobe在吃东西~//当当前的p1对象中没有定义page时则会向上查找，此处为Person中的pageconsole.log(p1.page) // xuanp2.page = &#x27;Oliver-xuan&#x27;console.log(p2.page) // Oliver-xuan 总结Js 中的对象原型给我的感觉就像是 JAVA 中的父类，我们在父类中定义一些方法，子类可以继承该方法，属性。 例如此处我们定义了 eating running 两个方法，我们在子类中并没有对其进行一些定义赋值，但是我们可以用 new 出来的对象直接使用。 正是因为 this 的存在，在构造器中的 this 也会以一种隐式绑定的方式，this 绑定到调用的对象上。如 p1.running 这里 running 的 this 就是 p1.","categories":[{"name":"底层逻辑","slug":"底层逻辑","permalink":"http://oliverxuan.github.io/categories/%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://oliverxuan.github.io/tags/JavaScript/"}]},{"title":"浅谈Js面向对象","slug":"浅谈Js面向对象","date":"2021-09-22T07:56:46.000Z","updated":"2021-09-22T09:36:32.953Z","comments":true,"path":"2021/09/22/浅谈Js面向对象/","link":"","permalink":"http://oliverxuan.github.io/2021/09/22/%E6%B5%85%E8%B0%88Js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"万事万物皆对象。这句话是我以前在学习 JAVA 时的感悟。 现实生活中的万事万物，都可以抽象为程序中的对象。比如人：多高，多重，性别，姓名，能吃饭，唱歌。我们都可以把他抽象为代码中的对象，该对象的属性，方法，对应了人的特征，能做什么。 Js 面向对象 JavaScript 其实支持多种编程范式的，包括函数式编程和面向对象编程： JavaScript 中的对象被设计成一组属性的无序集合，像是一个哈希表，有 key 和 value 组成； key 是一个标识符名称，value 可以是任意类型，也可以是其他对象或者函数类型； eg: name:Oliver 如果值是一个函数，那么我们可以称之为是对象的方法； JS 创建对象的方式 通过 new 的方式来创建： 1234567var obj = new Object()obj.name = &#x27;Oliver&#x27;obj.age = 21obj.height = 1.8obj.running = function () &#123; console.log(this.name + &#x27;在跑步~&#x27;)&#125; 字面量形式 12345678var info = &#123; name: &#x27;Oliver&#x27;, age: 20, height: 1.8, eating: function () &#123; console.log(this.name + &#x27;在吃东西~&#x27;) &#125;,&#125;","text":"万事万物皆对象。这句话是我以前在学习 JAVA 时的感悟。 现实生活中的万事万物，都可以抽象为程序中的对象。比如人：多高，多重，性别，姓名，能吃饭，唱歌。我们都可以把他抽象为代码中的对象，该对象的属性，方法，对应了人的特征，能做什么。 Js 面向对象 JavaScript 其实支持多种编程范式的，包括函数式编程和面向对象编程： JavaScript 中的对象被设计成一组属性的无序集合，像是一个哈希表，有 key 和 value 组成； key 是一个标识符名称，value 可以是任意类型，也可以是其他对象或者函数类型； eg: name:Oliver 如果值是一个函数，那么我们可以称之为是对象的方法； JS 创建对象的方式 通过 new 的方式来创建： 1234567var obj = new Object()obj.name = &#x27;Oliver&#x27;obj.age = 21obj.height = 1.8obj.running = function () &#123; console.log(this.name + &#x27;在跑步~&#x27;)&#125; 字面量形式 12345678var info = &#123; name: &#x27;Oliver&#x27;, age: 20, height: 1.8, eating: function () &#123; console.log(this.name + &#x27;在吃东西~&#x27;) &#125;,&#125; Js 属性操作 常规操作 12345678//赋值obj.name = &#x27;Oliver&#x27;//获取console.log(obj.name)//遍历 打印对象中所存在的属性for (var key in obj) &#123; console.log(key)&#125; defineProperty 方法1234567891011121314var obj = &#123; name: &#x27;Oliver&#x27;, age: 21,&#125;// 属性描述符是一个对象Object.defineProperty(obj, &#x27;height&#x27;, &#123; // 很多的配置 value: 1.88,&#125;)console.log(obj) //&#123; name: &#x27;why&#x27;, age: 18 &#125;console.log(obj.height) //1.88 对属性操作的控制以前在 Java 中，我们常常会用到 Private 对一些对象的属性进行限制。那 Js 中是否也存在这种操作呢？ defineProperty 数据属性描述符 Object.defineProperty(obj,prop,descriptor) 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此 可接收三个参数： obj 要定义属性的对象； prop 要定义或修改的属性的名称或 Symbol； descriptor 要定义或修改的属性描述符； 返回值：被传递给函数的对象。 对象。 value 该属性的值； 默认值 undefined ； configurable ** 该属性是否能修改**，配置； 默认值 false enumerable 该属性是否能枚举； 默认值 false writable 该属性是否能赋值，写入； 默认值 false 直接给对象的属性定义的时候，configurable，enumerable，writable 都为 true 12345678910111213var obj = &#123; name: &quot;Oliver&quot;, age: 21&#125;Object.defineProperty(obj, &quot;address&quot;, &#123; value: &quot;四川省&quot; // 默认值undefined // 是否可以配置 该特殊不可删除/也不可以重新定义属性描述符 configurable: false, // 默认值false // 该特殊是配置对应的属性(address)是否是可以枚举，通过log等等方式 enumerable: true, // 默认值false // 该特性是属性是否是可以赋值(写入值) writable: false // 默认值false&#125;) defineProperties()数据属性描述符（多个） Object.defineProperties() 方法直接在一个对象上定义 多个 新的属性或修改现有属性，并且返回该对象。 存储属性描述符 存取属性描述符 隐藏某一个私有属性被希望直接被外界使用和赋值 如果我们希望截获某一个属性它访问和设置值的过程时, 也会使用存储属性描述符 1234567891011121314151617181920212223242526272829303132333435var obj = &#123; name: &#x27;oliver&#x27;, age: 21, //约定俗成，在变量属性前添加 _ “下划线”表示该属性为私有的，不想别人随意改变其中的内容 _address: &#x27;四川省&#x27;,&#125;Object.defineProperty(obj, &#x27;address&#x27;, &#123; enumerable: true, configurable: true, // get方法获取对象中的私有属性 get: function () &#123; foo() return this._address &#125;, //set方法来设置私有属性的值 set: function (value) &#123; bar() this._address = value &#125;,&#125;)console.log(obj.address)obj.address = &#x27;上海市&#x27;console.log(obj.address)function foo() &#123; console.log(&#x27;获取了一次address的值&#x27;)&#125;function bar() &#123; console.log(&#x27;设置了addres的值&#x27;)&#125; 其他方法补充getOwnPropertyDescriptor 可以获取对象的某一属性的属性描述符 12// 获取某一个特性属性的属性描述符console.log(Object.getOwnPropertyDescriptor(obj, &#x27;name&#x27;)) getOwnPropertyDescriptors 12// 获取对象的所有属性描述符console.log(Object.getOwnPropertyDescriptors(obj)) preventExtensions 禁止对象扩展新属性 给一个对象添加新的属性会失败（在严格模式下会报错）； seal 密封对象，不允许配置和删除属性 实际是调用preventExtensions 并且将现有属性的configurable:false freeze 冻结对象，不允许修改现有属性： 实际上是调用seal 并且将现有属性的writable: false 总结Javascript 中的创建对象的思想，其实和 Java 中也算是大同小异，包括一些构造器，Js 中使用 function 来作为构造器的使用。其中的一些私有的方法在 JavaScript 中也有体现。 总的来说 Js 中的对象使用上更灵活，方法也更多。需要勤加使用练习。","categories":[{"name":"底层逻辑","slug":"底层逻辑","permalink":"http://oliverxuan.github.io/categories/%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://oliverxuan.github.io/tags/JavaScript/"}]},{"title":"Js中的严格模式","slug":"Js中的严格模式","date":"2021-09-16T05:10:04.000Z","updated":"2021-09-16T05:45:56.749Z","comments":true,"path":"2021/09/16/Js中的严格模式/","link":"","permalink":"http://oliverxuan.github.io/2021/09/16/Js%E4%B8%AD%E7%9A%84%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/","excerpt":"在 JavaScript 中，我们常常在非严格模式/松散模式下进行编译。Js 会将一些语法的错误保持静默，像是睁一只眼闭一只眼。在严格模式下，这些错误就会被 Js 揪出来。 JS 语法补充with 语句12345678910111213141516var obj = &#123; age: 1, mes: &#x27;like&#x27;,&#125;function foo() &#123; function bar() &#123; //现在obj里找，没有就一直向上找 with (obj) &#123; console.log(mes) &#125; &#125; bar()&#125;foo() 在 with 语句中，我们可以给其指定一个对象，使其中的语句优先查找对象中的相关内容。 如果该对象中没有改属性，则就一直向上查找，直到全局。 并不建议使用 with，其代码可读性差，容易产生混淆错误兼容性问题。 eval 函数eval 是一个特殊的函数，它可以将传入的字符串当做 JavaScript 代码来运行。 123var evalString = `var message = &quot;Hello&quot;;console.log(message);`eval(evalString)console.log(message)","text":"在 JavaScript 中，我们常常在非严格模式/松散模式下进行编译。Js 会将一些语法的错误保持静默，像是睁一只眼闭一只眼。在严格模式下，这些错误就会被 Js 揪出来。 JS 语法补充with 语句12345678910111213141516var obj = &#123; age: 1, mes: &#x27;like&#x27;,&#125;function foo() &#123; function bar() &#123; //现在obj里找，没有就一直向上找 with (obj) &#123; console.log(mes) &#125; &#125; bar()&#125;foo() 在 with 语句中，我们可以给其指定一个对象，使其中的语句优先查找对象中的相关内容。 如果该对象中没有改属性，则就一直向上查找，直到全局。 并不建议使用 with，其代码可读性差，容易产生混淆错误兼容性问题。 eval 函数eval 是一个特殊的函数，它可以将传入的字符串当做 JavaScript 代码来运行。 123var evalString = `var message = &quot;Hello&quot;;console.log(message);`eval(evalString)console.log(message) 十分不建议在实际开发中使用，其容易被劫持，存在很大的安全隐患！ eval 代码的可读性非常的差（代码的可读性是高质量代码的重要原则） eval 是一个字符串，那么有可能在执行的过程中被刻意篡改，那么可能会造成被攻击的风险； eval 的执行必须经过 JS 解释器，不能被 JS 引擎优化 非严格模式静默非严格模式1234567mes = &#x27;123&#x27;function foo() &#123; console.log(mes)&#125;foo() //123//在非严格模式下 此处能打印mes的值 我们并没有用 var 来声明变量，而是直接赋值。这是一种错误的语法，但是在非严格模式下，js 保持静默。 严格模式123456789//开启严格模式&#x27;use strict&#x27;mes = &#x27;123&#x27;function foo() &#123; console.log(mes)&#125;foo() 在严格模式下，js 会严格查找语法中的错误，此处的 mes 会报错，为： mes is not defined 严格模式严格模式概述 在 ECMAScript5 标准中，JavaScript 提出了严格模式的概念（Strict Mode） 严格模式很好理解，是一种具有限制性的 JavaScript 模式，从而使代码隐式的脱离了 ”懒散（sloppy）模式“ 支持严格模式的浏览器在检测到代码中有严格模式时，会以更加严格的方式对代码进行检测和执行 严格模式对正常的 JavaScript 语义进行了一些限制： 严格模式通过 抛出错误 来消除一些原有的 静默（silent）错误 严格模式让 JS 引擎在执行代码时可以进行更多的优化（不需要对一些特殊的语法进行处理） 严格模式禁用了在 ECMAScript 未来版本中可能会定义的一些语法 ​ Text from why：coderwhy 严格模式的开启方式文件开启123456789// 文件开启的方式// &#x27;use strict&#x27;mes = &#x27;123&#x27;function foo() &#123; console.log(mes)&#125;foo() 函数内开启1234567function use() &#123; // //函数内开启严格模式 // &#x27;use strict&#x27; true.foo = &#x27;abc&#x27;&#125;use() 严格模式的限制 无法意外地创建出全局变量。 所有的静默失效，会以异常的方式抛出。 如果试图删除不可删除的属性，将会报错。 不允许函数中传入两个相同的变量名（非严格模式下，x，y，x。接受的为最后一个 x） 不允许使用 0 的八进制语法 不允许使用 with eval 不能再引用上层变量 this 不会转换为默认对象，（而是变成 undefined） 总结js 中的严格模式，在新手使用中，是一种很好的保护方式。可以在严格的语法纠错中，找的自己的问题出在哪里。不为后续的开发留下安全隐患。","categories":[{"name":"底层逻辑","slug":"底层逻辑","permalink":"http://oliverxuan.github.io/categories/%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://oliverxuan.github.io/tags/JavaScript/"}]},{"title":"React 初体验","slug":"React-初体验","date":"2021-09-15T06:44:16.000Z","updated":"2021-09-15T07:08:18.064Z","comments":true,"path":"2021/09/15/React-初体验/","link":"","permalink":"http://oliverxuan.github.io/2021/09/15/React-%E5%88%9D%E4%BD%93%E9%AA%8C/","excerpt":"ReactReact 基本上是高级前端工程师的必备技能，相较于 Vue 也更加灵活。可以说是 Facebook 工程师们智慧的结晶。 在现阶段，学习 React 可以提高自己对前端的理解，扩大及自己的技术广度。为以后开发中大型项目奠基。 初体验完成点击按钮修改文字的操作 创建一个 html 文件 引入 React 相关 CDN 链接 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot; crossorigin &gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot; crossorigin &gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; React 和 Vue 不一样，React 的理念更像是类纯函数。我们从 CDN 也可以看出分别引入了 React 核心文件，React-dom，Babel 转译。每个都各司其职。而 Vue 则是全部打包在一起直接引入。 成功引入相关依赖后，这样我们就可以开始我们的 React 开发了 实现功能","text":"ReactReact 基本上是高级前端工程师的必备技能，相较于 Vue 也更加灵活。可以说是 Facebook 工程师们智慧的结晶。 在现阶段，学习 React 可以提高自己对前端的理解，扩大及自己的技术广度。为以后开发中大型项目奠基。 初体验完成点击按钮修改文字的操作 创建一个 html 文件 引入 React 相关 CDN 链接 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot; crossorigin &gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot; crossorigin &gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; React 和 Vue 不一样，React 的理念更像是类纯函数。我们从 CDN 也可以看出分别引入了 React 核心文件，React-dom，Babel 转译。每个都各司其职。而 Vue 则是全部打包在一起直接引入。 成功引入相关依赖后，这样我们就可以开始我们的 React 开发了 实现功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 需要渲染的地方，通过id来实现挂载 --&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;!-- 导入相关依赖 --&gt; &lt;script src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot; crossorigin &gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot; crossorigin &gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 开始开发 --&gt; &lt;!-- 注意事项：想在script使用jsx 需要添加标签 type=“text/babel” --&gt; &lt;!-- jsx多个组件在根的层面，只能有一个标签，就如同 Vue：div 来包裹--&gt; &lt;script type=&quot;text/babel&quot;&gt; //封装App组件，该App类继承了React.Component class App extends React.Component &#123; //变量放在constructor()中 constructor() &#123; //由于是继承类，需要调用一下super（） super() //动态数据，统一存放在this.state中 this.state = &#123; mes: &#x27;Hello world&#x27;, &#125; &#125; // render（）渲染 render() &#123; return ( //如同Vue一样，需要用唯一的&lt;div&gt;&lt;/div&gt;来包裹内容 &lt;div&gt; // 调用动态数据注意是this.state.的方式 &lt;h2&gt;&#123;this.state.mes&#125;&lt;/h2&gt; //React是声明式编程，这里绑定方法用的是onClick（）=&#123;&#125; 的方式进行的，切需要.bind来给它指定一个this &lt;button onClick=&#123;this.btnCLick.bind(this)&#125;&gt;改变文字&lt;/button&gt; &lt;/div&gt; ) &#125; // 永远不要手动调用render（） // 相关函数 btnCLick() &#123; console.log(this) console.log(&#x27;按钮发生了点击&#x27;) //通过this.setState的方式来修改state里面的内容 this.setState(&#123; mes: &#x27;Hello React&#x27;, &#125;) &#125; &#125; //渲染组件 渲染内容，挂载对象 ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;app&#x27;)) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 总结React 总体上要比 Vue 难很多，但是也带来了灵活的特性。希望通过自己的坚持，能够掌握 React 的开发技术！","categories":[{"name":"技术实现","slug":"技术实现","permalink":"http://oliverxuan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/"}],"tags":[{"name":"React","slug":"React","permalink":"http://oliverxuan.github.io/tags/React/"}]},{"title":"Js纯函数及函数柯里化","slug":"Js纯函数及函数柯里化","date":"2021-09-14T05:04:05.000Z","updated":"2021-09-14T07:36:29.578Z","comments":true,"path":"2021/09/14/Js纯函数及函数柯里化/","link":"","permalink":"http://oliverxuan.github.io/2021/09/14/Js%E7%BA%AF%E5%87%BD%E6%95%B0%E5%8F%8A%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/","excerpt":"在函数式编程中，有一个非常重要的概念：纯函数。 那究竟什么是纯函数呢？ 纯函数纯函数的定义 维基百科： 此函数在相同的输入值时需产生相同的输出。 函数的输出和输入值以外的其他隐藏信息或状态无关，也和I/O 设备产生的外部输出无关。 该函数不能有语义上可观察的函数副作用，诸如“触发事件”，使输出设备输出，或更改输出值以外物件的内容等。 维基百科的解释很严谨，但是未免有些晦涩。 我的理解： 一个函数，有确定的输入，一定会产生确定的输出。 我们在执行函数的时候，不会对外界产生任何的副作用。 副作用副作用：比如改变了函数外的变量，造成全局变量被篡改。 eg：slice 与 splice 的比较","text":"在函数式编程中，有一个非常重要的概念：纯函数。 那究竟什么是纯函数呢？ 纯函数纯函数的定义 维基百科： 此函数在相同的输入值时需产生相同的输出。 函数的输出和输入值以外的其他隐藏信息或状态无关，也和I/O 设备产生的外部输出无关。 该函数不能有语义上可观察的函数副作用，诸如“触发事件”，使输出设备输出，或更改输出值以外物件的内容等。 维基百科的解释很严谨，但是未免有些晦涩。 我的理解： 一个函数，有确定的输入，一定会产生确定的输出。 我们在执行函数的时候，不会对外界产生任何的副作用。 副作用副作用：比如改变了函数外的变量，造成全局变量被篡改。 eg：slice 与 splice 的比较 12345678910111213141516171819var numbers = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;]// slice函数是一个纯函数：// 1. slice只要给它传入一个start/end, 那么对于同一个数组来说, 它会给我们返回确定的值// 2. slice函数本身它是不会修改原来的数组// slice -&gt; this// slice函数本身就是一个纯函数// var new numbers1 = numbers.slice(0, 3)// console.log(numbers1)// console.log( numbers)// splice函数不是一个纯函数：// splice在执行时, 有修改掉调用的数组对象本身, 修改的这个操作就是产生的副作用var numbers2 = numbers.splice(2)console.log(numbers2)console.log(numbers) 纯函数的理解很简单，只需要关注好重点就可以了。 函数的柯里化函数柯里化用我自己的话简单来说：就是把一件事情进行拆分。 可以把这个过程看成造车： 函数柯里化就是自动化的流水线，流水线的工人各司其职共同造一台车。 普通函数则是一个工人去造一台车。 这样函数柯里化的优点就很明显了：当某个环节的工人出现问题的时候，我们可以快速找到该员工，进行批评教育。 但是如果是普通函数，那么我们则需要从一个人的身上慢慢找问题。整个工作也都停了。 函数演示12345678910111213//原函数function Psum(x, y, z) &#123; return x + y + z&#125;//函数柯里化以后function sum(x) &#123; return function (y) &#123; return function (z) &#123; return x + y + z &#125; &#125;&#125; 这么一看貌似柯里化真的就是自找麻烦一样，但是如果这里不是简单的相加操作呢？ 在真实的开发环境里，可能我们这的一个相加操作就是几十行业务代码。如果把它全部放在一个函数里，维护成本，可阅读性真的就太差了。 单一职责123456789101112131415161718192021222324function add(x, y, z) &#123; x = x + 2 y = y * 2 z = z * z return x + y + z&#125;console.log(add(10, 20, 30))function sum(x) &#123; x = x + 2 return function (y) &#123; y = y * 2 return function (z) &#123; z = z * z return x + y + z &#125; &#125;&#125;console.log(sum(10)(20)(30)) 从这段代码中，我们可以看出 在 sum 函数中，每一个函数都是各司其职，专注干好自己的事情。等所有都处理好了。再统一返回。 逻辑复用假如我们需要设计一个函数，实现传入两个参数，第一个为指定基础数字 X，另一个是与 X 相加的数字。 我们很快可以用传统方法写出： 123456789function sum(m, n) &#123; return m + n&#125;// 假如在程序中,我们经常需要把5和另外一个数字进行相加console.log(sum(5, 10))console.log(sum(5, 14))console.log(sum(5, 1100))console.log(sum(5, 555)) 但是未免有点繁琐 所以我们在此引出，函数柯里化，逻辑复用 123456789101112131415//创建一个makeAdder函数function makeAdder(count) &#123; //在此时如果只传入了一个参数，那么我们目前只确定了 return function中的count 但是 //num的值我们还未确定。 return function (num) &#123; return count + num &#125;&#125;//传入count值，创造makeAdder5的函数var adder5 = makeAdder(5)adder5(10)adder5(14)adder5(1100)adder5(555) 从这里开始，我们就可以慢慢体会函数柯里化的好处了！ 手写柯里化函数首先 我们可以从最外层，最浅显的入手 传入一个函数，返回一个函数 12345function myCurrying(fn) &#123; function curried() &#123;&#125; return curried&#125; 接收参数 123456789function myCurrying(fn) &#123; function curried(...args) &#123; //判断args接收的参数是否已经足够 fn.length是函数fn里接受的参数个数 if (args.length &gt;= fn.length) &#123; &#125; &#125; return curried&#125; 情况一： fn（）直调 12345678910function myCurrying(fn) &#123; function curried(...args) &#123; if (args.length &gt;= fn.length) &#123; //在此处如果直接使用fn（）调用，如果之后是使用call的方式调用新函数，则fn可能并不是之前的fn。而是被call指定了其他的this fn(...args) &#125; &#125; return curried&#125; apply /call 调用 12345678910function myCurrying(fn) &#123; function curried(...args) &#123; if (args.length &gt;= fn.length) &#123; //此处直接显示绑定this，该this为curried对象 return fn.apply(this, args) &#125; &#125; return curried&#125; 没有传入足够参数时，执行 else 123456789101112131415161718function myCurrying(fn) &#123; function curried(...args) &#123; if (args.length &gt;= fn.length) &#123; return fn.apply(this, args) &#125; else &#123; //递归思想 curried2接收剩余参数 function curried2(...args2) &#123; //再次调用curried 传入this=&gt;curried 解构拼接两个参数 return curried.apply(this, [...args, ...args2]) &#125; //返回curried2方法 为下次接收参数做准备 return curried2 &#125; &#125; //返回新函数 return curried&#125; 总结通过这次学习，深刻理解了纯函数，函数的柯里化。也自己尝试着实现了函数的柯里化。希望能在后续的开发学习中能及时运用这些方法。","categories":[{"name":"底层逻辑","slug":"底层逻辑","permalink":"http://oliverxuan.github.io/categories/%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://oliverxuan.github.io/tags/JavaScript/"}]},{"title":"Js中call,apply,bind的实现","slug":"Js中call-apply-bind的实现","date":"2021-09-12T08:42:43.000Z","updated":"2021-09-12T13:59:59.845Z","comments":true,"path":"2021/09/12/Js中call-apply-bind的实现/","link":"","permalink":"http://oliverxuan.github.io/2021/09/12/Js%E4%B8%ADcall-apply-bind%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"在 Js 中，我们常常会用到 call，apply，bind。进行一些 this 操作。我们不禁对其产生了好奇。 Js 中，这些方法是通过 C++实现的，那么我们尝试用 Js 来实现一下。 call 将手写的 mycall 方法，绑定在函数原型上。 实现所有函数都可以通过 foo（）.mycall 的方式调用。 12//Function.prototype :函数原型Function.prototype.mycall = function() 拿到调用 mycall（）的对象。 12//不难发现，此处是一个隐式绑定，函数foo（）.mycall。我们可以通过this拿到目标函数var fn = this 目前，我们完成了最基本的通过 mycall 执行函数体的方法。 12345678910Function.prototype.mycall = function () &#123; var fn = this fn()&#125;function foo() &#123; console.log(&#x27;foo函数被调用&#x27;)&#125;foo.mycall() //foo函数被调用","text":"在 Js 中，我们常常会用到 call，apply，bind。进行一些 this 操作。我们不禁对其产生了好奇。 Js 中，这些方法是通过 C++实现的，那么我们尝试用 Js 来实现一下。 call 将手写的 mycall 方法，绑定在函数原型上。 实现所有函数都可以通过 foo（）.mycall 的方式调用。 12//Function.prototype :函数原型Function.prototype.mycall = function() 拿到调用 mycall（）的对象。 12//不难发现，此处是一个隐式绑定，函数foo（）.mycall。我们可以通过this拿到目标函数var fn = this 目前，我们完成了最基本的通过 mycall 执行函数体的方法。 12345678910Function.prototype.mycall = function () &#123; var fn = this fn()&#125;function foo() &#123; console.log(&#x27;foo函数被调用&#x27;)&#125;foo.mycall() //foo函数被调用 实现函数可传入指定的 this 我们知道在 js 的 call（）中，是可以转入指定的对象，用该对象进行函数的调用。 但是也有一些特殊的情况。 undefined，null。传入该值后，实际上 this 是 window。 传入数字，字符串。实际上是 number/String 对象 我们针对这些特性，进行函数优化。 这里使用到： Object（）：_将传入的值变成对象类型_； 三元运算符：_判断是否为特殊情况_。 1234567891011121314151617181920212223//修改函数体，传入指定的Function.prototype.mycall = function (thisArg) &#123; var fn = this //对传入的thisArg进行判断，是否为null，undefined，如果是：window，不是 Object(thisArg)。 thisArg = thisArg !== null &amp;&amp; thisArg !== undefined ? Object(thisArg) : window //保存原this thisArg.fn = fn //执行原函数体，并保存结果 var result = thisArg.fn() //防止作用域污染，及时删除 delete thisArg.fn //返回执行结果 return result&#125;function foo() &#123; console.log(&#x27;foo函数被调用&#x27;) console.log(this)&#125;foo.mycall(&#x27;abc&#x27;) //String&#123;&#x27;abc&#x27;&#125;foo.mycall() //window 实现函数可传入参数 在这里，我们用到了…args （展开运算符），实现可传入未知个数的参数 1234567891011121314151617181920212223242526272829//...args 用于传入未知个数的参数Function.prototype.mycall = function (thisArg, ...args) &#123; var fn = this thisArg = thisArg !== null &amp;&amp; thisArg !== undefined ? Object(thisArg) : window thisArg.fn = fn //将参数传入执行函数中 var result = thisArg.fn(...args) delete thisArg.fn return result&#125;function foo() &#123; console.log(&#x27;foo函数被调用&#x27;) console.log(this)&#125;function sum(num1, num2) &#123; console.log(&#x27;sum函数被执行&#x27;, this, num1, num2) return num1 + num2&#125;var name = &#x27;window&#x27;// foo.call(&#x27;abc&#x27;)// foo.mycall(&#x27;abc&#x27;)// foo.call()// foo.mycall()console.log(sum.mycall(&#123;&#125;, 1, 2)) //sum函数被执行 &#123;fn: ƒ&#125;[[Prototype]]: Object 1 2 3 目前我们己完成了 mycall（）的手写。 apply 基础部分 此部分和 call 基本一致。 123456789Function.prototype.myapply = function (thisArgs) &#123; var fn = this thisArgs = thisArgs !== null &amp;&amp; thisArs !== undefined ? Object(thisArgs) : window thisArgs.fn = fn var result = thisArgs.fn() delete thisArgs.fn return result&#125; apply 传参处理 12345678910111213141516171819//apple传参是数组类型，所以我们这里只需要传入目标数组就行Function.prototype.myapply = function (thisArgs, array) &#123; var fn = this thisArgs = thisArgs !== null &amp;&amp; thisArgs !== undefined ? Object(thisArgs) : window thisArgs.fn = fn //array = array ? array: [] array = array || [] var result = thisArgs.fn(...array) delete thisArgs.fn return result&#125;function sum(num1, num2) &#123; console.log(&#x27;sum函数被执行&#x27;, this, num1, num2) return num1 + num2&#125;console.log(sum.myapply(&#123;&#125;, [1, 2])) //sum函数被执行 &#123;fn: ƒ&#125; 1 2 3 bind 基础部分 基础部分和前文一致 1234Function.prototype.mybind = function (thisArg) &#123; var fn = this thisArg = thisArg !== null &amp;&amp; thisArg !== undefined ? Object(thisArg) : window&#125; 传参处理 由于 bind 的特殊用法，我们可以在 bind（）里传入参数，也可以在新的函数中传入参数，或者都传入参数，所以我们需要特殊处理。 123456789101112131415161718192021222324252627Function.prototype.mybind = function (thisArg, ...myargs) &#123; var fn = this thisArg = thisArg !== null &amp;&amp; thisArg !== undefined ? Object(thisArg) : window //设立一个代理函数 function pxfn(...arg) &#123; thisArg.fn = fn //合并参数 var finalArray = [...myargs, ...arg] //执行函数体 var result = thisArg.fn(...finalArray) delete thisArg.fn //返回执行结果 return result &#125; //返回pxfn函数 return pxfn&#125;function sum(num1, num2, num3, num4) &#123; console.log(num1, num2, num3, num4)&#125;var bar = foo.mybind(&#x27;123&#x27;)bar() //foo被执行 String &#123;&#x27;123&#x27;, fn: ƒ&#125;var bar2 = sum.mybind(&#x27;1234&#x27;, 1, 2, 3, 4)bar2() //1 2 3 4 总结通过这次手写 Js 中的一些重要方法，我理解到 this 在实际开发的重要性，也学会了，如何处理数据，以及一些边界情况的处理。总的来说，这是一次很好的学习经验。","categories":[{"name":"底层逻辑","slug":"底层逻辑","permalink":"http://oliverxuan.github.io/categories/%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://oliverxuan.github.io/tags/JavaScript/"}]},{"title":"Js中的this练习题","slug":"Js中的this练习题","date":"2021-09-09T07:05:22.000Z","updated":"2021-09-09T08:05:03.446Z","comments":true,"path":"2021/09/09/Js中的this练习题/","link":"","permalink":"http://oliverxuan.github.io/2021/09/09/Js%E4%B8%AD%E7%9A%84this%E7%BB%83%E4%B9%A0%E9%A2%98/","excerpt":"习题：练习题 1:12345678910111213141516var name = &#x27;window&#x27;var person = &#123; name: &#x27;person&#x27;, sayName: function () &#123; console.log(this.name) &#125;,&#125;function sayName() &#123; var sss = person.sayName sss() person.sayName() person.sayName() ;(b = person.sayName)()&#125; 练习题 2:1234567891011121314151617181920212223242526272829303132333435var name = &#x27;window&#x27;var person1 = &#123; name: &#x27;person1&#x27;, foo1: function () &#123; console.log(this.name) &#125;, foo2: () =&gt; console.log(this.name), foo3: function () &#123; return function () &#123; console.log(this.name) &#125; &#125;, foo4: function () &#123; return () =&gt; &#123; console.log(this.name) &#125; &#125;,&#125;var person2 = &#123; name: &#x27;person2&#x27; &#125;person1.foo1()person1.foo1.call(person2)person1.foo2()person1.foo2.call(person2)person1.foo3()()person1.foo3.call(person2)()person1.foo3().call(person2)person1.foo4()()person1.foo4.call(person2)()person1.foo4().call(person2) 练习题 3:123456789101112131415161718192021222324252627282930313233343536var name = &#x27;window&#x27;function Person(name) &#123; this.name = name ;(this.foo1 = function () &#123; console.log(this.name) &#125;), (this.foo2 = () =&gt; console.log(this.name)), (this.foo3 = function () &#123; return function () &#123; console.log(this.name) &#125; &#125;), (this.foo4 = function () &#123; return () =&gt; &#123; console.log(this.name) &#125; &#125;)&#125;var person1 = new Person(&#x27;person1&#x27;)var person2 = new Person(&#x27;person2&#x27;)person1.foo1()person1.foo1.call(person2)person1.foo2()person1.foo2.call(person2)person1.foo3()()person1.foo3.call(person2)()person1.foo3().call(person2)person1.foo4()()person1.foo4.call(person2)()person1.foo4().call(person2) 练习题 4:12345678910111213141516171819202122232425262728293031323334353637var name = &#x27;window&#x27;function Person(name) &#123; this.name = name this.obj = &#123; name: &#x27;obj&#x27;, foo1: function () &#123; return function () &#123; console.log(this.name) &#125; &#125;, foo2: function () &#123; return () =&gt; &#123; console.log(this.name) &#125; &#125;, &#125;&#125;var person1 = new Person(&#x27;person1&#x27;)var person2 = new Person(&#x27;person2&#x27;)person1.obj.foo1()()person1.obj.foo1.call(person2)()person1.obj.foo1().call(person2)person1.obj.foo2()()person1.obj.foo2.call(person2)()person1.obj.foo2().call(person2)//上层作用域的理解var obj = &#123; name: &#x27;obj&#x27;, foo: function () &#123; // 上层作用域是全局 &#125;,&#125; 习题题解：","text":"习题：练习题 1:12345678910111213141516var name = &#x27;window&#x27;var person = &#123; name: &#x27;person&#x27;, sayName: function () &#123; console.log(this.name) &#125;,&#125;function sayName() &#123; var sss = person.sayName sss() person.sayName() person.sayName() ;(b = person.sayName)()&#125; 练习题 2:1234567891011121314151617181920212223242526272829303132333435var name = &#x27;window&#x27;var person1 = &#123; name: &#x27;person1&#x27;, foo1: function () &#123; console.log(this.name) &#125;, foo2: () =&gt; console.log(this.name), foo3: function () &#123; return function () &#123; console.log(this.name) &#125; &#125;, foo4: function () &#123; return () =&gt; &#123; console.log(this.name) &#125; &#125;,&#125;var person2 = &#123; name: &#x27;person2&#x27; &#125;person1.foo1()person1.foo1.call(person2)person1.foo2()person1.foo2.call(person2)person1.foo3()()person1.foo3.call(person2)()person1.foo3().call(person2)person1.foo4()()person1.foo4.call(person2)()person1.foo4().call(person2) 练习题 3:123456789101112131415161718192021222324252627282930313233343536var name = &#x27;window&#x27;function Person(name) &#123; this.name = name ;(this.foo1 = function () &#123; console.log(this.name) &#125;), (this.foo2 = () =&gt; console.log(this.name)), (this.foo3 = function () &#123; return function () &#123; console.log(this.name) &#125; &#125;), (this.foo4 = function () &#123; return () =&gt; &#123; console.log(this.name) &#125; &#125;)&#125;var person1 = new Person(&#x27;person1&#x27;)var person2 = new Person(&#x27;person2&#x27;)person1.foo1()person1.foo1.call(person2)person1.foo2()person1.foo2.call(person2)person1.foo3()()person1.foo3.call(person2)()person1.foo3().call(person2)person1.foo4()()person1.foo4.call(person2)()person1.foo4().call(person2) 练习题 4:12345678910111213141516171819202122232425262728293031323334353637var name = &#x27;window&#x27;function Person(name) &#123; this.name = name this.obj = &#123; name: &#x27;obj&#x27;, foo1: function () &#123; return function () &#123; console.log(this.name) &#125; &#125;, foo2: function () &#123; return () =&gt; &#123; console.log(this.name) &#125; &#125;, &#125;&#125;var person1 = new Person(&#x27;person1&#x27;)var person2 = new Person(&#x27;person2&#x27;)person1.obj.foo1()()person1.obj.foo1.call(person2)()person1.obj.foo1().call(person2)person1.obj.foo2()()person1.obj.foo2.call(person2)()person1.obj.foo2().call(person2)//上层作用域的理解var obj = &#123; name: &#x27;obj&#x27;, foo: function () &#123; // 上层作用域是全局 &#125;,&#125; 习题题解：练习题 1:12345678910111213141516171819var name = &#x27;window&#x27;var person = &#123; name: &#x27;person&#x27;, sayName: function () &#123; console.log(this.name) &#125;,&#125;function sayName() &#123; var sss = person.sayName sss() //window 默认绑定，独立函数调用 person.sayName() //person 隐式绑定，通过person调用sayName（） person.sayName() //person 隐式绑定，通过person调用sayName（）， //实质上（）没有用，本身就是一个整体，只是用来混淆视听。 ;(b = person.sayName)() //window 默认绑定，独立函数调用，b接收了sayName（）后被独立调用&#125; 练习题 2:123456789101112131415161718192021222324252627282930313233343536373839404142434445var name = &#x27;window&#x27;var person1 = &#123; name: &#x27;person1&#x27;, foo1: function () &#123; console.log(this.name) &#125;, foo2: () =&gt; console.log(this.name), foo3: function () &#123; return function () &#123; console.log(this.name) &#125; &#125;, foo4: function () &#123; return () =&gt; &#123; console.log(this.name) &#125; &#125;,&#125;var person2 = &#123; name: &#x27;person2&#x27; &#125;person1.foo1() //person1 隐式绑定，通过person1来调用函数person1.foo1.call(person2) //person2 显式绑定，首先拿到了foo1的函数体，再通过call方法调用， //其中指定绑定了this为person2person1.foo2() //window 默认绑定，由于foo2是箭头函数，箭头函数不接受this对象，向上层寻找，上层是对象。//由于对象没有this指定，则它的this就指向了全局person1.foo2.call(person2) //window 默认绑定，拿到foo2后通过call（）调用，但是箭头函数不接受this对象，故为windowperson1.foo3()() //window 独立函数调用，通过person1拿到foo3函数体后，函数再执行。相当于是函数的独立调用person1.foo3.call(person2)() //person2 首先拿到了foo3函数，通过call我们拿到了return 的函数 再执行，相当于独立调用。person1.foo3().call(person2) //person2 显式绑定，通过foo3（）拿到了return函数，再通过call绑定了this运行。person1.foo4()() //person1 隐式绑定，首先foo4（）拿到了箭头函数，（）再执行，箭头函数中没有this指定//向上查找，由于上层为foo4（）foo4是由person1 调用执行的，故为隐式绑定person1.foo4.call(person2)() //person2 首先拿到了foo4 对其进行call绑定，foo4的作用域中this指向了person2//然后箭头函数向上查找，foo4的this以及变成了person2person1.foo4().call(person2) //person1 首先拿到了箭头函数，由于箭头函数不传值，直接调用，向上查找foo4的作用域//中this的指向，为person1 练习题 3:123456789101112131415161718192021222324252627282930313233343536var name = &#x27;window&#x27;function Person(name) &#123; this.name = name ;(this.foo1 = function () &#123; console.log(this.name) &#125;), (this.foo2 = () =&gt; console.log(this.name)), (this.foo3 = function () &#123; return function () &#123; console.log(this.name) &#125; &#125;), (this.foo4 = function () &#123; return () =&gt; &#123; console.log(this.name) &#125; &#125;)&#125;var person1 = new Person(&#x27;person1&#x27;)var person2 = new Person(&#x27;person2&#x27;)person1.foo1() //perosn1person1.foo1.call(person2) //perosn2 显式绑定person1.foo2() //person1 上级作用域中this指向的是person1person1.foo2.call(person2) //person1 call并不会改变箭头函数的this指向，上级作用域中this指向的是person1person1.foo3()() //window 独立函数调用person1.foo3.call(person2)() //window 独立函数调用person1.foo3().call(person2) //person2 显示绑定person1.foo4()() //perosn1 隐式绑定，拿到了箭头函数，再（），箭头函数向上查找，上级作用域this为perosn1person1.foo4.call(person2)() //perosn2 首先改变了foo4的this为perosn2，当箭头函数找的时候上级作用域已改变person1.foo4().call(person2) //perosn1 call无法改变箭头函数的this绑定值，箭头函数向上查找，为perosn1 练习题 4:123456789101112131415161718192021222324252627282930313233343536373839var name = &#x27;window&#x27;function Person(name) &#123; this.name = name this.obj = &#123; name: &#x27;obj&#x27;, foo1: function () &#123; return function () &#123; console.log(this.name) &#125; &#125;, foo2: function () &#123; return () =&gt; &#123; console.log(this.name) &#125; &#125;, &#125;&#125;var person1 = new Person(&#x27;person1&#x27;)var person2 = new Person(&#x27;person2&#x27;)person1.obj.foo1()() //window 独立函数调用person1.obj.foo1.call(person2)() //window 独立函数调用person1.obj.foo1().call(person2) //perosn2 显示绑定了person2person1.obj.foo2()() //obj，首先，我们foo2（），拿到了箭头函数，箭头函数向上查找，foo2是通过obj进行调用的//所以foo2的作用域中this为objperson1.obj.foo2.call(person2)() //perosn2 foo2的this通过call改变了，所以，箭头函数向上查找this时时person2person1.obj.foo2().call(person2) //obj call无法改变箭头函数的this//上层作用域的理解var obj = &#123; name: &#x27;obj&#x27;, foo: function () &#123; // 上层作用域是全局 &#125;,&#125; 总结首先感谢 coderwhy 老师提供的练习题与讲解，本文中的题解为个人理解，仅供参考。 关于箭头函数，不要忘记向上查找的规则 关于最后的（）要分析好是否为函数的独立调用 箭头函数向上查找的时候需要判断上层作用域到底是哪一个","categories":[{"name":"练习题","slug":"练习题","permalink":"http://oliverxuan.github.io/categories/%E7%BB%83%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://oliverxuan.github.io/tags/JavaScript/"}]},{"title":"Js中的This指向","slug":"Js中的This指向","date":"2021-09-08T03:02:23.000Z","updated":"2021-09-09T07:04:09.709Z","comments":true,"path":"2021/09/08/Js中的This指向/","link":"","permalink":"http://oliverxuan.github.io/2021/09/08/Js%E4%B8%AD%E7%9A%84This%E6%8C%87%E5%90%91/","excerpt":"Js 中什么是 This？为什么需要 this?在 Java 中 this 常用在关于类的操作中，我们常常可以用 this.的方式调用类的属性，方法。 相对于 Java。 Js 中的 this 用法可比 Java 中更灵活。 正也是因为灵活，让 Js 中的 this 常常让人摸不清头脑。 在 Js 中我们可以通过 this 方法，在不同的情况下，拿到不同的对象。有可能是全局对象(window)，也有可能是一个 Obj 对象,或者我们可以直接给我们的 this 指定绑定上一个对象。 this 指向什么呢？ 在全局的情况下，this 指向 window 1234console.log(this) //windowvar name = &#x27;Oliver&#x27;console.log(this.name) //oliverconsole.log(window.name) //oliver 但是，开发中很少直接在全局作用域下去使用 this，通常都是在函数中使用。 所有的函数在被调用时，都会创建一个执行上下文： 这个上下文中记录着函数的调用栈、AO 对象等； this 也是其中的一条记录； 我们先来看一个让人困惑的问题： 定义一个函数，我们采用三种不同的方式对它进行调用，它产生了三种不同的结果","text":"Js 中什么是 This？为什么需要 this?在 Java 中 this 常用在关于类的操作中，我们常常可以用 this.的方式调用类的属性，方法。 相对于 Java。 Js 中的 this 用法可比 Java 中更灵活。 正也是因为灵活，让 Js 中的 this 常常让人摸不清头脑。 在 Js 中我们可以通过 this 方法，在不同的情况下，拿到不同的对象。有可能是全局对象(window)，也有可能是一个 Obj 对象,或者我们可以直接给我们的 this 指定绑定上一个对象。 this 指向什么呢？ 在全局的情况下，this 指向 window 1234console.log(this) //windowvar name = &#x27;Oliver&#x27;console.log(this.name) //oliverconsole.log(window.name) //oliver 但是，开发中很少直接在全局作用域下去使用 this，通常都是在函数中使用。 所有的函数在被调用时，都会创建一个执行上下文： 这个上下文中记录着函数的调用栈、AO 对象等； this 也是其中的一条记录； 我们先来看一个让人困惑的问题： 定义一个函数，我们采用三种不同的方式对它进行调用，它产生了三种不同的结果 12345678910111213function foo() &#123; console.log(this)&#125;foo() //window 默认绑定var obj = &#123; name: &#x27;obj&#x27;, foo: foo,&#125;obj.foo() //obj对象 隐式绑定foo.apply(&#x27;abc&#x27;) //abc 显式绑定 这个的案例可以给我们什么样的启示呢？ 函数在调用时，JavaScript 会默认给 this 绑定一个值； this 的绑定和定义的位置（编写的位置）没有关系； this 的绑定和调用方式以及调用的位置有关系； this 是在运行时被绑定的； 重要结论： this 的指向，和它所处的位置无关和调用位置有关！ this 在被调用运行的时候，才会给他 this 绑定一个值！ this 绑定规则：绑定一：默认绑定绑定二：隐式绑定绑定三：显示绑定绑定四：new 绑定规则一：默认绑定什么情况下使用默认绑定呢？独立的函数调用 我们可以理解成函数没有被绑定到某个对象上进行调用 下面是一些默认绑定演示： 12345678910111213141516171819202122232425262728293031323334353637383940//1. windowfunction foo() &#123; console.log(this)&#125;foo()//2. windowfunction foo1() &#123; console.log(this)&#125;function foo2() &#123; console.log(this) foo1()&#125;function foo3() &#123; console.log(this) foo2()&#125;foo3()//3. windowvar obj = &#123; name: &#x27;obj&#x27;, foo: function () &#123; console.log(this) &#125;,&#125;var bar = obj.foo //将该对象中的方法传递给了bar 那么其实bar就是一个单独调用bar()//5. windowfunction foo() &#123; function bar() &#123; console.log(this) &#125; return bar&#125;var fn = foo() //实质上就是在调用bar 然后将bar传递给了fnfn() 默认绑定，独立函数调用 规则二：隐式绑定另外一种比较常见的调用方式是通过某个对象进行调用的： 也就是它的调用位置中，是通过某个对象发起的函数调用。 123456789101112function foo() &#123; console.log(this)&#125;var obj = &#123; name: &#x27;obj&#x27;, age: 19, fn: foo,&#125;//使用对象调用的方式来执行函数。obj.fn() //在对象里，将foo函数传递给了fn 实质上就是通过obj在调用 隐式绑定有前提条件： 必须在调用的对象内部有一个对函数的引用（比如一个属性）； 如果没有这样的引用，在进行调用时，会报找不到该函数的错误； 正是通过这个引用，间接的将this 绑定到了这个对象上； 规则三：显示绑定如果我们不希望在 对象内部 包含这个函数的引用，同时又希望在这个对象上进行强制调用，该怎么做呢？ JavaScript 所有的函数都可以使用call 和 apply 方法（这个和 Prototype 有关）。 其实非常简单，第一个参数是相同的，后面的参数，apply 为数组，call 为参数列表； 这两个函数的第一个参数都要求是一个对象，这个对象的作用是什么呢？就是给 this 准备的。 在调用这个函数时，会将 this 绑定到这个传入的对象上。 因为上面的过程，我们明确的绑定了 this 指向的对象，所以称之为 显示绑定。 通过 call 或者 apply 绑定 this 对象 call（ ）绑定，其第一参数为指定的 this 绑定对象，第二，三，N，参数为将要传入的参数 1234567function foo(num1, num2, num3) &#123; console.log(this) console.log(num1, num2, num3)&#125;foo.call(&#x27;call&#x27;, 1, 2, 3) //[String: &#x27;call&#x27;] 1 2 3foo.call(&#123; name: &#x27;yzx&#x27; &#125;) //&#123; name: &#x27;yzx&#x27; &#125; apply（ ）绑定，其第一参数为指定 this 绑定对象，第二参数为一个数组，其中包含了将要传入的参数 1234567function foo(num1, num2, num3) &#123; console.log(this) console.log(num1, num2, num3)&#125;foo.apply(&#x27;apply&#x27;, [1, 2, 3]) //[String: &#x27;apply&#x27;] 1 2 3foo.apply(&#123; name: &#x27;yzx&#x27;, age: 18 &#125;) //&#123; name: &#x27;yzx&#x27;, age: 18 &#125; 通过 bind 方法实现显示绑定 我们可以通过.bind 方法实现显示绑定 12345678910111213function foo() &#123; name: &#x27;foo&#x27;, console.log(this)&#125;var obj = &#123; name: &#x27;obj&#x27;, fn: foo,&#125;foo() //windowobj.fn() //objvar fn = obj.fn.bind(&#123; name: &#x27;Bind&#x27; &#125;)fn() //Bind 规则四：new 绑定JavaScript 中的函数可以当做一个类的构造函数来使用，也就是使用 new 关键字。 使用 new 关键字来调用函数是，会执行如下的操作： 创建一个全新的对象； 这个新对象会被执行 prototype 连接； 这个新对象会绑定到函数调用的 this 上（this 的绑定在这个步骤完成）； 如果函数没有返回其他对象，表达式会返回这个新对象； 1234567function Person(name) &#123; console.log(this) //Person&#123;&#125; this.name = name //Person&#123;name:Oliverxuan&#125;&#125;var p = new Person(&#x27;Oliverxuan&#x27;)console.log(p) 内置函数 this 绑定setTimeout（）1234//1. setTimeoutsetTimeout(function () &#123; console.log(this) //window&#125;, 2000) 监听点击1234const boxDiv = document.querySelector(&#x27;box&#x27;)boxDiv.onclick = function () &#123; console.log(this) //boxDiv&#123;&#125;&#125; 数组：filter/map/forEach 等高阶函数12345678910var names = [&#x27;abc&#x27;, &#x27;cba&#x27;]names.forEach(function (item) &#123; console.log(item, this) //abc&#123;&#125;&#125;, &#x27;abc&#x27;) //此处进行了this绑定var names = [&#x27;abc&#x27;, &#x27;cba&#x27;]names.forEach(function (item) &#123; console.log(item, this) // window&#125;) //此处没有进行this的绑定 规则优先级基本规则学习了四条规则，接下来开发中我们只需要去查找函数的调用应用了哪条规则即可，但是如果一个函数调用位置应用了多条规则，优先级谁更高呢？ 1. 默认规则的优先级最低 毫无疑问，默认规则的优先级是最低的，因为存在其他规则时，就会通过其他规则的方式来绑定 this 2. 显示绑定优先级高于默认绑定 代码测试： 12345678var obj = &#123; name: &#x27;obj&#x27;, foo: function () &#123; console.log(this) &#125;,&#125;obj.foo() // name:&#123; name: &#x27;obj&#x27;, foo: [Function: foo] &#125; 3 .显示绑定优先级高于隐式绑定 代码测试： 12345678910111213var obj = &#123; name: &#x27;obj&#x27;, foo: function () &#123; console.log(this) &#125;,&#125;obj.foo.call(&#x27;abc&#x27;) //[String: &#x27;abc&#x27;]obj.foo.apply(&#x27;abc&#x27;) //[String: &#x27;abc&#x27;]function foo() &#123; console.log(this)&#125; 4. bind 的优先级，高于隐式绑定 代码测试： 123456var obj = &#123; name: &#x27;obj&#x27;, foo: foo.bind(&#x27;aaa&#x27;),&#125;obj.foo() //[String: &#x27;aaa&#x27;] 6. new 绑定优先级高于显示绑定 new 绑定和call、apply 是不允许同时使用的，所以不存在谁的优先级更高 new 绑定可以和 bind 一起使用，new 绑定优先级更高 代码测试： 12345678var obj = &#123; name: &#x27;obj&#x27;, foo: function () &#123; console.log(this) &#125;,&#125;var f = new obj.foo() //foo&#123;&#125; 7. 小小总结 bind 优先级比较高 new &gt; 显示 &gt; 隐式 &gt; 默认绑定（独立函数调用） 规则之外常规情况 忽略显示绑定 12345678910111213function foo() &#123; console.log(this)&#125;foo.apply(&#x27;abc&#x27;)foo.apply(&#123;&#125;)foo.apply(null) //window 全局对象foo.apply(undefined) //window 全局对象foo.bind(null) //window 全局对象foo.bind(undefined) //window 全局对象var bar = foo.bind(null)bar() 间接函数引用 1234567891011121314151617181920212223242526272829var obj = &#123; name: &#x27;obj&#x27;, foo: function () &#123; console.log(this) &#125;,&#125;var obj2 = &#123; name: &#x27;obj2&#x27;,&#125;obj2.bar = obj.fooobj2.bar() //&#123; name: &#x27;obj2&#x27;, bar: [Function: foo] &#125;var obj = &#123; name: &#x27;obj&#x27;, foo: function () &#123; console.log(this) &#125;,&#125;var obj2 = &#123; name: &#x27;obj2&#x27;,&#125;obj2.bar = obj.fooobj2.bar()( //&#123; name: &#x27;obj2&#x27;, bar: [Function: foo] &#125; (obj2.bar = obj.foo))() // 没有 分号（；）无法运行 与上面的代码看成整体;(obj2.bar = obj.foo)() // 有 分号（；）window 独立调用 箭头函数特性： 箭头函数中 是不会绑定 this/arguments 属性 箭头函数不能作为函数构造器使用 四大规则 对箭头函数不适用 简写： 如果参数只有一个 小括号可以省略 123nums.forEach((item) =&gt; &#123; console.log(item)&#125;) 如果函数的函数执行体只有一行代码，大括号也可以省略 1234nums.forEach((item) =&gt; console.log(item))// 并且会默认地将代码的执行结果作为返回值var num = nums.filter((item) =&gt; item % 2 == 0)console.log(num) 如果一个箭头函数它的返回值，只有一行代码，且只返回一个对象 如果想简写 返回对象 需要在外层套一个（）以示整体 1var bar = () =&gt; (&#123; name: &#x27;oliver&#x27;, age: 12 &#125;) 总结JS 中的 this 十分灵活，需要结合各种情况进行分析。但是万变不离其宗。掌握特性，方可以一眼看穿真相！ JS 的优点是灵活，缺点也是灵活。想要真正掌握 JS 中的晦涩语法。还需要继续修炼内功 感谢 coderwhy 老师的课程以及公众号，能够让我细节地，全面地学习 JS","categories":[{"name":"底层逻辑","slug":"底层逻辑","permalink":"http://oliverxuan.github.io/categories/%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://oliverxuan.github.io/tags/JavaScript/"}]},{"title":"Js常用数组高阶函数","slug":"Js中的高阶函数","date":"2021-09-06T04:54:54.000Z","updated":"2021-09-15T06:46:56.758Z","comments":true,"path":"2021/09/06/Js中的高阶函数/","link":"","permalink":"http://oliverxuan.github.io/2021/09/06/Js%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/","excerpt":"js 中有很多高阶函数，能在日常的代码编写工作中提高效率。下面列举一些常用 js 的数组高阶函数 FOO 数组1var nums = [10, 5, 11, 100, 55] filter: 过滤返回布尔类型 可以传递三个值 item 当前的的元素，index 当前数组下标， arr 当前整个数组 12345//数组取偶操作var numbers = nums.filter((item, index, arr) =&gt; &#123; return item % 2 == 0&#125;)console.log(numbers) map: 映射对所有的 item 进行操作 12345//对每个item进行*10操作var nums2 = nums.map((item) =&gt; &#123; return item * 10&#125;)console.log(nums2) forEach: 迭代","text":"js 中有很多高阶函数，能在日常的代码编写工作中提高效率。下面列举一些常用 js 的数组高阶函数 FOO 数组1var nums = [10, 5, 11, 100, 55] filter: 过滤返回布尔类型 可以传递三个值 item 当前的的元素，index 当前数组下标， arr 当前整个数组 12345//数组取偶操作var numbers = nums.filter((item, index, arr) =&gt; &#123; return item % 2 == 0&#125;)console.log(numbers) map: 映射对所有的 item 进行操作 12345//对每个item进行*10操作var nums2 = nums.map((item) =&gt; &#123; return item * 10&#125;)console.log(nums2) forEach: 迭代无返回值 1234//遍历数组，无返回值！nums.forEach((item) =&gt; &#123; console.log(item)&#125;) find/findIndex :查找查找 item/返还该 item/itemIndex 1234var item = nums.find((item) =&gt; &#123; return item == 11&#125;)console.log(item) reduce :累加preValue 前数据; 0:基础数据 12345//数组累加操作var total = nums.reduce((preValue, item) =&gt; &#123; return preValue + item&#125;, 0)console.log(total) 总结js 中很多高阶函数，我们还需继续探索。慢慢感受 js 的魅力！","categories":[{"name":"技术实现","slug":"技术实现","permalink":"http://oliverxuan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://oliverxuan.github.io/tags/JavaScript/"}]},{"title":"浅谈js闭包","slug":"浅谈js闭包","date":"2021-09-05T11:53:27.000Z","updated":"2021-09-05T13:43:02.040Z","comments":true,"path":"2021/09/05/浅谈js闭包/","link":"","permalink":"http://oliverxuan.github.io/2021/09/05/%E6%B5%85%E8%B0%88js%E9%97%AD%E5%8C%85/","excerpt":"最近在学习 Javascript 高级语法，研究到了一些底层逻辑，有了很多的心得体会。赶紧记录下来！ 什么是 Js 闭包？ js 中函数是一等公民什么是一等公民？就好比 java 中的对象。js 中的函数十分灵活！ 函数可以作为另一个函数的参数，也可以作为另一个函数的返回值来使用 自己可以编写高阶函数 可以使用内置的高阶函数 代码演示： 函数作为一等公民，可以作为参数传入其他的函数中 1234567function calc(num1, num2, fnc) &#123; console.log(fnc(num1, num2))&#125;function add(num1, num2) &#123; return num1 + num2&#125;calc(20, 30, add)","text":"最近在学习 Javascript 高级语法，研究到了一些底层逻辑，有了很多的心得体会。赶紧记录下来！ 什么是 Js 闭包？ js 中函数是一等公民什么是一等公民？就好比 java 中的对象。js 中的函数十分灵活！ 函数可以作为另一个函数的参数，也可以作为另一个函数的返回值来使用 自己可以编写高阶函数 可以使用内置的高阶函数 代码演示： 函数作为一等公民，可以作为参数传入其他的函数中 1234567function calc(num1, num2, fnc) &#123; console.log(fnc(num1, num2))&#125;function add(num1, num2) &#123; return num1 + num2&#125;calc(20, 30, add) js 允许函数的嵌套定义 12345678910111213141516171819function foo() &#123; function bar() &#123; console.log(&#x27;bar&#x27;) &#125; return bar&#125;var fn = foo()fn() function makeAdder(count) function add(num) &#123; return count + num &#125; return add &#125; var add5 = makeAdder(5) var add10 = makeAdder(10) console.log(add5(10)) console.log(add10(10)) 高阶函数:把一个函数，接受另一个函数的返回值，作为参数使用，称为高阶函数。 js 中的闭包定义官方式定义：在计算机科学中对闭包的定义（维基百科）： 闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures）； 是在支持 头等函数 的编程语言中，实现词法绑定的一种技术； 闭包在实现上是一个结构体，它存储了一个函数和一个关联的环境（相当于一个符号查找表）； 闭包跟函数最大的区别在于，当捕捉闭包的时候，它的 自由变量 会在捕捉时被确定，这样即使脱离了捕捉时的上下文，它也能照常运行； MDN 对 JavaScript 闭包的解释： 一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）； 也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域； 在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来； 我对 Js 闭包的理解： 广义上来讲，js 中的函数都是闭包 狭义上来讲，js 中的一个函数，如果访问了外层作用域的变量，那它就是一个闭包。 闭包：函数+可以访问的自由变量 简单的闭包，以及逻辑： 简单描述逻辑：GO 对象，执行上下文调用栈 EcStack-&gt;全局执行上下文，VO：GO-&gt;解析函数，创建函数对象,上层作用域,函数执行体-&gt;函数执行上下文-&gt;执行代码-&gt;执行上下文销毁，AO 也销毁 闭包中的问题闭包中的某些 AO 为什么不会被销毁？这就涉及到 Js 的内存回收机制：垃圾回收器会定期从这个根开始，找所有从根开始有引用到的对象，对于哪些没有引用到的对象，就认为是不可用的对象； 我们可以参考： 12345678910111213function foo() &#123; var name = &#x27;foo&#x27; var age = 18 function bar() &#123; console.log(name) console.log(age) &#125; return bar&#125;var fn = foo()fn() 我们对 function bar 进行研究。 创建 GO 对象，包含了 fn：undefined ，foo：undefined 运行 foo（） 创建 foo 函数对象，其中包含了他作用域链，函数执行体；创建 foo AO 对象，name：undefined …，并对 bar（）进行预加载 执行 foo 函数，对 foo AO 进行修改。 创建 bar 函数对象，bar AO 其中 bar 的函数对象中 父级作用域是 foo，指向 foo AO 。 返回 bar（） fn 存储 bar 的地址 运行 fn（） bar 开始寻找相关的 name，age，bar AO 无，则向 foo AO 中寻找。 找到相关数据，执行函数。 由于我们可以很清楚地找到一条线：GO 的 fn（）-&gt; bar-&gt;bar AO 父级作用域指向 foo 的 AO 所以此时的 foo AO 不会被销毁，因为我们可以从根目录开始寻找这一条线路。 闭包内存泄漏由于某些 AO 一直存在，就有着内存泄漏的问题存在。 解决方法就直接将其指向 null 如： 12345678910111213141516function foo() &#123; var name = &#x27;foo&#x27; var age = 18 function bar() &#123; console.log(name) console.log(age) &#125; return bar&#125;var fn = foo()fn()fn = nullfoo = null 就可以解决这个问题 总结JavaScript 博大精深，还需继续努力，深入研究其中的原理。冲冲冲！","categories":[{"name":"底层逻辑","slug":"底层逻辑","permalink":"http://oliverxuan.github.io/categories/%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://oliverxuan.github.io/tags/JavaScript/"}]},{"title":"vue表单提交时自动刷新","slug":"vue表单提交时自动刷新","date":"2021-08-31T05:41:29.000Z","updated":"2021-08-31T07:47:23.348Z","comments":true,"path":"2021/08/31/vue表单提交时自动刷新/","link":"","permalink":"http://oliverxuan.github.io/2021/08/31/vue%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4%E6%97%B6%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0/","excerpt":"问题描述在之前 mmjd 的项目中，我设计了一个登陆的界面。发现当第一次提交的时候，会默认刷新一次。导致用户提交的表单是空的。从而报错。 这直接导致了很不好的用户体验。 解决方案vue 中使用表单 form 默认提交行为是刷新一下，在这儿我们使用事件修饰符 prevent 来阻止 form 表单的默认行为 1&lt;input type=&quot;submit&quot; value=&quot;提交&quot; @click.prevent=&#x27;had&#x27;&gt; 总结这个点似曾相识，在以前学习的时候老师好像提到过。自己没注意到细节上的东西。反向说明了自己对 vue 的一些细节，和项目经验不足。需要继续提高！","text":"问题描述在之前 mmjd 的项目中，我设计了一个登陆的界面。发现当第一次提交的时候，会默认刷新一次。导致用户提交的表单是空的。从而报错。 这直接导致了很不好的用户体验。 解决方案vue 中使用表单 form 默认提交行为是刷新一下，在这儿我们使用事件修饰符 prevent 来阻止 form 表单的默认行为 1&lt;input type=&quot;submit&quot; value=&quot;提交&quot; @click.prevent=&#x27;had&#x27;&gt; 总结这个点似曾相识，在以前学习的时候老师好像提到过。自己没注意到细节上的东西。反向说明了自己对 vue 的一些细节，和项目经验不足。需要继续提高！","categories":[{"name":"Obstacle","slug":"Obstacle","permalink":"http://oliverxuan.github.io/categories/Obstacle/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://oliverxuan.github.io/tags/vue/"}]},{"title":"通过node如何创建一个接口","slug":"通过node如何创建一个接口","date":"2021-08-31T05:18:58.000Z","updated":"2021-09-15T06:46:24.097Z","comments":true,"path":"2021/08/31/通过node如何创建一个接口/","link":"","permalink":"http://oliverxuan.github.io/2021/08/31/%E9%80%9A%E8%BF%87node%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3/","excerpt":"主要功能通过 node.js 环境与 Koa 框架，编写一个接口 实现方法 app 文件夹 1234567891011121314151617&lt;!-- index.js --&gt;//导入Koa框架const Koa = require(&#x27;koa&#x27;)const bodyParser = require(&#x27;koa-bodyparser&#x27;)const errorHandler = require(&#x27;./error-handle&#x27;)const useRoutes = require(&#x27;../router&#x27;)//新建Koa实例const app = new Koa()app.use(bodyParser())useRoutes(app)app.on(&#x27;error&#x27;, errorHandler)module.exports = app main.js 文件 main.js 文件一般是程序的主要入口 12345678910111213//导入之前创建的app实例const app = require(&#x27;./app&#x27;)//导入数据库相关配置require(&#x27;./app/database&#x27;)//导入相关配置const config = require(&#x27;./app/config&#x27;)//创建启动服务器app.listen(config.APP_PORT, () =&gt; &#123; console.log(`服务器在$&#123;config.APP_PORT&#125;端口已启动`)&#125;) router 文件夹index.js 文件 主要用来配置 router（路由）相关信息 12345678910111213141516//导入fs插件const fs = require(&#x27;fs&#x27;)//创建useRoutesconst useRoutes = (app) =&gt; &#123; //自动生成router相关配置 fs.readdirSync(__dirname).forEach((file) =&gt; &#123; if (file === &#x27;index.js&#x27;) return const router = require(`./$&#123;file&#125;`) app.use(router.routes()) app.use(router.allowedMethods()) &#125;)&#125;module.exports = useRoutes","text":"主要功能通过 node.js 环境与 Koa 框架，编写一个接口 实现方法 app 文件夹 1234567891011121314151617&lt;!-- index.js --&gt;//导入Koa框架const Koa = require(&#x27;koa&#x27;)const bodyParser = require(&#x27;koa-bodyparser&#x27;)const errorHandler = require(&#x27;./error-handle&#x27;)const useRoutes = require(&#x27;../router&#x27;)//新建Koa实例const app = new Koa()app.use(bodyParser())useRoutes(app)app.on(&#x27;error&#x27;, errorHandler)module.exports = app main.js 文件 main.js 文件一般是程序的主要入口 12345678910111213//导入之前创建的app实例const app = require(&#x27;./app&#x27;)//导入数据库相关配置require(&#x27;./app/database&#x27;)//导入相关配置const config = require(&#x27;./app/config&#x27;)//创建启动服务器app.listen(config.APP_PORT, () =&gt; &#123; console.log(`服务器在$&#123;config.APP_PORT&#125;端口已启动`)&#125;) router 文件夹index.js 文件 主要用来配置 router（路由）相关信息 12345678910111213141516//导入fs插件const fs = require(&#x27;fs&#x27;)//创建useRoutesconst useRoutes = (app) =&gt; &#123; //自动生成router相关配置 fs.readdirSync(__dirname).forEach((file) =&gt; &#123; if (file === &#x27;index.js&#x27;) return const router = require(`./$&#123;file&#125;`) app.use(router.routes()) app.use(router.allowedMethods()) &#125;)&#125;module.exports = useRoutes img.router.js 具体的路由文件 12345678910111213141516//导入koa路由const Router = require(&#x27;koa-router&#x27;)//制定接口的路径const imgRouter = new Router(&#123; prefix: &#x27;/mmjd&#x27; &#125;)//导入相关方法/中间件const &#123; getImgs,personType,personImgs &#125; = require(&#x27;../controller/img.controller&#x27;)const &#123; verifyAuth &#125; = require(&#x27;../middleware/auth.middleware&#x27;)//注册接口，并标明请求方法imgRouter.get(&#x27;/&#x27;, getImgs)imgRouter.post(&#x27;/personimg&#x27;,verifyAuth,personType,personImgs)module.exports = imgRouter 其次就是在 middleware 或者 controller，service 中写具体操作了 总结其中还是有很多细节的东西没有掌握好，此点需要以后继续深入研究！","categories":[{"name":"技术实现","slug":"技术实现","permalink":"http://oliverxuan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://oliverxuan.github.io/tags/node-js/"}]},{"title":"axios拦截","slug":"axios拦截","date":"2021-08-30T09:17:04.000Z","updated":"2021-09-15T06:46:39.502Z","comments":true,"path":"2021/08/30/axios拦截/","link":"","permalink":"http://oliverxuan.github.io/2021/08/30/axios%E6%8B%A6%E6%88%AA/","excerpt":"主要功能实现在 axios 每次请求/响应时，对请求/响应进行相关的处理。我们把这种处理方式称之为拦截。 实现方法 request.js 文件的封装 首先我们要将 axios 主要的请求封装在 request.js 文件中，这样我们可以降低代码的耦合度，提高整体的效率，方便后期的维护。12345678910111213141516//将axios插件导入import axios from &quot;axios&quot;;//创建axios方法，并将该方法导出export function request(config) &#123; // 1.创建axios的实例 const instance = axios.create(&#123; baseURL: &quot;*******&quot;, timeout: 5000 &#125;); // 2.设立请求/响应拦截 // 3.发送真正的网络请求 return instance(config);&#125; axios 拦截器 请求拦截 可以在任何的请求上进行修饰，改变。此处我以添加 Authorization：Token 的方法为例： 12345678910111213141516//使用axios的请求拦截方法instance.interceptors.request.use( //对参数进行处理 config =&gt; &#123; //具体操作 if (localStorage.getItem(&quot;Authorization&quot;)) &#123; config.headers.Authorization = localStorage.getItem(&quot;Authorization&quot;); &#125; //最后注意需要返回修饰后的参数 return config; &#125;, error =&gt; &#123; //如果请求是错误的，我们将异常抛出 return Promise.reject(error); &#125; );","text":"主要功能实现在 axios 每次请求/响应时，对请求/响应进行相关的处理。我们把这种处理方式称之为拦截。 实现方法 request.js 文件的封装 首先我们要将 axios 主要的请求封装在 request.js 文件中，这样我们可以降低代码的耦合度，提高整体的效率，方便后期的维护。12345678910111213141516//将axios插件导入import axios from &quot;axios&quot;;//创建axios方法，并将该方法导出export function request(config) &#123; // 1.创建axios的实例 const instance = axios.create(&#123; baseURL: &quot;*******&quot;, timeout: 5000 &#125;); // 2.设立请求/响应拦截 // 3.发送真正的网络请求 return instance(config);&#125; axios 拦截器 请求拦截 可以在任何的请求上进行修饰，改变。此处我以添加 Authorization：Token 的方法为例： 12345678910111213141516//使用axios的请求拦截方法instance.interceptors.request.use( //对参数进行处理 config =&gt; &#123; //具体操作 if (localStorage.getItem(&quot;Authorization&quot;)) &#123; config.headers.Authorization = localStorage.getItem(&quot;Authorization&quot;); &#125; //最后注意需要返回修饰后的参数 return config; &#125;, error =&gt; &#123; //如果请求是错误的，我们将异常抛出 return Promise.reject(error); &#125; ); 响应拦截 1234567891011121314151617181920//axios响应拦截方法instance.interceptors.response.use( res =&gt; &#123; //获取响应参数，并返回 return res.data; &#125;, err =&gt; &#123; //如果返还错误，提取相关的Status响应码，进行错误提示 const &#123; response &#125; = err; if ((response.status = 401)) &#123; localStorage.removeItem(&quot;Authorization&quot;); localStorage.removeItem(&quot;userName&quot;); localStorage.removeItem(&quot;userId&quot;); alert(&quot;请登陆后再使用哦～&quot;); &#125; else &#123; console.log(err); &#125; &#125; ); 后续调用 如需对接后端接口，仅需要创建相关 js 文件，并写入具体请求方法。 user.js 1234567891011121314151617181920212223242526//导入我们之前封装好的request文件import &#123; request &#125; from &quot;./request&quot;;//写具体的对接接口的方法export function GetUser() &#123; return request(&#123; url: &quot;/users/name&quot;, method: &quot;POST&quot; &#125;);&#125;//传参类：//将需要的参数写在方法内export function ChangeUserSkin(flag, type, fix) &#123; return request(&#123; url: &quot;/users/skintest&quot;, method: &quot;POST&quot;, //将所需的数据创建好。 data: &#123; flag: flag, type: type, fix: fix &#125; &#125;);&#125; 总结axios 在日常的 vue 开发中是使用频率很高的组件，用来进行前后端数据交互工作。整体上并不难。需要我们熟练掌握相关的方法，逻辑。其中也需要注意代码的规范，体现封装性。","categories":[{"name":"技术实现","slug":"技术实现","permalink":"http://oliverxuan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/"}],"tags":[{"name":"axios","slug":"axios","permalink":"http://oliverxuan.github.io/tags/axios/"}]},{"title":"mmjd项目的完成情况","slug":"mmjd项目的完成情况","date":"2021-08-24T17:24:58.000Z","updated":"2021-08-24T17:43:34.300Z","comments":true,"path":"2021/08/25/mmjd项目的完成情况/","link":"","permalink":"http://oliverxuan.github.io/2021/08/25/mmjd%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%AE%8C%E6%88%90%E6%83%85%E5%86%B5/","excerpt":"项目进度:最近一直在做那个护肤品测评网站，可谓是从无到有，功能也都在慢慢实现。目前已经完成了 90% 剩余的就是 Debug 和样式 接口功能：不多说了，直接上图！ 后端接口： 真的是完完整地做完了整个项目的后端接口。从中真的学会了很多！慢慢也熟悉了 Node.js + Koa 开发接口的开发逻辑。 Mysql： 从中也重新回忆起了很多的 sql 语句（真的好久不用生疏了！）比如：left join ，json_object…. 前端界面：现在的前端界面真的奇丑无比，等着这两天我调好了我们再看！","text":"项目进度:最近一直在做那个护肤品测评网站，可谓是从无到有，功能也都在慢慢实现。目前已经完成了 90% 剩余的就是 Debug 和样式 接口功能：不多说了，直接上图！ 后端接口： 真的是完完整地做完了整个项目的后端接口。从中真的学会了很多！慢慢也熟悉了 Node.js + Koa 开发接口的开发逻辑。 Mysql： 从中也重新回忆起了很多的 sql 语句（真的好久不用生疏了！）比如：left join ，json_object…. 前端界面：现在的前端界面真的奇丑无比，等着这两天我调好了我们再看！ 技术栈： 前端：Html JavaScript CSS Vue Vuex VueRouter axios Webpack node.js Bootstrap 后端：node.js Koa mysql 数据库: mysql 收获：通过这次完完整整地独自开发前后端的项目，很多东西真的就是要亲自来才能深刻体会！希望自己以后能参与或创造更多的项目！ 开源地址: 前端：https://github.com/Oliverxuan/mmjd 后端：https://github.com/Oliverxuan/MMJD-node","categories":[{"name":"CodeLife","slug":"CodeLife","permalink":"http://oliverxuan.github.io/categories/CodeLife/"}],"tags":[{"name":"项目","slug":"项目","permalink":"http://oliverxuan.github.io/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"创建用户并验证合法性","slug":"创建用户并验证合法性","date":"2021-08-15T16:10:04.000Z","updated":"2021-09-15T06:46:28.417Z","comments":true,"path":"2021/08/16/创建用户并验证合法性/","link":"","permalink":"http://oliverxuan.github.io/2021/08/16/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E5%B9%B6%E9%AA%8C%E8%AF%81%E5%90%88%E6%B3%95%E6%80%A7/","excerpt":"主要功能实现一个接口，可以读取用户的输入信息，并检查其合法性。如果其合法，将其录入数据库中，如果不合法，返回其不合法的类型。 实现方法1.创建数据库：1234567CREATE TABLE IF NOT EXISTS `users`(id INT PRIMARY KEY AUTO_INCREMENT,name VARCHAR(30) NOT NULL UNIQUE,password VARCHAR(50) NOT NULL,createAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,updateAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP); 2.连接数据库1.配置数据库信息 将数据库的配置写入 .env 文件中 1234567# mysql配置MYSQL_HOST=xxxxxxMYSQL_PORT=xxxxMYSQL_DATABASE=xxxxxMYSQL_ROOT=xxxxxMYSQL_PASSWORD=xxxxxx 将数据库信息在 config.js 文件中导入","text":"主要功能实现一个接口，可以读取用户的输入信息，并检查其合法性。如果其合法，将其录入数据库中，如果不合法，返回其不合法的类型。 实现方法1.创建数据库：1234567CREATE TABLE IF NOT EXISTS `users`(id INT PRIMARY KEY AUTO_INCREMENT,name VARCHAR(30) NOT NULL UNIQUE,password VARCHAR(50) NOT NULL,createAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,updateAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP); 2.连接数据库1.配置数据库信息 将数据库的配置写入 .env 文件中 1234567# mysql配置MYSQL_HOST=xxxxxxMYSQL_PORT=xxxxMYSQL_DATABASE=xxxxxMYSQL_ROOT=xxxxxMYSQL_PASSWORD=xxxxxx 将数据库信息在 config.js 文件中导入 12345678module.exports = &#123; APP_PORT, MYSQL_HOST, MYSQL_PORT, MYSQL_DATABASE, MYSQL_ROOT, MYSQL_PASSWORD,&#125; = process.env 2.建立数据库连接 在全局文件夹（app）里新建关于数据库操作的 database.js 文件 导入 mysql 插件 1const mysql = require(&#x27;mysql2&#x27;) 将配置信息导入 1const config = require(&#x27;./config&#x27;) 创建数据库连接池,并将相关配置导入 12345678const connections = mysql.createPool(&#123; host: config.MYSQL_HOST, port: config.MYSQL_PORT, database: config.MYSQL_DATABASE, user: config.MYSQL_ROOT, password: config.MYSQL_PASSWORD,&#125;) 取得数据库连接，并设置数据库启动提示 123456789connections.getConnection((err, conn) =&gt; &#123; conn.connect((err) =&gt; &#123; if (err) &#123; console.log(&#x27;数据库连接失败!&#x27;) &#125; else &#123; console.log(&#x27;数据库连接成功！&#x27;) &#125; &#125;)&#125;) 将 connections 导出，从而达到封装。 12//操作都是建立在connections.promise（）上的，所以在导出的时候连带promise()module.exports = connections.promise() 在 main.js 中引入 database.js，从而达到加载目的 12require(&#x27;./app/database&#x27;) 测试连接,得到回应： 3.实现数据库的存入 实现 create 方法 12//查询数据 const result = await service.create(user) 在 service 的 user.service.js 中写入数据库操作 12345678910//操作都是异步的所以要加上async awaitasync create(user) &#123; //从user中获取user，password const &#123; name, password &#125; = user //sql语句 const statement = &#x27;INSERT INTO users (name,password) VALUES (?,?);&#x27; //执行sql语句，并将查询结果返还至result中 const result = await connection.execute(statement, [name, password]) return result[0] &#125; 执行结果 优化过程：验证输入的合法性 创建验证中间件 verifyUser ,并写入 UserRouter 中 1userRouter.post(&#x27;/&#x27;, verifyUser, create) 由于此类型的中间件在后续开发中会频繁创建，故统一在 middleware.js 中创建 12345678910111213141516171819202122232425262728293031323334353637383940// 导入错误类型const errorType = require(&#x27;../constants/error-types&#x27;)// 导入service 利用其中的getUserByName来验证是否已存在该用户const service = require(&#x27;../service/user.service&#x27;)//创建中间件，注意其也是异步操作！const verifyUser = async (ctx, next) =&gt; &#123; //获取用户名，密码 const &#123; name, password &#125; = ctx.request.body //判断不能为空 if (!name || !password) &#123; //如果为空，则新建Error，其错误类型为：NAME_OR_PASSWORD_IS_REQUIRED const error = new Error(errorType.NAME_OR_PASSWORD_IS_REQUIRED) //将错误发射出去 return ctx.app.emit(&#x27;error&#x27;, error, ctx) &#125; //判断本次注册的用户名是否被注册 const result = await service.getUserByNanme(name) //如果返还不为NULL if (result.length) &#123; //新建error 错误类型为：USER_ALREADY_EXISTS const error = new Error(errorType.USER_ALREADY_EXISTS) //将错误发射出去 return ctx.app.emit(&#x27;error&#x27;, error, ctx) &#125; //如果以上都未执行，则进行下一个中间件：create await next()&#125;//导出verifyUsermodule.exports = &#123; verifyUser,&#125; errorType 的创建由于以后的错误类型会有很多，所以统一写入在 errorType 中 1234567const NAME_OR_PASSWORD_IS_REQUIRED = &#x27;name_or_password_is_required&#x27;const USER_ALREADY_EXISTS = &#x27;user_already_exists&#x27;module.exports = &#123; NAME_OR_PASSWORD_IS_REQUIRED, USER_ALREADY_EXISTS,&#125; service 中的 getUserByName 方法 1234567async getUserByNanme(name) &#123; const statement = `SELECT * FROM users WHERE name = ?;` const result = await connection.execute(statement, [name]) return result[0]&#125; 在 index.js 中接收报错信息 12app.on(&#x27;error&#x27;, errorHandler) 创建错误处理 error-handle.js在其中统一处理错误信息 12345678910111213141516171819202122232425262728293031//导入错误类型const errorTypes = require(&#x27;../constants/error-types&#x27;)// 导入之前发射出来的参数error，ctx，并进行分析处理const errorHandler = (error, ctx) =&gt; &#123; //建立状态变量，和报错提示 let status, message //通过传入的错误类型来判断处理方式 switch (error.message) &#123; case errorTypes.NAME_OR_PASSWORD_IS_REQUIRED: status = 400 //Bad request message = &#x27;用户名或者密码为空&#x27; break case errorTypes.USER_ALREADY_EXISTS: console.log(&#x27;1&#x27;) status = 409 //Conflict message = &#x27;用户名已存在&#x27; break default: status = 404 message = &#x27;NOT FOUND&#x27; &#125; //将错误信息导入ctx中 ctx.status = status ctx.body = message&#125;module.exports = errorHandler 错误展示用户已存在：状态码： 用户输入名或密码为空:状态码： 总结经过今天的汇总，逐渐将其中的思路理清楚，为以后开发接口提供了思路。","categories":[{"name":"技术实现","slug":"技术实现","permalink":"http://oliverxuan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://oliverxuan.github.io/tags/node-js/"}]},{"title":"node.js 用户登陆初体验","slug":"node-js-用户登陆初体验","date":"2021-08-13T16:59:57.000Z","updated":"2021-09-15T06:47:09.500Z","comments":true,"path":"2021/08/14/node-js-用户登陆初体验/","link":"","permalink":"http://oliverxuan.github.io/2021/08/14/node-js-%E7%94%A8%E6%88%B7%E7%99%BB%E9%99%86%E5%88%9D%E4%BD%93%E9%AA%8C/","excerpt":"实现目标写一个接口，实现从用户输入中获得数据 技术点文件夹功能分类 app (app 操作文件夹) index.js (导入所使用的插件，中间件) 12345678910111213141516// 导入所需的插件，中间件const Koa = require(&#x27;koa&#x27;)const bodyParser = require(&#x27;koa-bodyparser&#x27;)const userRouter = require(&#x27;../router/user.router&#x27;)//实例化Koa对象const app = new Koa()//注册/使用插件，中间件app.use(bodyParser())app.use(userRouter.routes())app.use(userRouter.allowedMethods())//导出app 以便其他模块使用module.exports = app config.js (配置操作) 12345678//导入插件const dotenv = require(&#x27;dotenv&#x27;)//使用插件的方法，导入写好的配置文件（.env）dotenv.config()module.exports = &#123; APP_PORT &#125; = process.env main.js (程序的总入口)","text":"实现目标写一个接口，实现从用户输入中获得数据 技术点文件夹功能分类 app (app 操作文件夹) index.js (导入所使用的插件，中间件) 12345678910111213141516// 导入所需的插件，中间件const Koa = require(&#x27;koa&#x27;)const bodyParser = require(&#x27;koa-bodyparser&#x27;)const userRouter = require(&#x27;../router/user.router&#x27;)//实例化Koa对象const app = new Koa()//注册/使用插件，中间件app.use(bodyParser())app.use(userRouter.routes())app.use(userRouter.allowedMethods())//导出app 以便其他模块使用module.exports = app config.js (配置操作) 12345678//导入插件const dotenv = require(&#x27;dotenv&#x27;)//使用插件的方法，导入写好的配置文件（.env）dotenv.config()module.exports = &#123; APP_PORT &#125; = process.env main.js (程序的总入口) 123456789// 导入之前的Koa实例化的对象app。 导入配置文件const app = require(&#x27;./app&#x27;)const config = require(&#x27;./app/config&#x27;)//创建服务器，并利用config的APP_PORT参数app.listen(config.APP_PORT, () =&gt; &#123; console.log(`服务器在$&#123;config.APP_PORT&#125;端口已启动`)&#125;) router (所有的路由管理文件夹) user.router.js (user 的路由管理) 12345678910111213141516// 路由相关的js 注册接口适用//导入koa-router组件const Router = require(&#x27;koa-router&#x27;)//导入方法const &#123; create &#125; = require(&#x27;../controller/user.controller&#x27;)//注册路由 其路径为/usersconst userRouter = new Router(&#123; prefix: &#x27;/users&#x27; &#125;)//设置路由的响应方式，响应方法userRouter.post(&#x27;/&#x27;, create)//导出路由module.exports = userRouter controller (管理不同路径下的不同的情况下的方法，操作) user.controller.js (user 的一些方法，操作) 12345678910111213141516171819//导入写好的方法const service = require(&#x27;../service/user.service&#x27;)//创建类 其中包含了不同情况下的不同方法class UserController &#123; async create(ctx, next) &#123; //获取用户请求的参数 const user = ctx.request.body //查询数据 const result = await service.create(user) //返回数据 ctx.body = result &#125;&#125;module.exports = new UserController() service (业务层，其一般对接着 mysql 数据库操作) user.service.js 1234567891011//创建类class UserService &#123; async create(user) &#123; console.log(&#x27;将用户数据保存到数据库中&#x27;, user) //将user存储到数据库中 return &#x27;创建用户成功&#x27; &#125;&#125;module.exports = new UserService() utils (工具类) .env (配置文件) 123# 服务器端口号APP_PORT=8000 实现结果 总结本次实现了一个小功能，主要目的是想让自己理清楚这个文件与文件之间的关系，以及不同的文件之间的分工。","categories":[{"name":"技术实现","slug":"技术实现","permalink":"http://oliverxuan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://oliverxuan.github.io/tags/node-js/"}]},{"title":"Better-scroll 中无法滚动问题","slug":"Better-scroll-中无法滚动问题","date":"2021-08-11T06:25:44.000Z","updated":"2021-08-31T05:42:20.684Z","comments":true,"path":"2021/08/11/Better-scroll-中无法滚动问题/","link":"","permalink":"http://oliverxuan.github.io/2021/08/11/Better-scroll-%E4%B8%AD%E6%97%A0%E6%B3%95%E6%BB%9A%E5%8A%A8%E9%97%AE%E9%A2%98/","excerpt":"问题描述在昨天我在使用 Vue 开发前端页面的时候，我遇到了在使用 better-scroll 实现页面滚动的时候无法滚动经过排查，问题出在与 better-scroll 的滚动原理与实际高度之间产生矛盾（图片异步加载问题） 问题分析在之前的 GoodsList 组件中，有一个加载接口图片的操作 12345678910&lt;template&gt; &lt;div class=&quot;goods-item&quot;&gt; &lt;img :src=&quot;goodsItem.img&quot; alt=&quot;&quot; /&gt; &lt;div class=&quot;goods-info&quot;&gt; &lt;p&gt;&#123;&#123; goodsItem.name &#125;&#125;&lt;/p&gt; &lt;span class=&quot;price&quot;&gt;RMB:&#123;&#123; goodsItem.price &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 由于 better-scroll 在计算 wrapper content 高度的时候是在一开始就会计算好 从而达到滚动的目的 但是 Goods list 会加载网路图片，存在一个异步问题加载完后，实际的高度会远超于之前 better-scroll 计算的高度 从而导致 better-scroll 之间计算无效了，最终无法滚动 解决方法123456789&lt;template&gt; &lt;div class=&quot;goods-item&quot;&gt; &lt;img :src=&quot;goodsItem.img&quot; alt=&quot;&quot; @load=&quot;imageload&quot; /&gt; &lt;div class=&quot;goods-info&quot;&gt; &lt;p&gt;&#123;&#123; goodsItem.name &#125;&#125;&lt;/p&gt; &lt;span class=&quot;price&quot;&gt;RMB:&#123;&#123; goodsItem.price &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;","text":"问题描述在昨天我在使用 Vue 开发前端页面的时候，我遇到了在使用 better-scroll 实现页面滚动的时候无法滚动经过排查，问题出在与 better-scroll 的滚动原理与实际高度之间产生矛盾（图片异步加载问题） 问题分析在之前的 GoodsList 组件中，有一个加载接口图片的操作 12345678910&lt;template&gt; &lt;div class=&quot;goods-item&quot;&gt; &lt;img :src=&quot;goodsItem.img&quot; alt=&quot;&quot; /&gt; &lt;div class=&quot;goods-info&quot;&gt; &lt;p&gt;&#123;&#123; goodsItem.name &#125;&#125;&lt;/p&gt; &lt;span class=&quot;price&quot;&gt;RMB:&#123;&#123; goodsItem.price &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 由于 better-scroll 在计算 wrapper content 高度的时候是在一开始就会计算好 从而达到滚动的目的 但是 Goods list 会加载网路图片，存在一个异步问题加载完后，实际的高度会远超于之前 better-scroll 计算的高度 从而导致 better-scroll 之间计算无效了，最终无法滚动 解决方法123456789&lt;template&gt; &lt;div class=&quot;goods-item&quot;&gt; &lt;img :src=&quot;goodsItem.img&quot; alt=&quot;&quot; @load=&quot;imageload&quot; /&gt; &lt;div class=&quot;goods-info&quot;&gt; &lt;p&gt;&#123;&#123; goodsItem.name &#125;&#125;&lt;/p&gt; &lt;span class=&quot;price&quot;&gt;RMB:&#123;&#123; goodsItem.price &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 在原代码 “&lt; img &gt;”标签处新增 @load=”imageload“ 监听事件 12345methods: &#123; imageload() &#123; this.$bus.$emit(&quot;itemImageLoad&quot;); &#125; &#125; 随后在方法里将此事件发射到事件总线里面 注意，需要在 main.js 里注册 事件总线 12345678910111213import Vue from &quot;vue&quot;;import App from &quot;./App.vue&quot;;import router from &quot;./router&quot;;import store from &quot;./store&quot;;Vue.config.productionTip = false;Vue.prototype.$bus = new Vue();new Vue(&#123; router, store, render: h =&gt; h(App)&#125;).$mount(&quot;#app&quot;); 将事件传入事件总线后 需要在 better-scroll 滚动页面里面监听事件 12345mounted() &#123; this.$bus.$on(&quot;itemImageLoad&quot;, () =&gt; &#123; this.$refs.scroll.scroll.refresh(); &#125;); &#125;, 提前设置 better-scroll 中的 refs 从而方便操作 最后监听到图片加载后 调用 scroll 的 refresh（）函数达到重新计算高度的目的 性能优化由于之前的频繁发出事件 image load 导致 实际上会 refresh 很多次 此处就需要 dbounce 防抖函数来处理 ： 12345678910function debounce(fn,delay)&#123; var handle; return function()&#123; clearTimeout(handle) handle=setTimeout(function()&#123; fn() &#125;,delay) &#125; &#125; 从而达到性能优化的目的","categories":[{"name":"Obstacle","slug":"Obstacle","permalink":"http://oliverxuan.github.io/categories/Obstacle/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://oliverxuan.github.io/tags/vue/"}]},{"title":"Hello,好久不见","slug":"Hello-好久不见","date":"2021-08-11T06:04:48.000Z","updated":"2021-08-11T06:25:13.431Z","comments":true,"path":"2021/08/11/Hello-好久不见/","link":"","permalink":"http://oliverxuan.github.io/2021/08/11/Hello-%E5%A5%BD%E4%B9%85%E4%B8%8D%E8%A7%81/","excerpt":"最近都去干什么了？距离上次更新我的博客已经过去了 10 多天了，在这段时间里我开始新的征程 =&gt; 准备 9 月份的 辽宁省大学生移动开发大赛 我计划着开发一个护肤品测评网站，整个网站的架构为：前端：Vue 全家桶，axios 后端：Node.js，express 数据库：Mysql 期间遇到的问题困难由于我之前没有涉及过后端的接口开发，所以我在这 10 天的时间里自学了一点 Node.js 的开发基础。顺便学习了 Express，Koa 框架的基本开发。 到目前为止，我已成功地将写好的使用 Express 的 Js 程序用 Node.js 部署在我的云服务器上。 在这其中我遇到了很多的困难，例如： 在服务器上部署合适的 Node &amp; Mysql 如何在本地通过 ssh 连接远端服务器","text":"最近都去干什么了？距离上次更新我的博客已经过去了 10 多天了，在这段时间里我开始新的征程 =&gt; 准备 9 月份的 辽宁省大学生移动开发大赛 我计划着开发一个护肤品测评网站，整个网站的架构为：前端：Vue 全家桶，axios 后端：Node.js，express 数据库：Mysql 期间遇到的问题困难由于我之前没有涉及过后端的接口开发，所以我在这 10 天的时间里自学了一点 Node.js 的开发基础。顺便学习了 Express，Koa 框架的基本开发。 到目前为止，我已成功地将写好的使用 Express 的 Js 程序用 Node.js 部署在我的云服务器上。 在这其中我遇到了很多的困难，例如： 在服务器上部署合适的 Node &amp; Mysql 如何在本地通过 ssh 连接远端服务器 ssh root@ip 如何在 vs code navicat-mysql ssh 连接远端数据 vs code 通过远程资源管理器 mysql 里设置可远端读写权限 navicat 在建立连接时正确写入服务器中的数据库信息 注意需要在服务器安全组里开放相应的端口 建立数据库，在 Vue 里通过 axios 连接远端数据库 处理接口数据 如何在服务器上一直运行 Node 项目 npm2 管理插件 在此感谢前辈们在遇到困难时留下的宝贵经验，以至于我在后续开发时遇到问题都能及时解决","categories":[{"name":"CodeLife","slug":"CodeLife","permalink":"http://oliverxuan.github.io/categories/CodeLife/"}],"tags":[{"name":"规划","slug":"规划","permalink":"http://oliverxuan.github.io/tags/%E8%A7%84%E5%88%92/"}]},{"title":"岛屿问题的实现","slug":"岛屿问题的实现","date":"2021-07-31T06:42:14.000Z","updated":"2021-09-14T07:41:54.388Z","comments":true,"path":"2021/07/31/岛屿问题的实现/","link":"","permalink":"http://oliverxuan.github.io/2021/07/31/%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"问题描述给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/number-of-islands著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解决方案此问题与上一期的门墙算法的实现的思想基本一致，属于利用队列，以及广度优先搜索（dfs）的方式解决问题。但是并不是完全的相同。本问题需要注意在于广度优先搜索的时候，需要有“感染”的思想。 首先遍历整个二维数组，寻找数组中的岛 再在孤岛的基础上 遍历他的上下左右临格元素 是否也为“1”岛屿 如果是 将它感染。 1234567891011121314151617181920212223242526272829public class Solution &#123; public int numIslands(char[][] grid) &#123; if(grid.length==0)&#123; return 0; &#125; int count=0; for (int i = 0; i &lt; grid.length; i++) &#123; for (int j = 0; j &lt; grid[0].length; j++) &#123; if(grid[i][j]==&#x27;1&#x27;)&#123; count++; dfs(grid,i,j); &#125; &#125; &#125; return count; &#125; private void dfs(char[][] grid, int i, int j) &#123; if(i&lt;0 || i&gt;= grid.length || j&lt;0 || j&gt;=grid[0].length || grid[i][j]==&#x27;0&#x27;)&#123; return; &#125; grid[i][j]=&#x27;0&#x27;; dfs(grid, i - 1, j); dfs(grid, i + 1, j); dfs(grid, i, j + 1); dfs(grid, i, j - 1); &#125;&#125;","text":"问题描述给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/number-of-islands著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解决方案此问题与上一期的门墙算法的实现的思想基本一致，属于利用队列，以及广度优先搜索（dfs）的方式解决问题。但是并不是完全的相同。本问题需要注意在于广度优先搜索的时候，需要有“感染”的思想。 首先遍历整个二维数组，寻找数组中的岛 再在孤岛的基础上 遍历他的上下左右临格元素 是否也为“1”岛屿 如果是 将它感染。 1234567891011121314151617181920212223242526272829public class Solution &#123; public int numIslands(char[][] grid) &#123; if(grid.length==0)&#123; return 0; &#125; int count=0; for (int i = 0; i &lt; grid.length; i++) &#123; for (int j = 0; j &lt; grid[0].length; j++) &#123; if(grid[i][j]==&#x27;1&#x27;)&#123; count++; dfs(grid,i,j); &#125; &#125; &#125; return count; &#125; private void dfs(char[][] grid, int i, int j) &#123; if(i&lt;0 || i&gt;= grid.length || j&lt;0 || j&gt;=grid[0].length || grid[i][j]==&#x27;0&#x27;)&#123; return; &#125; grid[i][j]=&#x27;0&#x27;; dfs(grid, i - 1, j); dfs(grid, i + 1, j); dfs(grid, i, j + 1); dfs(grid, i, j - 1); &#125;&#125;","categories":[{"name":"Problems","slug":"Problems","permalink":"http://oliverxuan.github.io/categories/Problems/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://oliverxuan.github.io/tags/leetcode/"}]},{"title":"门与墙算法的实现","slug":"门与墙算法的实现","date":"2021-07-29T14:50:18.000Z","updated":"2021-07-30T15:16:58.408Z","comments":true,"path":"2021/07/29/门与墙算法的实现/","link":"","permalink":"http://oliverxuan.github.io/2021/07/29/%E9%97%A8%E4%B8%8E%E5%A2%99%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"问题描述：你被给定一个 m × n 的二维网格 rooms ，网格中有以下三种可能的初始化值：-1 表示墙或是障碍物 0 表示一扇门INF 无限表示一个空的房间。然后，我们用 231 - 1 = 2147483647 代表 INF。你可以认为通往门的距离总是小于 2147483647 的。你要给每个空房间位上填上该房间到 最近门的距离 ，如果无法到达门，则填 INF 即可。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/walls-and-gates著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 建立基本数据以及辅助坐标 先寻找门坐标，将其入队 取出队头元素 A 进行解析 分析 A 上下左右 block 是否可用 合法 A 是否未赋值 将合法的 block 进行赋值（步数） 将新的 block 入队 结束条件当取出的区域 上下左右都已经赋值 ｜｜ 为墙，为门 则无需处理，退出处理队列 本题的突破点: 理解队列先进先出的性质 广度优先搜索的性质 先找门，后赋值的思路 ps：block 我的定义是 INF 即可用的房间","text":"问题描述：你被给定一个 m × n 的二维网格 rooms ，网格中有以下三种可能的初始化值：-1 表示墙或是障碍物 0 表示一扇门INF 无限表示一个空的房间。然后，我们用 231 - 1 = 2147483647 代表 INF。你可以认为通往门的距离总是小于 2147483647 的。你要给每个空房间位上填上该房间到 最近门的距离 ，如果无法到达门，则填 INF 即可。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/walls-and-gates著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 建立基本数据以及辅助坐标 先寻找门坐标，将其入队 取出队头元素 A 进行解析 分析 A 上下左右 block 是否可用 合法 A 是否未赋值 将合法的 block 进行赋值（步数） 将新的 block 入队 结束条件当取出的区域 上下左右都已经赋值 ｜｜ 为墙，为门 则无需处理，退出处理队列 本题的突破点: 理解队列先进先出的性质 广度优先搜索的性质 先找门，后赋值的思路 ps：block 我的定义是 INF 即可用的房间 实现难点 如何寻找 block 的上下左右房间 该房间的周围空间是否有用 能否联想到新的 block 就当作是一个新门，再从新门找他的上下左右 block 如何进行数据处理 细节处理 象形理解把每一个门当作一个大的问题小孩（类似孩子王），队列就是记录未解决问题小孩的清单。我们把每一个 INF 区域当作一个医生，安排医生用最小的距离去解决这些问题小孩。我们先在房间里寻找大问题小孩，将他们全部记录在清单上。我们开始分析他周围是否也有问题小孩（孩子王的小跟班）（上下左右检查）如果有（该区域为空）且该问题其他医生没有解决（未赋值）我们就指派该区域的医生去解决这个问题小孩，并且记录该问题小孩离孩子王有多远。（为 block 赋值）如果周围的问题小孩已经有医生解决了，我们就不管。将新的问题小孩记录在队列上，原先的孩子王的下线已经全盘供出，所以他从问题清单上划除。继续解决清单上的新的问题小孩….（可能有点不怎么容易理解。。。。我真的尽力了 源码 yyds ） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Solution &#123; //定义空房间的特征值 private static final int INF = 2147483647; //定义门的特殊值 private static final int DOOR = 0; //定义辅助坐标 以此来表示房间的上下左右 private static final List&lt;int[]&gt; DIRECTIONS = Arrays.asList( new int[]&#123;1, 0&#125;, new int[]&#123;-1, 0&#125;, new int[]&#123;0, -1&#125;, new int[]&#123;0, 1&#125; ); public void wallsAndGates(int[][] rooms) &#123; //记录房间的长宽 int m= rooms.length; int n=rooms[0].length; if(m==0)&#123; return; &#125; //创建队列 Queue&lt;int []&gt; queue=new LinkedList&lt;&gt;(); //遍历rooms 寻找所有的门 for (int row = 0; row &lt; m; row++) &#123; for (int col = 0; col &lt; n; col++) &#123; //当检测到该地区为门的时候 将门的坐标元素入队 if(rooms[row][col]==DOOR)&#123; queue.add(new int[]&#123;row,col&#125;); &#125; &#125; &#125; //核心区域 （当队列不为空的时候，继续执行） while(!queue.isEmpty())&#123; //取出队头的元素 也是最先入队的元素 （ d,c,b,a =&gt; a) int[] block = queue.poll(); //记录原生的行，列数据 int row=block[0]; int col=block[1]; //制造当前block的上下左右block 利用辅助坐标快速制作出新的坐标数据 for (int [] direction: DIRECTIONS) &#123; int r=row+direction[0]; int c=col+direction[1]; //判断新的坐标是否合法 是否存在障碍物 ！！（重点！）是否之前已经被被赋值过！！ //如果已经被赋值 说明当前值就是该区域的最短路径，再次改变就是不准确值 // 因为是广度优先 所以当前值一定是最优值 if(r&lt;0 || c&lt;0 || r&gt;=rooms.length || c&gt;=rooms[0].length || rooms[r][c]!=INF)&#123; continue; &#125; //细节点 需要在前一个block的值上进行+1 否则步数全为1 rooms[r][c]=rooms[row][col]+1; //如果都不是 则为全新的为赋值block 将其加入队列（列尾） queue.add(new int[]&#123;r,c&#125;); &#125; &#125; &#125;&#125;","categories":[{"name":"Problems","slug":"Problems","permalink":"http://oliverxuan.github.io/categories/Problems/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://oliverxuan.github.io/tags/leetcode/"}]},{"title":"循环队列的实现","slug":"循环队列的实现","date":"2021-07-27T17:21:50.000Z","updated":"2021-07-30T15:17:02.169Z","comments":true,"path":"2021/07/28/循环队列的实现/","link":"","permalink":"http://oliverxuan.github.io/2021/07/28/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"问题描述：设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。 循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。 你的实现应该支持如下操作： MyCircularQueue(k): 构造器，设置队列长度为 k 。Front: 从队首获取元素。如果队列为空，返回 -1 。Rear: 获取队尾元素。如果队列为空，返回 -1 。enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。isEmpty(): 检查循环队列是否为空。isFull(): 检查循环队列是否已满。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/design-circular-queue 示例：MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3circularQueue.enQueue(1); // 返回 truecircularQueue.enQueue(2); // 返回 truecircularQueue.enQueue(3); // 返回 truecircularQueue.enQueue(4); // 返回 false，队列已满circularQueue.Rear(); // 返回 3circularQueue.isFull(); // 返回 truecircularQueue.deQueue(); // 返回 truecircularQueue.enQueue(4); // 返回 truecircularQueue.Rear(); // 返回 4 解题思路： 首先要明白循环队列的原理 如何设计循环队列中的两个指针 细节处理","text":"问题描述：设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。 循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。 你的实现应该支持如下操作： MyCircularQueue(k): 构造器，设置队列长度为 k 。Front: 从队首获取元素。如果队列为空，返回 -1 。Rear: 获取队尾元素。如果队列为空，返回 -1 。enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。isEmpty(): 检查循环队列是否为空。isFull(): 检查循环队列是否已满。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/design-circular-queue 示例：MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3circularQueue.enQueue(1); // 返回 truecircularQueue.enQueue(2); // 返回 truecircularQueue.enQueue(3); // 返回 truecircularQueue.enQueue(4); // 返回 false，队列已满circularQueue.Rear(); // 返回 3circularQueue.isFull(); // 返回 truecircularQueue.deQueue(); // 返回 truecircularQueue.enQueue(4); // 返回 truecircularQueue.Rear(); // 返回 4 解题思路： 首先要明白循环队列的原理 如何设计循环队列中的两个指针 细节处理 循环队列原理https://www.bilibili.com/video/BV1yx411e7nb?from=search&amp;seid=13632348157331521482/ 实现难点： 为什么要在 eg：head（head+1）% size 取模？ 为什么 get tail 的时候不能直接返回？ 细节处理 实现代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class MyCircularQueue &#123; //构造原始数组 int[] arr; //数组长度 int size; //头指针，记录循环列表的头部 int head; //尾指针，记录循环列表的尾部 int tail; //计数器，记录总共有多少个元素 int count; //构造器，将原始的数组arr转化为实体，以及一些变量的初始化 public MyCircularQueue(int k) &#123; arr = new int[k]; size = k; head = 0; tail = 0; count = 0; &#125; //入队操作 public boolean enQueue(int value) &#123; //先判断队列是否已满。 if (isFull()) &#123; return false; &#125; arr[tail] = value; //关键点！此处的指针也应该跟着循环，不能说到了数组的size（最大长度）就一直无限延续 //所以这里需要取模运算&quot;%&quot; 例：k=size=7 tail=7 tail=（7+1%7=1 所以下次tail //的位置就在下角标为 1 的位置 从而达到循环指针的目的 后面的head指针同理 tail = (tail + 1) % size; count++; return true; &#125; //出队操作 public boolean deQueue() &#123; //判断是否为空 if (isEmpty()) &#123; return false; &#125; head = (head + 1) % size; count--; return true; &#125; //取头元素 public int Front() &#123; if (isEmpty()) &#123; return -1; &#125; return arr[head]; &#125; public int Rear() &#123; if(isEmpty())&#123; return -1; &#125; //此处需要注意tail的真实位置到底指向的是哪里。 //注意数据的处理不能取负。 return arr[(tail - 1 + size) % size]; &#125; //判断空 public boolean isEmpty() &#123; return count==0; &#125; //判断满 public boolean isFull() &#123; return size==count; &#125;&#125; 总结：在对循环队列实现的时候，注意的细节点有很多，需要做到指针循环才能达到整体的循环目的。总的来说还是难度中等。","categories":[{"name":"Problems","slug":"Problems","permalink":"http://oliverxuan.github.io/categories/Problems/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://oliverxuan.github.io/tags/leetcode/"}]},{"title":"hexo s 时4000端口被占用问题","slug":"hexo-s-时4000端口被占用问题","date":"2021-07-25T14:47:18.000Z","updated":"2021-07-29T17:24:31.003Z","comments":true,"path":"2021/07/25/hexo-s-时4000端口被占用问题/","link":"","permalink":"http://oliverxuan.github.io/2021/07/25/hexo-s-%E6%97%B64000%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98/","excerpt":"问题描述：hexo s 启动的时候遇到了 4000 端口无法创建使用的问题。具体打开 localhost：4000 发现 4000 端口下 hexo 依然在运行！ 解决方案：(mac 环境): sudo lsof -i tcp:4000查询当前端口的进程 报错： 12COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEnode 19087 root 23u IPv6 0xe0d367ae3505eeb3 0t0 TCP *:terabase (LISTEN) 发现进程 19087 sudo kill 19087 再次打开就没有 hexo 的页面了 最后成功在 4000 默认端口下启动 hexo","text":"问题描述：hexo s 启动的时候遇到了 4000 端口无法创建使用的问题。具体打开 localhost：4000 发现 4000 端口下 hexo 依然在运行！ 解决方案：(mac 环境): sudo lsof -i tcp:4000查询当前端口的进程 报错： 12COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEnode 19087 root 23u IPv6 0xe0d367ae3505eeb3 0t0 TCP *:terabase (LISTEN) 发现进程 19087 sudo kill 19087 再次打开就没有 hexo 的页面了 最后成功在 4000 默认端口下启动 hexo","categories":[{"name":"Obstacle","slug":"Obstacle","permalink":"http://oliverxuan.github.io/categories/Obstacle/"}],"tags":[{"name":"技术踩坑","slug":"技术踩坑","permalink":"http://oliverxuan.github.io/tags/%E6%8A%80%E6%9C%AF%E8%B8%A9%E5%9D%91/"}]},{"title":"关于大三一年的计划","slug":"关于大三一年的计划","date":"2021-07-25T14:39:56.000Z","updated":"2021-07-30T15:18:55.613Z","comments":true,"path":"2021/07/25/关于大三一年的计划/","link":"","permalink":"http://oliverxuan.github.io/2021/07/25/%E5%85%B3%E4%BA%8E%E5%A4%A7%E4%B8%89%E4%B8%80%E5%B9%B4%E7%9A%84%E8%AE%A1%E5%88%92/","excerpt":"大三这一年真的是无比关键.想着明年的今天就是我实习的日子.心里多少还是有些焦虑。 回顾自身：大一光顾着玩耍，等到大一暑假的时候突然感觉”玩的索然无味“玩的甚至有点空虚。觉得这不是自己想要的生活。于是放下了我喜欢的游戏。打开了哔哩哔哩，搜起了关于 Java 的教学视频，我还记着我第一次装 Jdk 第一次配置环境变量的时候的一脸懵逼。（这和我学的 C 不一样呀）好奇心促使我继续坚持学习了下去。就这样，我听着尚硅谷的宋红康老师的 Java 课程度过了第一个充实的暑假，也是在那个暑假，我渐渐地明白了，计算机的路，我才刚刚开始。等到了大二，我渐渐尝试着做一些简单的静态页面，跟着做一些简单的 JavaWeb 项目。当我第一次在我自己的数据库接收到前端页面发来的数据的时候，我真的无比激动！这真的是一件很有成就感的事情！到了大二的下学期，在好朋友的指引下，我渐渐接触一些更深层次的东西，我学习了 CoderWhy 老师的 Vue，学完了 Vue 我也深刻体会到组件化开发的便利性。真的佩服我们的尤大佬！能开发出这么好的框架！我什么时候才能到达他这种能力呀！大二这一年，是我学习进步最快的一年，我渐渐明白到了真正的差距到底有多大。所以我想在我大三这一年，有计划有目标地进行学习！争取在一年后的今天能取得互联网大厂的 offer！ 大三规划：大方向：扎实内功，基础。深入底层逻辑，原理。追求技术深度。多总结，多学习。具体目标，步骤: 复习巩固计算机原理，数据结构等计算机基础。（巩固基础） leetcode 坚持每天刷题。（巩固基础） 学习 Node.js 以达到能够做出前后端分离的全栈完整项目。（完善自己的技术面） 学习 uniapp 或 flutter 以达到跨平台，多处运用的目的。（完善自己的技术面） 深入研究 Javascript，Vue 的底层逻辑，以及源码。以达到一定的技术深度。（提高自己技术深度） 多做项目，多参加比赛。提高自己的眼界，技术的多样性，学习别人的优点，改善自己的不足。（提高自己技术深度）","text":"大三这一年真的是无比关键.想着明年的今天就是我实习的日子.心里多少还是有些焦虑。 回顾自身：大一光顾着玩耍，等到大一暑假的时候突然感觉”玩的索然无味“玩的甚至有点空虚。觉得这不是自己想要的生活。于是放下了我喜欢的游戏。打开了哔哩哔哩，搜起了关于 Java 的教学视频，我还记着我第一次装 Jdk 第一次配置环境变量的时候的一脸懵逼。（这和我学的 C 不一样呀）好奇心促使我继续坚持学习了下去。就这样，我听着尚硅谷的宋红康老师的 Java 课程度过了第一个充实的暑假，也是在那个暑假，我渐渐地明白了，计算机的路，我才刚刚开始。等到了大二，我渐渐尝试着做一些简单的静态页面，跟着做一些简单的 JavaWeb 项目。当我第一次在我自己的数据库接收到前端页面发来的数据的时候，我真的无比激动！这真的是一件很有成就感的事情！到了大二的下学期，在好朋友的指引下，我渐渐接触一些更深层次的东西，我学习了 CoderWhy 老师的 Vue，学完了 Vue 我也深刻体会到组件化开发的便利性。真的佩服我们的尤大佬！能开发出这么好的框架！我什么时候才能到达他这种能力呀！大二这一年，是我学习进步最快的一年，我渐渐明白到了真正的差距到底有多大。所以我想在我大三这一年，有计划有目标地进行学习！争取在一年后的今天能取得互联网大厂的 offer！ 大三规划：大方向：扎实内功，基础。深入底层逻辑，原理。追求技术深度。多总结，多学习。具体目标，步骤: 复习巩固计算机原理，数据结构等计算机基础。（巩固基础） leetcode 坚持每天刷题。（巩固基础） 学习 Node.js 以达到能够做出前后端分离的全栈完整项目。（完善自己的技术面） 学习 uniapp 或 flutter 以达到跨平台，多处运用的目的。（完善自己的技术面） 深入研究 Javascript，Vue 的底层逻辑，以及源码。以达到一定的技术深度。（提高自己技术深度） 多做项目，多参加比赛。提高自己的眼界，技术的多样性，学习别人的优点，改善自己的不足。（提高自己技术深度）","categories":[{"name":"CodeLife","slug":"CodeLife","permalink":"http://oliverxuan.github.io/categories/CodeLife/"}],"tags":[{"name":"规划","slug":"规划","permalink":"http://oliverxuan.github.io/tags/%E8%A7%84%E5%88%92/"}]}],"categories":[{"name":"底层逻辑","slug":"底层逻辑","permalink":"http://oliverxuan.github.io/categories/%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/"},{"name":"技术实现","slug":"技术实现","permalink":"http://oliverxuan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/"},{"name":"练习题","slug":"练习题","permalink":"http://oliverxuan.github.io/categories/%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"name":"Obstacle","slug":"Obstacle","permalink":"http://oliverxuan.github.io/categories/Obstacle/"},{"name":"CodeLife","slug":"CodeLife","permalink":"http://oliverxuan.github.io/categories/CodeLife/"},{"name":"Problems","slug":"Problems","permalink":"http://oliverxuan.github.io/categories/Problems/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://oliverxuan.github.io/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://oliverxuan.github.io/tags/React/"},{"name":"vue","slug":"vue","permalink":"http://oliverxuan.github.io/tags/vue/"},{"name":"node.js","slug":"node-js","permalink":"http://oliverxuan.github.io/tags/node-js/"},{"name":"axios","slug":"axios","permalink":"http://oliverxuan.github.io/tags/axios/"},{"name":"项目","slug":"项目","permalink":"http://oliverxuan.github.io/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"规划","slug":"规划","permalink":"http://oliverxuan.github.io/tags/%E8%A7%84%E5%88%92/"},{"name":"leetcode","slug":"leetcode","permalink":"http://oliverxuan.github.io/tags/leetcode/"},{"name":"技术踩坑","slug":"技术踩坑","permalink":"http://oliverxuan.github.io/tags/%E6%8A%80%E6%9C%AF%E8%B8%A9%E5%9D%91/"}]}